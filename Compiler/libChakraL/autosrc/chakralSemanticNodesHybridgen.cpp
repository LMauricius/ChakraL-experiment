// This file is autogenerated. Edit only function bodies!

#include "../include/chakralServer.h"
#include "../autoinclude/chakralSemanticNodesAutogen.h"
#include <ostream>

namespace ChakraL
{
    
    // === *** ContextBlock *** ===
    
    std::string_view SemanticNode_ContextBlock::className() const {
        return "ContextBlock";
    }
    
    void SemanticNode_ContextBlock::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ContextBlock\"," << std::endl; 
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "descs: [" << std::endl;
        for (auto& ptr : descs) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; ptr->print(out, tabs+2, tabstr); out << "," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ContextBlock::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + descs.size() + 0);
        for (const auto& ptr : descs) {ret.push_back(ptr.get());}
        return ret;
    }
    
    ContextPtr SemanticNode_ContextBlock::baseContext(Server& server, Scope& scope) {
        if (!mCached_baseContext.has_value()) {
            mCached_baseContext = std::optional<ContextPtr>{get_baseContext(server, scope)};
        }
        return mCached_baseContext.value();
    }
    
    ContextPtr SemanticNode_ContextBlock::get_baseContext(Server& server, Scope& scope) {
    }
    
    void SemanticNode_ContextBlock::outputInternalCDeclaration(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_ContextBlock::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_ContextBlock::outputInternalCDefinition(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_ContextBlock::outputCInclude(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_ContextBlock::outputCPPInclude(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** Description *** ===
    
    std::string_view SemanticNode_Description::className() const {
        return "Description";
    }
    
    void SemanticNode_Description::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"Description\"," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_Description::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** Requirement *** ===
    
    std::string_view SemanticNode_Requirement::className() const {
        return "Requirement";
    }
    
    void SemanticNode_Requirement::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"Requirement\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "cond: "; 
        if (cond) cond->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_Requirement::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            cond.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** Inclusion *** ===
    
    std::string_view SemanticNode_Inclusion::className() const {
        return "Inclusion";
    }
    
    void SemanticNode_Inclusion::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"Inclusion\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "value: "; 
        if (value) value->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_Inclusion::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            value.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** TraitSpecifier *** ===
    
    std::string_view SemanticNode_TraitSpecifier::className() const {
        return "TraitSpecifier";
    }
    
    void SemanticNode_TraitSpecifier::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"TraitSpecifier\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "token: "; 
        out<< "\"" << token.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_TraitSpecifier::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** Statement *** ===
    
    std::string_view SemanticNode_Statement::className() const {
        return "Statement";
    }
    
    void SemanticNode_Statement::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"Statement\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "exec: "; 
        if (exec) exec->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_Statement::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            exec.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    void SemanticNode_Statement::outputInternalCDeclaration(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_Statement::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_Statement::outputInternalCDefinition(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** MemberDecl *** ===
    
    std::string_view SemanticNode_MemberDecl::className() const {
        return "MemberDecl";
    }
    
    void SemanticNode_MemberDecl::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"MemberDecl\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "member: "; 
        if (member) member->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "valueSpecs: [" << std::endl;
        for (auto& ptr : valueSpecs) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; ptr->print(out, tabs+2, tabstr); out << "," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "value: "; 
        if (value) value->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "trait: "; 
        if (trait) trait->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_MemberDecl::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            member.get(),
            value.get(),
            trait.get(),
        };
        ret.reserve(ret.size() + valueSpecs.size() + 0);
        for (const auto& ptr : valueSpecs) {ret.push_back(ptr.get());}
        return ret;
    }
    
    void SemanticNode_MemberDecl::outputInternalCDeclaration(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_MemberDecl::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_MemberDecl::outputInternalCDefinition(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** Definition *** ===
    
    std::string_view SemanticNode_Definition::className() const {
        return "Definition";
    }
    
    void SemanticNode_Definition::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"Definition\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "id: "; 
        out<< "\"" << id.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "value: "; 
        if (value) value->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_Definition::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            value.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    uint64_t SemanticNode_Definition::nameHash(Server& server, Scope& scope) {
        if (!mCached_nameHash.has_value()) {
            mCached_nameHash = std::optional<uint64_t>{get_nameHash(server, scope)};
        }
        return mCached_nameHash.value();
    }
    
    uint64_t SemanticNode_Definition::get_nameHash(Server& server, Scope& scope) {
    }
    
    std::string SemanticNode_Definition::hintName(Server& server, Scope& scope) {
        if (!mCached_hintName.has_value()) {
            mCached_hintName = std::optional<std::string>{get_hintName(server, scope)};
        }
        return mCached_hintName.value();
    }
    
    std::string SemanticNode_Definition::get_hintName(Server& server, Scope& scope) {
    }
    
    std::string SemanticNode_Definition::shortName(Server& server, Scope& scope) {
        if (!mCached_shortName.has_value()) {
            mCached_shortName = std::optional<std::string>{get_shortName(server, scope)};
        }
        return mCached_shortName.value();
    }
    
    std::string SemanticNode_Definition::get_shortName(Server& server, Scope& scope) {
    }
    
    std::string SemanticNode_Definition::longName(Server& server, Scope& scope) {
        if (!mCached_longName.has_value()) {
            mCached_longName = std::optional<std::string>{get_longName(server, scope)};
        }
        return mCached_longName.value();
    }
    
    std::string SemanticNode_Definition::get_longName(Server& server, Scope& scope) {
    }
    
    std::string SemanticNode_Definition::uniqueName(Server& server, Scope& scope) {
        if (!mCached_uniqueName.has_value()) {
            mCached_uniqueName = std::optional<std::string>{get_uniqueName(server, scope)};
        }
        return mCached_uniqueName.value();
    }
    
    std::string SemanticNode_Definition::get_uniqueName(Server& server, Scope& scope) {
    }
    
    void SemanticNode_Definition::outputInternalCDeclaration(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_Definition::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_Definition::outputInternalCDefinition(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** Change *** ===
    
    std::string_view SemanticNode_Change::className() const {
        return "Change";
    }
    
    void SemanticNode_Change::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"Change\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "left: "; 
        if (left) left->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "op: "; 
        if (op) op->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "rights: "; 
        if (rights) rights->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_Change::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            left.get(),
            op.get(),
            rights.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    void SemanticNode_Change::outputInternalCDeclaration(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_Change::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_Change::outputInternalCDefinition(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** IfStat *** ===
    
    std::string_view SemanticNode_IfStat::className() const {
        return "IfStat";
    }
    
    void SemanticNode_IfStat::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"IfStat\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "cond: "; 
        if (cond) cond->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "exec: "; 
        if (exec) exec->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "alt: "; 
        if (alt) alt->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_IfStat::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            cond.get(),
            exec.get(),
            alt.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    void SemanticNode_IfStat::outputInternalCDeclaration(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_IfStat::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_IfStat::outputInternalCDefinition(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** LoopStat *** ===
    
    std::string_view SemanticNode_LoopStat::className() const {
        return "LoopStat";
    }
    
    void SemanticNode_LoopStat::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"LoopStat\"," << std::endl; 
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "parts: [" << std::endl;
        for (auto& ptr : parts) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; ptr->print(out, tabs+2, tabstr); out << "," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "block: "; 
        if (block) block->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_LoopStat::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            block.get(),
        };
        ret.reserve(ret.size() + parts.size() + 0);
        for (const auto& ptr : parts) {ret.push_back(ptr.get());}
        return ret;
    }
    
    void SemanticNode_LoopStat::outputInternalCDeclaration(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_LoopStat::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_LoopStat::outputInternalCDefinition(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** LoopStatPart *** ===
    
    std::string_view SemanticNode_LoopStatPart::className() const {
        return "LoopStatPart";
    }
    
    void SemanticNode_LoopStatPart::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"LoopStatPart\"," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_LoopStatPart::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** TimesLoopStatPart *** ===
    
    std::string_view SemanticNode_TimesLoopStatPart::className() const {
        return "TimesLoopStatPart";
    }
    
    void SemanticNode_TimesLoopStatPart::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"TimesLoopStatPart\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "count: "; 
        if (count) count->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_TimesLoopStatPart::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            count.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** ForLoopStatPart *** ===
    
    std::string_view SemanticNode_ForLoopStatPart::className() const {
        return "ForLoopStatPart";
    }
    
    void SemanticNode_ForLoopStatPart::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ForLoopStatPart\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "id: "; 
        out<< "\"" << id.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "iterable: "; 
        if (iterable) iterable->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ForLoopStatPart::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            iterable.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** WhileLoopStatPart *** ===
    
    std::string_view SemanticNode_WhileLoopStatPart::className() const {
        return "WhileLoopStatPart";
    }
    
    void SemanticNode_WhileLoopStatPart::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"WhileLoopStatPart\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "cond: "; 
        if (cond) cond->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_WhileLoopStatPart::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            cond.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** JumpStat *** ===
    
    std::string_view SemanticNode_JumpStat::className() const {
        return "JumpStat";
    }
    
    void SemanticNode_JumpStat::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"JumpStat\"," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_JumpStat::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    void SemanticNode_JumpStat::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_JumpStat::outputInternalCDefinition(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** WithStat *** ===
    
    std::string_view SemanticNode_WithStat::className() const {
        return "WithStat";
    }
    
    void SemanticNode_WithStat::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"WithStat\"," << std::endl; 
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "funcs: [" << std::endl;
        for (auto& tok : funcs) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; out << "\"" << tok.fullname() << "\"," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "entries: [" << std::endl;
        for (auto& ptr : entries) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; ptr->print(out, tabs+2, tabstr); out << "," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "block: "; 
        if (block) block->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_WithStat::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            block.get(),
        };
        ret.reserve(ret.size() + entries.size() + 0);
        for (const auto& ptr : entries) {ret.push_back(ptr.get());}
        return ret;
    }
    
    void SemanticNode_WithStat::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_WithStat::outputInternalCDefinition(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** BreakStat *** ===
    
    std::string_view SemanticNode_BreakStat::className() const {
        return "BreakStat";
    }
    
    void SemanticNode_BreakStat::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"BreakStat\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "id: "; 
        out<< "\"" << id.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_BreakStat::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** ContinueStat *** ===
    
    std::string_view SemanticNode_ContinueStat::className() const {
        return "ContinueStat";
    }
    
    void SemanticNode_ContinueStat::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ContinueStat\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "id: "; 
        out<< "\"" << id.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ContinueStat::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** ReturnStat *** ===
    
    std::string_view SemanticNode_ReturnStat::className() const {
        return "ReturnStat";
    }
    
    void SemanticNode_ReturnStat::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ReturnStat\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "val: "; 
        if (val) val->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ReturnStat::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            val.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** YieldStat *** ===
    
    std::string_view SemanticNode_YieldStat::className() const {
        return "YieldStat";
    }
    
    void SemanticNode_YieldStat::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"YieldStat\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "val: "; 
        if (val) val->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_YieldStat::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            val.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** Expression *** ===
    
    std::string_view SemanticNode_Expression::className() const {
        return "Expression";
    }
    
    void SemanticNode_Expression::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"Expression\"," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_Expression::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    Value SemanticNode_Expression::value(Server& server, Scope& scope) {
        if (!mCached_value.has_value()) {
            mCached_value = std::optional<Value>{get_value(server, scope)};
        }
        return mCached_value.value();
    }
    
    Value SemanticNode_Expression::get_value(Server& server, Scope& scope) {
    }
    
    Identifier SemanticNode_Expression::idName() {
        if (!mCached_idName.has_value()) {
            mCached_idName = std::optional<Identifier>{get_idName()};
        }
        return mCached_idName.value();
    }
    
    Identifier SemanticNode_Expression::get_idName() {
    }
    
    void SemanticNode_Expression::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_Expression::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** ExprBinaryL2R *** ===
    
    std::string_view SemanticNode_ExprBinaryL2R::className() const {
        return "ExprBinaryL2R";
    }
    
    void SemanticNode_ExprBinaryL2R::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ExprBinaryL2R\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "left: "; 
        if (left) left->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "operators: [" << std::endl;
        for (auto& tok : operators) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; out << "\"" << tok.fullname() << "\"," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "right: "; 
        if (right) right->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "operands: [" << std::endl;
        for (auto& ptr : operands) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; ptr->print(out, tabs+2, tabstr); out << "," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ExprBinaryL2R::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            left.get(),
            right.get(),
        };
        ret.reserve(ret.size() + operands.size() + 0);
        for (const auto& ptr : operands) {ret.push_back(ptr.get());}
        return ret;
    }
    
    void SemanticNode_ExprBinaryL2R::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_ExprBinaryL2R::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** ExprLUnary *** ===
    
    std::string_view SemanticNode_ExprLUnary::className() const {
        return "ExprLUnary";
    }
    
    void SemanticNode_ExprLUnary::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ExprLUnary\"," << std::endl; 
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "operators: [" << std::endl;
        for (auto& tok : operators) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; out << "\"" << tok.fullname() << "\"," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "operand: "; 
        if (operand) operand->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ExprLUnary::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            operand.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    void SemanticNode_ExprLUnary::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_ExprLUnary::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** ExprRUnary *** ===
    
    std::string_view SemanticNode_ExprRUnary::className() const {
        return "ExprRUnary";
    }
    
    void SemanticNode_ExprRUnary::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ExprRUnary\"," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ExprRUnary::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    void SemanticNode_ExprRUnary::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_ExprRUnary::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** TightExpr *** ===
    
    std::string_view SemanticNode_TightExpr::className() const {
        return "TightExpr";
    }
    
    void SemanticNode_TightExpr::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"TightExpr\"," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_TightExpr::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    void SemanticNode_TightExpr::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_TightExpr::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** LogicalExpr *** ===
    
    std::string_view SemanticNode_LogicalExpr::className() const {
        return "LogicalExpr";
    }
    
    void SemanticNode_LogicalExpr::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"LogicalExpr\"," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_LogicalExpr::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    void SemanticNode_LogicalExpr::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_LogicalExpr::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** ExprPrefixFunction *** ===
    
    std::string_view SemanticNode_ExprPrefixFunction::className() const {
        return "ExprPrefixFunction";
    }
    
    void SemanticNode_ExprPrefixFunction::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ExprPrefixFunction\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "left: "; 
        if (left) left->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "right: "; 
        if (right) right->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ExprPrefixFunction::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            left.get(),
            right.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    void SemanticNode_ExprPrefixFunction::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_ExprPrefixFunction::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** RangeLiteral *** ===
    
    std::string_view SemanticNode_RangeLiteral::className() const {
        return "RangeLiteral";
    }
    
    void SemanticNode_RangeLiteral::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"RangeLiteral\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "left: "; 
        if (left) left->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "operators: [" << std::endl;
        for (auto& ptr : operators) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; ptr->print(out, tabs+2, tabstr); out << "," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "right: "; 
        if (right) right->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_RangeLiteral::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            left.get(),
            right.get(),
        };
        ret.reserve(ret.size() + operators.size() + 0);
        for (const auto& ptr : operators) {ret.push_back(ptr.get());}
        return ret;
    }
    
    void SemanticNode_RangeLiteral::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_RangeLiteral::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** Identifier *** ===
    
    std::string_view SemanticNode_Identifier::className() const {
        return "Identifier";
    }
    
    void SemanticNode_Identifier::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"Identifier\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "name: "; 
        out<< "\"" << name.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "unary_op: "; 
        if (unary_op) unary_op->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "binary_op: "; 
        if (binary_op) binary_op->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "suf: "; 
        out<< "\"" << suf.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_Identifier::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            unary_op.get(),
            binary_op.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    Identifier SemanticNode_Identifier::idName() {
        if (!mCached_idName.has_value()) {
            mCached_idName = std::optional<Identifier>{get_idName()};
        }
        return mCached_idName.value();
    }
    
    Identifier SemanticNode_Identifier::get_idName() {
    }
    
    void SemanticNode_Identifier::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_Identifier::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** Literal *** ===
    
    std::string_view SemanticNode_Literal::className() const {
        return "Literal";
    }
    
    void SemanticNode_Literal::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"Literal\"," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_Literal::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** FunctionLiteral *** ===
    
    std::string_view SemanticNode_FunctionLiteral::className() const {
        return "FunctionLiteral";
    }
    
    void SemanticNode_FunctionLiteral::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"FunctionLiteral\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "param: "; 
        if (param) param->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "block: "; 
        if (block) block->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_FunctionLiteral::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            param.get(),
            block.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    void SemanticNode_FunctionLiteral::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_FunctionLiteral::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** CoroutineLiteral *** ===
    
    std::string_view SemanticNode_CoroutineLiteral::className() const {
        return "CoroutineLiteral";
    }
    
    void SemanticNode_CoroutineLiteral::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"CoroutineLiteral\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "param: "; 
        if (param) param->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "block: "; 
        if (block) block->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_CoroutineLiteral::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            param.get(),
            block.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    void SemanticNode_CoroutineLiteral::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_CoroutineLiteral::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** ContextExpressionLiteral *** ===
    
    std::string_view SemanticNode_ContextExpressionLiteral::className() const {
        return "ContextExpressionLiteral";
    }
    
    void SemanticNode_ContextExpressionLiteral::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ContextExpressionLiteral\"," << std::endl; 
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "items: [" << std::endl;
        for (auto& ptr : items) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; ptr->print(out, tabs+2, tabstr); out << "," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ContextExpressionLiteral::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + items.size() + 0);
        for (const auto& ptr : items) {ret.push_back(ptr.get());}
        return ret;
    }
    
    void SemanticNode_ContextExpressionLiteral::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_ContextExpressionLiteral::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** ValueLiteral *** ===
    
    std::string_view SemanticNode_ValueLiteral::className() const {
        return "ValueLiteral";
    }
    
    void SemanticNode_ValueLiteral::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ValueLiteral\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "val: "; 
        out<< "\"" << val.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "suf: "; 
        out<< "\"" << suf.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ValueLiteral::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    void SemanticNode_ValueLiteral::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_ValueLiteral::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** ModuleReference *** ===
    
    std::string_view SemanticNode_ModuleReference::className() const {
        return "ModuleReference";
    }
    
    void SemanticNode_ModuleReference::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ModuleReference\"," << std::endl; 
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "modulepath: [" << std::endl;
        for (auto& tok : modulepath) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; out << "\"" << tok.fullname() << "\"," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "version: "; 
        out<< "\"" << version.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ModuleReference::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    void SemanticNode_ModuleReference::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_ModuleReference::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** ListLiteral *** ===
    
    std::string_view SemanticNode_ListLiteral::className() const {
        return "ListLiteral";
    }
    
    void SemanticNode_ListLiteral::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ListLiteral\"," << std::endl; 
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "items: [" << std::endl;
        for (auto& ptr : items) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; ptr->print(out, tabs+2, tabstr); out << "," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ListLiteral::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + items.size() + 0);
        for (const auto& ptr : items) {ret.push_back(ptr.get());}
        return ret;
    }
    
    void SemanticNode_ListLiteral::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_ListLiteral::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** DictLiteral *** ===
    
    std::string_view SemanticNode_DictLiteral::className() const {
        return "DictLiteral";
    }
    
    void SemanticNode_DictLiteral::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"DictLiteral\"," << std::endl; 
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "items: [" << std::endl;
        for (auto& ptr : items) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; ptr->print(out, tabs+2, tabstr); out << "," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_DictLiteral::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + items.size() + 0);
        for (const auto& ptr : items) {ret.push_back(ptr.get());}
        return ret;
    }
    
    void SemanticNode_DictLiteral::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_DictLiteral::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** SetLiteral *** ===
    
    std::string_view SemanticNode_SetLiteral::className() const {
        return "SetLiteral";
    }
    
    void SemanticNode_SetLiteral::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"SetLiteral\"," << std::endl; 
        
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "items: [" << std::endl;
        for (auto& ptr : items) {for (size_t i = 0; i<tabs+2; i++) out << tabstr; ptr->print(out, tabs+2, tabstr); out << "," << std::endl; }
        {for (size_t i = 0; i<tabs+1; i++) out << tabstr;} out << "]," << std::endl;
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_SetLiteral::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + items.size() + 0);
        for (const auto& ptr : items) {ret.push_back(ptr.get());}
        return ret;
    }
    
    void SemanticNode_SetLiteral::outputInternalCGlobals(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    void SemanticNode_SetLiteral::outputInternalCExpression(Server& server, Scope& scope, std::ostringstream& ss) {
    }
    
    // === *** UnaryOperator *** ===
    
    std::string_view SemanticNode_UnaryOperator::className() const {
        return "UnaryOperator";
    }
    
    void SemanticNode_UnaryOperator::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"UnaryOperator\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "op: "; 
        out<< "\"" << op.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_UnaryOperator::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** BinaryOperator *** ===
    
    std::string_view SemanticNode_BinaryOperator::className() const {
        return "BinaryOperator";
    }
    
    void SemanticNode_BinaryOperator::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"BinaryOperator\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "op: "; 
        out<< "\"" << op.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_BinaryOperator::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** RangeOperator *** ===
    
    std::string_view SemanticNode_RangeOperator::className() const {
        return "RangeOperator";
    }
    
    void SemanticNode_RangeOperator::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"RangeOperator\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "left: "; 
        out<< "\"" << left.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "right: "; 
        out<< "\"" << right.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_RangeOperator::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** DictEntry *** ===
    
    std::string_view SemanticNode_DictEntry::className() const {
        return "DictEntry";
    }
    
    void SemanticNode_DictEntry::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"DictEntry\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "key: "; 
        if (key) key->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "value: "; 
        if (value) value->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_DictEntry::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            key.get(),
            value.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** ExpressionOrBlock *** ===
    
    std::string_view SemanticNode_ExpressionOrBlock::className() const {
        return "ExpressionOrBlock";
    }
    
    void SemanticNode_ExpressionOrBlock::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ExpressionOrBlock\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "expr: "; 
        if (expr) expr->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "block: "; 
        if (block) block->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ExpressionOrBlock::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            expr.get(),
            block.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** ValueSpecifier *** ===
    
    std::string_view SemanticNode_ValueSpecifier::className() const {
        return "ValueSpecifier";
    }
    
    void SemanticNode_ValueSpecifier::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ValueSpecifier\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "token: "; 
        out<< "\"" << token.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ValueSpecifier::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** WithStatEntry *** ===
    
    std::string_view SemanticNode_WithStatEntry::className() const {
        return "WithStatEntry";
    }
    
    void SemanticNode_WithStatEntry::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"WithStatEntry\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "id: "; 
        out<< "\"" << id.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "value: "; 
        if (value) value->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "anonValue: "; 
        if (anonValue) anonValue->print(out, tabs+1, tabstr); else out << "null";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_WithStatEntry::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
            value.get(),
            anonValue.get(),
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
    // === *** ChangeOperator *** ===
    
    std::string_view SemanticNode_ChangeOperator::className() const {
        return "ChangeOperator";
    }
    
    void SemanticNode_ChangeOperator::print(std::wostream& out, size_t tabs, const std::wstring& tabstr) const {
        out << "{" << std::endl; 
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "NODE_TYPE: \"ChangeOperator\"," << std::endl; 
        
        for (size_t i = 0; i<tabs+1; i++) out << tabstr; out << "op: "; 
        out<< "\"" << op.fullname() << "\"";
        out << "," << std::endl; 
        
        for (size_t i = 0; i<tabs; i++) out << tabstr; out << "}"; 
    }
    
    std::vector<const SemanticNode*> SemanticNode_ChangeOperator::getSubNodes() const {
        std::vector<const SemanticNode*> ret {
        };
        ret.reserve(ret.size() + 0);
        return ret;
    }
    
}
