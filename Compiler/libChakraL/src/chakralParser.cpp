// This file is autogenerated. Do not edit!

#include "chakralParser.h"

namespace ChakraL
{

    namespace
    {
        
        void a_file(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_file_1_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ONL_1_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBody_1_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBody_2_descs_contextDescriptionEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBody_3_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBodyClosedBlock(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBodyClosedBlock_1_descs_contextDescriptionEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBodyClosedBlock_2_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBodyClosedBlock_3_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBodyClosedBlock_4_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextDescriptionEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextDescriptionEntry_1_statement(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextDescriptionEntry_2_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextDescriptionEntry_3_traitAssertion(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextDescriptionEntry_4_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_traitAssertion(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_traitAssertion_1_L_TRAIT_COND(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_traitAssertion_2_cond_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expression_1_exprLeast(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_1_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_2_L_LEFT_PAR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_4_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_5_L_RIGHT_PAR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_6_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_7_literal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_identifier_1_name_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixFunction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixFunction_1_left_expr1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixFunction_2_L_MEMBER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixFunction_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixFunction_4_right_expr0(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr1_1_expr0(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr1_2_suffixFunction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixInc(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixInc_1_val_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixInc_2_L_INCREMENT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixDec(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixDec_1_val_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixDec_2_L_DECREMENT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_copy(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_copy_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_copy_2_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_copy_3_val_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixFunction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixFunction_1_left_expr1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixFunction_2_right_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr2_1_expr1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr2_2_suffixInc(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr2_3_suffixDec(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr2_4_copy(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr2_5_prefixFunction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixInc(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixInc_1_L_INCREMENT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixInc_2_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixInc_3_val_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixDec(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixDec_1_L_DECREMENT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixDec_2_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixDec_3_val_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_plus(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_plus_1_L_ADD(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_plus_2_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_plus_3_val_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_minus(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_minus_1_L_SUB(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_minus_2_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_minus_3_val_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logNot(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logNot_1_L_NOT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logNot_2_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logNot_3_val_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr3_1_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr3_2_prefixInc(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr3_3_prefixDec(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr3_4_plus(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr3_5_minus(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr3_6_logNot(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_multiplication(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_multiplication_1_left_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_multiplication_2_L_MUL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_multiplication_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_multiplication_4_right_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossProduct(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossProduct_1_left_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossProduct_2_L_CROSS(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossProduct_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossProduct_4_right_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotProduct(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotProduct_1_left_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotProduct_2_L_DOT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotProduct_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotProduct_4_right_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_division(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_division_1_left_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_division_2_L_DIV(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_division_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_division_4_right_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divisionInt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divisionInt_1_left_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divisionInt_2_L_INT_DIV(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divisionInt_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divisionInt_4_right_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modulo(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modulo_1_left_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modulo_2_L_MOD(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modulo_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modulo_4_right_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4_1_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4_2_multiplication(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4_3_crossProduct(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4_4_dotProduct(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4_5_division(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4_6_divisionInt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4_7_modulo(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addition(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addition_1_left_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addition_2_L_ADD(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addition_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addition_4_right_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subtraction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subtraction_1_left_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subtraction_2_L_SUB(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subtraction_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subtraction_4_right_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr5_1_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr5_2_addition(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr5_3_subtraction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftL_1_left_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftL_2_L_SHIFT_LEFT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftL_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftL_4_right_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftR_1_left_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftR_2_L_SHIFT_RIGHT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftR_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftR_4_right_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr6_1_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr6_2_shiftL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr6_3_shiftR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLess(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLess_1_left_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLess_2_L_LESS(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLess_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLess_4_right_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGreat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGreat_1_left_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGreat_2_L_GREAT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGreat_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGreat_4_right_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLeEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLeEq_1_left_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLeEq_2_L_LEEQ(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLeEq_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLeEq_4_right_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGrEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGrEq_1_left_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGrEq_2_L_GREQ(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGrEq_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGrEq_4_right_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr7_1_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr7_2_compLess(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr7_3_compGreat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr7_4_compLeEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr7_5_compGrEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compEqual_1_left_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compEqual_2_L_EQUAL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compEqual_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compEqual_4_right_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotEq_1_left_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotEq_2_L_NOTEQ(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotEq_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotEq_4_right_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compAssigned(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compAssigned_1_left_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compAssigned_2_L_ASSIGNED(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compAssigned_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compAssigned_4_right_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotAss(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotAss_1_left_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotAss_2_L_NOTASS(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotAss_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotAss_4_right_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr8_1_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr8_2_compEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr8_3_compNotEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr8_4_compAssigned(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr8_5_compNotAss(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logAnd(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logAnd_1_left_expr9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logAnd_2_L_AND(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logAnd_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logAnd_4_right_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr9_1_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr9_2_logAnd(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logXOr(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logXOr_1_left_expr10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logXOr_2_L_XOR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logXOr_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logXOr_4_right_expr9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr10_1_expr9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr10_2_logXOr(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logOr(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logOr_1_left_exprLeast(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logOr_2_L_OR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logOr_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logOr_4_right_expr10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_exprLeast(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_exprLeast_1_expr10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_exprLeast_2_logOr(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_literal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_literal_1_contextLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_literal_2_valueLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_literal_3_listLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_literal_4_setLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_literal_5_dictLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_1_num_L_NUM_LIT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_2_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_3_suf_L_LIT_SUFFIX(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_4_str_L_NUM_B_LIT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_5_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_6_suf_L_LIT_SUFFIX(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_7_str_L_NUM_O_LIT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_8_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_9_suf_L_LIT_SUFFIX(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_10_str_L_NUM_X_LIT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_11_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_12_suf_L_LIT_SUFFIX(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_13_str_L_STR_LIT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_14_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_15_suf_L_LIT_SUFFIX(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_1_L_LEFT_BRACK(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_2_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_3_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_4_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_5_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_6_L_RIGHT_BRACK(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_7_L_LEFT_BRACK(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_8_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_9_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_10_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_11_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_12_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_13_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_14_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_15_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_16_L_RIGHT_BRACK(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_1_L_LEFT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_2_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_3_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_4_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_5_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_6_L_RIGHT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_7_L_LEFT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_8_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_9_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_10_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_11_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_12_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_13_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_14_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_15_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_16_L_RIGHT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_1_L_LEFT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_2_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_3_items_dictEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_4_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_5_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_6_items_dictEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_7_L_RIGHT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_8_L_LEFT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_9_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_10_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_11_items_dictEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_12_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_13_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_14_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_15_items_dictEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_16_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_17_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_18_L_RIGHT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictEntry_1_key_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictEntry_2_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictEntry_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictEntry_4_value_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_1_L_LEFT_PAR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_2_items_memberDecl(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_3_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_4_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_5_items_memberDecl(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_6_L_RIGHT_PAR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_7_L_LEFT_PAR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_8_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_9_items_memberDecl(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_10_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_11_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_12_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_13_items_memberDecl(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_14_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_15_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_16_L_RIGHT_PAR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_memberDecl(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_memberDecl_1_member_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_memberDecl_2_L_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_memberDecl_3_value_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement_1_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement_2_definition(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement_3_varDeclaration(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement_4_assignmentEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement_5_ifStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement_6_loopStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement_7_jumpStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement_8_withStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_2_id_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_3_L_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_5_val_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_6_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_7_id_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_8_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_9_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_10_contextBodyClosedBlock(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varDeclaration(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varDeclaration_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varDeclaration_2_body_varRefDeclBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_refDeclaration(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_refDeclaration_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_refDeclaration_2_body_varRefDeclBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclBody_1_items_varRefDeclEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclBody_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclBody_3_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclBody_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclBody_5_items_varRefDeclEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntry_1_equal_varRefDeclEntryEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntry_2_assign_varRefDeclEntryAssign(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryEqual_1_id_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryEqual_2_L_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryEqual_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryEqual_4_val_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryAssign(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryAssign_1_id_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryAssign_2_L_ASSIGN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryAssign_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryAssign_4_val_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_2_cond_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_3_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_4_exec1_statement(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_5_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_6_elseStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_7_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_8_cond_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_9_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_10_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_11_exec1_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_12_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_13_elseStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_14_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_2_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_3_statement(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_4_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_5_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_6_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_7_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_8_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_9_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_10_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_11_statement(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_12_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_13_elseStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_14_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_15_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_16_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_17_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_18_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_19_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_20_elseStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_21_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat_2_parts_loopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat_3_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat_4_L_SEMICOLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat_5_parts_loopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat_6_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat_7_contextBodyClosedBlock(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStatPart_1_timesLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStatPart_2_forLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStatPart_3_whileLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_timesLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_timesLoopStatPart_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_timesLoopStatPart_2_count_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_forLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_forLoopStatPart_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_forLoopStatPart_2_id_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_forLoopStatPart_3_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_forLoopStatPart_4_iterator_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_whileLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_whileLoopStatPart_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_whileLoopStatPart_2_cond_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_jumpStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_jumpStat_1_breakStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_jumpStat_2_continueStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_jumpStat_3_returnStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_breakStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_breakStat_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_continueStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_continueStat_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_returnStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_returnStat_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_returnStat_2_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_returnStat_3_val_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat_2_entries_withStatEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat_3_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat_4_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat_5_entries_withStatEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat_6_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat_7_contextBodyClosedBlock(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStatEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStatEntry_1_id_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStatEntry_2_L_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStatEntry_3_val_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStatEntry_4_val_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_1_assignRef(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_2_changeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_3_addChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_4_subChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_5_mulChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_6_crossChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_7_dotChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_8_divChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_9_intDivChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_10_modChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_11_shiftRChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_12_shiftLChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_13_andChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_14_orChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual_15_xorChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignRef(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignRef_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignRef_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignRef_3_L_ASSIGN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignRef_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignRef_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_changeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_changeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_changeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_changeVal_3_L_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_changeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_changeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addChangeVal_3_L_ADD_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subChangeVal_3_L_SUB_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_mulChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_mulChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_mulChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_mulChangeVal_3_L_MUL_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_mulChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_mulChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossChangeVal_3_L_CROSS(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotChangeVal_3_L_DOT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divChangeVal_3_L_DIV_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_intDivChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_intDivChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_intDivChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_intDivChangeVal_3_L_INT_DIV_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_intDivChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_intDivChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modChangeVal_3_L_MOD_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftRChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftRChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftRChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftRChangeVal_3_L_SHIFT_RIGHT_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftRChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftRChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftLChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftLChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftLChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftLChangeVal_3_L_SHIFT_LEFT_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftLChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftLChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_andChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_andChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_andChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_andChangeVal_3_L_AND_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_andChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_andChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_orChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_orChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_orChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_orChangeVal_3_L_OR_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_orChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_orChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_xorChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_xorChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_xorChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_xorChangeVal_3_L_XOR_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_xorChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_xorChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
    
        // file
        bool n_file(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_file(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_file);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_file>();
                for (auto par : parentStates) par->subNode = state->node;
                a_file_1_contextBody({state}, nextStates, curNode);
            }
        }
    
        // file = _ <:contextBody>
        bool n_file_1_contextBody(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[":"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_file_1_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_file_1_contextBody);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextBody({state}, nextStates, curNode);
            state->node->nodeLists[":"].push_back(state->subNode);
            }
        }
    
        // ONL
        bool n_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ONL>();
                for (auto par : parentStates) par->subNode = state->node;
                a_ONL_1_L_NEW_LN({state}, nextStates, curNode);
            }
        }
    
        // ONL = _ '\n'*
        bool n_ONL_1_L_NEW_LN(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_ONL_1_L_NEW_LN(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_ONL_1_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ONL_1_L_NEW_LN];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextBody
        bool n_contextBody(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextBody);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBody>();
                for (auto par : parentStates) par->subNode = state->node;
                a_contextBody_1_sub({state}, nextStates, curNode);
            }
        }
    
        // contextBody = _ ( <descs:contextDescriptionEntry> | '\n')*
        bool n_contextBody_1_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_contextBody_1_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextBody_1_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextBody_1_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextBody_2_descs_contextDescriptionEntry({state}, nextStates, curNode);
                a_contextBody_3_L_NEW_LN({state}, nextStates, curNode);
            }
        }
    
        // contextBody = ( _ <descs:contextDescriptionEntry> | '\n')*
        bool n_contextBody_2_descs_contextDescriptionEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["descs"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody_2_descs_contextDescriptionEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextBody_2_descs_contextDescriptionEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextDescriptionEntry({state}, nextStates, curNode);
            state->node->nodeLists["descs"].push_back(state->subNode);
            }
        }
    
        // contextBody = ( <descs:contextDescriptionEntry> | _ '\n')*
        bool n_contextBody_3_L_NEW_LN(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody_3_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextBody_3_L_NEW_LN];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextBodyClosedBlock
        bool n_contextBodyClosedBlock(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBodyClosedBlock(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextBodyClosedBlock);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBodyClosedBlock>();
                for (auto par : parentStates) par->subNode = state->node;
                a_contextBodyClosedBlock_1_descs_contextDescriptionEntry({state}, nextStates, curNode);
                a_contextBodyClosedBlock_2_L_NEW_LN({state}, nextStates, curNode);
            }
        }
    
        // contextBodyClosedBlock 	= _ <descs:contextDescriptionEntry>
        bool n_contextBodyClosedBlock_1_descs_contextDescriptionEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["descs"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBodyClosedBlock_1_descs_contextDescriptionEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextBodyClosedBlock_1_descs_contextDescriptionEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextDescriptionEntry({state}, nextStates, curNode);
            state->node->nodeLists["descs"].push_back(state->subNode);
            }
        }
    
        // contextBodyClosedBlock = _ '\n' <:contextBody> 'ok'
        bool n_contextBodyClosedBlock_2_L_NEW_LN(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            a_contextBodyClosedBlock_3_contextBody(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextBodyClosedBlock_2_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextBodyClosedBlock_2_L_NEW_LN];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextBodyClosedBlock = '\n' _ <:contextBody> 'ok'
        bool n_contextBodyClosedBlock_3_contextBody(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[":"].push_back(curState->subNode);
            a_contextBodyClosedBlock_4_L_IDENTIFIER(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextBodyClosedBlock_3_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextBodyClosedBlock_3_contextBody);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextBody({state}, nextStates, curNode);
            state->node->nodeLists[":"].push_back(state->subNode);
            }
        }
    
        // contextBodyClosedBlock = '\n' <:contextBody> _ 'ok'
        bool n_contextBodyClosedBlock_4_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBodyClosedBlock_4_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextBodyClosedBlock_4_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextDescriptionEntry
        bool n_contextDescriptionEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextDescriptionEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextDescriptionEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextDescriptionEntry>();
                for (auto par : parentStates) par->subNode = state->node;
                a_contextDescriptionEntry_1_statement({state}, nextStates, curNode);
                a_contextDescriptionEntry_3_traitAssertion({state}, nextStates, curNode);
            }
        }
    
        // contextDescriptionEntry = _ <statement> '\n'
        bool n_contextDescriptionEntry_1_statement(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_contextDescriptionEntry_2_L_NEW_LN(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextDescriptionEntry_1_statement(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextDescriptionEntry_1_statement);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_statement({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // contextDescriptionEntry = <statement> _ '\n'
        bool n_contextDescriptionEntry_2_L_NEW_LN(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextDescriptionEntry_2_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextDescriptionEntry_2_L_NEW_LN];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextDescriptionEntry = _ <traitAssertion> '\n'
        bool n_contextDescriptionEntry_3_traitAssertion(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_contextDescriptionEntry_4_L_NEW_LN(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextDescriptionEntry_3_traitAssertion(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextDescriptionEntry_3_traitAssertion);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_traitAssertion({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // contextDescriptionEntry = <traitAssertion> _ '\n'
        bool n_contextDescriptionEntry_4_L_NEW_LN(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextDescriptionEntry_4_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextDescriptionEntry_4_L_NEW_LN];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // traitAssertion
        bool n_traitAssertion(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_traitAssertion(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_traitAssertion);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_traitAssertion>();
                for (auto par : parentStates) par->subNode = state->node;
                a_traitAssertion_1_L_TRAIT_COND({state}, nextStates, curNode);
            }
        }
    
        // traitAssertion = _ '??' <cond:expression>
        bool n_traitAssertion_1_L_TRAIT_COND(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_TRAIT_COND)
                return false;
            a_traitAssertion_2_cond_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_traitAssertion_1_L_TRAIT_COND(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_traitAssertion_1_L_TRAIT_COND];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // traitAssertion = '??' _ <cond:expression>
        bool n_traitAssertion_2_cond_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["cond"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_traitAssertion_2_cond_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_traitAssertion_2_cond_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["cond"].push_back(state->subNode);
            }
        }
    
        // expression
        bool n_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expression>();
                for (auto par : parentStates) par->subNode = state->node;
                a_expression_1_exprLeast({state}, nextStates, curNode);
            }
        }
    
        // expression = _ <exprLeast>
        bool n_expression_1_exprLeast(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expression_1_exprLeast(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expression_1_exprLeast);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_exprLeast({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr0
        bool n_expr0(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr0(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr0);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr0>();
                for (auto par : parentStates) par->subNode = state->node;
                a_expr0_1_identifier({state}, nextStates, curNode);
                a_expr0_2_L_LEFT_PAR({state}, nextStates, curNode);
                a_expr0_7_literal({state}, nextStates, curNode);
            }
        }
    
        // expr0 	= _ <identifier>
        bool n_expr0_1_identifier(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr0_1_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr0_1_identifier);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_identifier({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr0 = _ '(' <ONL> <expression> ')' <ONL>
        bool n_expr0_2_L_LEFT_PAR(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_PAR)
                return false;
            a_expr0_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_expr0_2_L_LEFT_PAR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_expr0_2_L_LEFT_PAR];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // expr0 = '(' _ <ONL> <expression> ')' <ONL>
        bool n_expr0_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_expr0_4_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_expr0_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr0_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr0 = '(' <ONL> _ <expression> ')' <ONL>
        bool n_expr0_4_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_expr0_5_L_RIGHT_PAR(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_expr0_4_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr0_4_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr0 = '(' <ONL> <expression> _ ')' <ONL>
        bool n_expr0_5_L_RIGHT_PAR(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_PAR)
                return false;
            a_expr0_6_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_expr0_5_L_RIGHT_PAR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_expr0_5_L_RIGHT_PAR];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // expr0 = '(' <ONL> <expression> ')' _ <ONL>
        bool n_expr0_6_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr0_6_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr0_6_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr0 = _ <literal>
        bool n_expr0_7_literal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr0_7_literal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr0_7_literal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_literal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // identifier
        bool n_identifier(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_identifier);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_identifier>();
                for (auto par : parentStates) par->subNode = state->node;
                a_identifier_1_name_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // identifier = _ name:L_IDENTIFIER
        bool n_identifier_1_name_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists["name"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_identifier_1_name_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_identifier_1_name_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // suffixFunction
        bool n_suffixFunction(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_suffixFunction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_suffixFunction);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_suffixFunction>();
                for (auto par : parentStates) par->subNode = state->node;
                a_suffixFunction_1_left_expr1({state}, nextStates, curNode);
            }
        }
    
        // suffixFunction = _ <left:expr1> '.' <ONL> <right:expr0>
        bool n_suffixFunction_1_left_expr1(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_suffixFunction_2_L_MEMBER(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_suffixFunction_1_left_expr1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_suffixFunction_1_left_expr1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr1({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // suffixFunction = <left:expr1> _ '.' <ONL> <right:expr0>
        bool n_suffixFunction_2_L_MEMBER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_MEMBER)
                return false;
            a_suffixFunction_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_suffixFunction_2_L_MEMBER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_suffixFunction_2_L_MEMBER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // suffixFunction = <left:expr1> '.' _ <ONL> <right:expr0>
        bool n_suffixFunction_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_suffixFunction_4_right_expr0(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_suffixFunction_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_suffixFunction_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // suffixFunction = <left:expr1> '.' <ONL> _ <right:expr0>
        bool n_suffixFunction_4_right_expr0(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_suffixFunction_4_right_expr0(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_suffixFunction_4_right_expr0);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr0({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // expr1
        bool n_expr1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr1>();
                for (auto par : parentStates) par->subNode = state->node;
                a_expr1_1_expr0({state}, nextStates, curNode);
                a_expr1_2_suffixFunction({state}, nextStates, curNode);
            }
        }
    
        // expr1 = _ <expr0>
        bool n_expr1_1_expr0(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr1_1_expr0(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr1_1_expr0);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr0({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr1 = _ <suffixFunction>
        bool n_expr1_2_suffixFunction(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr1_2_suffixFunction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr1_2_suffixFunction);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_suffixFunction({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // suffixInc
        bool n_suffixInc(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_suffixInc(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_suffixInc);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_suffixInc>();
                for (auto par : parentStates) par->subNode = state->node;
                a_suffixInc_1_val_expr2({state}, nextStates, curNode);
            }
        }
    
        // suffixInc = _ <val:expr2> '++'
        bool n_suffixInc_1_val_expr2(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            a_suffixInc_2_L_INCREMENT(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_suffixInc_1_val_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_suffixInc_1_val_expr2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr2({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // suffixInc = <val:expr2> _ '++'
        bool n_suffixInc_2_L_INCREMENT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_INCREMENT)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_suffixInc_2_L_INCREMENT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_suffixInc_2_L_INCREMENT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // suffixDec
        bool n_suffixDec(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_suffixDec(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_suffixDec);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_suffixDec>();
                for (auto par : parentStates) par->subNode = state->node;
                a_suffixDec_1_val_expr2({state}, nextStates, curNode);
            }
        }
    
        // suffixDec = _ <val:expr2> '--'
        bool n_suffixDec_1_val_expr2(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            a_suffixDec_2_L_DECREMENT(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_suffixDec_1_val_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_suffixDec_1_val_expr2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr2({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // suffixDec = <val:expr2> _ '--'
        bool n_suffixDec_2_L_DECREMENT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_DECREMENT)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_suffixDec_2_L_DECREMENT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_suffixDec_2_L_DECREMENT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // copy
        bool n_copy(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_copy(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_copy);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_copy>();
                for (auto par : parentStates) par->subNode = state->node;
                a_copy_1_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // copy = _ 'new' <ONL> <val:expr2>
        bool n_copy_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_copy_2_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_copy_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_copy_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // copy = 'new' _ <ONL> <val:expr2>
        bool n_copy_2_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_copy_3_val_expr2(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_copy_2_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_copy_2_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // copy = 'new' <ONL> _ <val:expr2>
        bool n_copy_3_val_expr2(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_copy_3_val_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_copy_3_val_expr2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr2({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // prefixFunction
        bool n_prefixFunction(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_prefixFunction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_prefixFunction);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_prefixFunction>();
                for (auto par : parentStates) par->subNode = state->node;
                a_prefixFunction_1_left_expr1({state}, nextStates, curNode);
            }
        }
    
        // prefixFunction = _ <left:expr1> <right:expr2>
        bool n_prefixFunction_1_left_expr1(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_prefixFunction_2_right_expr2(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_prefixFunction_1_left_expr1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_prefixFunction_1_left_expr1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr1({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // prefixFunction = <left:expr1> _ <right:expr2>
        bool n_prefixFunction_2_right_expr2(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_prefixFunction_2_right_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_prefixFunction_2_right_expr2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr2({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // expr2
        bool n_expr2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr2>();
                for (auto par : parentStates) par->subNode = state->node;
                a_expr2_1_expr1({state}, nextStates, curNode);
                a_expr2_2_suffixInc({state}, nextStates, curNode);
                a_expr2_3_suffixDec({state}, nextStates, curNode);
                a_expr2_4_copy({state}, nextStates, curNode);
                a_expr2_5_prefixFunction({state}, nextStates, curNode);
            }
        }
    
        // expr2 = _ <expr1>
        bool n_expr2_1_expr1(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr2_1_expr1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr2_1_expr1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr1({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr2 = _ <suffixInc>
        bool n_expr2_2_suffixInc(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr2_2_suffixInc(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr2_2_suffixInc);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_suffixInc({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr2 = _ <suffixDec>
        bool n_expr2_3_suffixDec(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr2_3_suffixDec(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr2_3_suffixDec);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_suffixDec({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr2 = _ <copy>
        bool n_expr2_4_copy(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr2_4_copy(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr2_4_copy);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_copy({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr2 = _ <prefixFunction>
        bool n_expr2_5_prefixFunction(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr2_5_prefixFunction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr2_5_prefixFunction);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_prefixFunction({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // prefixInc
        bool n_prefixInc(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_prefixInc(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_prefixInc);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_prefixInc>();
                for (auto par : parentStates) par->subNode = state->node;
                a_prefixInc_1_L_INCREMENT({state}, nextStates, curNode);
            }
        }
    
        // prefixInc = _ '++' <ONL> <val:expr3>
        bool n_prefixInc_1_L_INCREMENT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_INCREMENT)
                return false;
            a_prefixInc_2_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_prefixInc_1_L_INCREMENT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_prefixInc_1_L_INCREMENT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // prefixInc = '++' _ <ONL> <val:expr3>
        bool n_prefixInc_2_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_prefixInc_3_val_expr3(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_prefixInc_2_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_prefixInc_2_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // prefixInc = '++' <ONL> _ <val:expr3>
        bool n_prefixInc_3_val_expr3(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_prefixInc_3_val_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_prefixInc_3_val_expr3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr3({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // prefixDec
        bool n_prefixDec(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_prefixDec(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_prefixDec);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_prefixDec>();
                for (auto par : parentStates) par->subNode = state->node;
                a_prefixDec_1_L_DECREMENT({state}, nextStates, curNode);
            }
        }
    
        // prefixDec = _ '--' <ONL> <val:expr3>
        bool n_prefixDec_1_L_DECREMENT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_DECREMENT)
                return false;
            a_prefixDec_2_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_prefixDec_1_L_DECREMENT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_prefixDec_1_L_DECREMENT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // prefixDec = '--' _ <ONL> <val:expr3>
        bool n_prefixDec_2_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_prefixDec_3_val_expr3(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_prefixDec_2_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_prefixDec_2_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // prefixDec = '--' <ONL> _ <val:expr3>
        bool n_prefixDec_3_val_expr3(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_prefixDec_3_val_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_prefixDec_3_val_expr3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr3({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // plus
        bool n_plus(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_plus(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_plus);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_plus>();
                for (auto par : parentStates) par->subNode = state->node;
                a_plus_1_L_ADD({state}, nextStates, curNode);
            }
        }
    
        // plus = _ '+' <ONL> <val:expr3>
        bool n_plus_1_L_ADD(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_ADD)
                return false;
            a_plus_2_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_plus_1_L_ADD(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_plus_1_L_ADD];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // plus = '+' _ <ONL> <val:expr3>
        bool n_plus_2_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_plus_3_val_expr3(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_plus_2_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_plus_2_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // plus = '+' <ONL> _ <val:expr3>
        bool n_plus_3_val_expr3(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_plus_3_val_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_plus_3_val_expr3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr3({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // minus
        bool n_minus(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_minus(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_minus);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_minus>();
                for (auto par : parentStates) par->subNode = state->node;
                a_minus_1_L_SUB({state}, nextStates, curNode);
            }
        }
    
        // minus = _ '-' <ONL> <val:expr3>
        bool n_minus_1_L_SUB(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SUB)
                return false;
            a_minus_2_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_minus_1_L_SUB(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_minus_1_L_SUB];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // minus = '-' _ <ONL> <val:expr3>
        bool n_minus_2_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_minus_3_val_expr3(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_minus_2_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_minus_2_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // minus = '-' <ONL> _ <val:expr3>
        bool n_minus_3_val_expr3(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_minus_3_val_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_minus_3_val_expr3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr3({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // logNot
        bool n_logNot(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logNot(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logNot);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_logNot>();
                for (auto par : parentStates) par->subNode = state->node;
                a_logNot_1_L_NOT({state}, nextStates, curNode);
            }
        }
    
        // logNot = _ '!' <ONL> <val:expr3>
        bool n_logNot_1_L_NOT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NOT)
                return false;
            a_logNot_2_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_logNot_1_L_NOT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_logNot_1_L_NOT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // logNot = '!' _ <ONL> <val:expr3>
        bool n_logNot_2_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_logNot_3_val_expr3(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_logNot_2_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logNot_2_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // logNot = '!' <ONL> _ <val:expr3>
        bool n_logNot_3_val_expr3(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logNot_3_val_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logNot_3_val_expr3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr3({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // expr3
        bool n_expr3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr3>();
                for (auto par : parentStates) par->subNode = state->node;
                a_expr3_1_expr2({state}, nextStates, curNode);
                a_expr3_2_prefixInc({state}, nextStates, curNode);
                a_expr3_3_prefixDec({state}, nextStates, curNode);
                a_expr3_4_plus({state}, nextStates, curNode);
                a_expr3_5_minus({state}, nextStates, curNode);
                a_expr3_6_logNot({state}, nextStates, curNode);
            }
        }
    
        // expr3 = _ <expr2>
        bool n_expr3_1_expr2(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr3_1_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr3_1_expr2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr2({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr3 = _ <prefixInc>
        bool n_expr3_2_prefixInc(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr3_2_prefixInc(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr3_2_prefixInc);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_prefixInc({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr3 = _ <prefixDec>
        bool n_expr3_3_prefixDec(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr3_3_prefixDec(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr3_3_prefixDec);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_prefixDec({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr3 = _ <plus>
        bool n_expr3_4_plus(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr3_4_plus(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr3_4_plus);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_plus({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr3 = _ <minus>
        bool n_expr3_5_minus(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr3_5_minus(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr3_5_minus);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_minus({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr3 = _ <logNot>
        bool n_expr3_6_logNot(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr3_6_logNot(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr3_6_logNot);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_logNot({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // multiplication
        bool n_multiplication(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_multiplication(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_multiplication);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_multiplication>();
                for (auto par : parentStates) par->subNode = state->node;
                a_multiplication_1_left_expr4({state}, nextStates, curNode);
            }
        }
    
        // multiplication = _ <left:expr4> '*' <ONL> <right:expr3>
        bool n_multiplication_1_left_expr4(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_multiplication_2_L_MUL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_multiplication_1_left_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_multiplication_1_left_expr4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr4({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // multiplication = <left:expr4> _ '*' <ONL> <right:expr3>
        bool n_multiplication_2_L_MUL(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_MUL)
                return false;
            a_multiplication_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_multiplication_2_L_MUL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_multiplication_2_L_MUL];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // multiplication = <left:expr4> '*' _ <ONL> <right:expr3>
        bool n_multiplication_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_multiplication_4_right_expr3(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_multiplication_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_multiplication_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // multiplication = <left:expr4> '*' <ONL> _ <right:expr3>
        bool n_multiplication_4_right_expr3(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_multiplication_4_right_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_multiplication_4_right_expr3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr3({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // crossProduct
        bool n_crossProduct(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_crossProduct(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_crossProduct);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_crossProduct>();
                for (auto par : parentStates) par->subNode = state->node;
                a_crossProduct_1_left_expr4({state}, nextStates, curNode);
            }
        }
    
        // crossProduct = _ <left:expr4> '×' <ONL> <right:expr3>
        bool n_crossProduct_1_left_expr4(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_crossProduct_2_L_CROSS(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_crossProduct_1_left_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_crossProduct_1_left_expr4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr4({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // crossProduct = <left:expr4> _ '×' <ONL> <right:expr3>
        bool n_crossProduct_2_L_CROSS(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CROSS)
                return false;
            a_crossProduct_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_crossProduct_2_L_CROSS(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_crossProduct_2_L_CROSS];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // crossProduct = <left:expr4> '×' _ <ONL> <right:expr3>
        bool n_crossProduct_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_crossProduct_4_right_expr3(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_crossProduct_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_crossProduct_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // crossProduct = <left:expr4> '×' <ONL> _ <right:expr3>
        bool n_crossProduct_4_right_expr3(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_crossProduct_4_right_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_crossProduct_4_right_expr3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr3({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // dotProduct
        bool n_dotProduct(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dotProduct(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dotProduct);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dotProduct>();
                for (auto par : parentStates) par->subNode = state->node;
                a_dotProduct_1_left_expr4({state}, nextStates, curNode);
            }
        }
    
        // dotProduct = _ <left:expr4> '⋅' <ONL> <right:expr3>
        bool n_dotProduct_1_left_expr4(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_dotProduct_2_L_DOT(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dotProduct_1_left_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dotProduct_1_left_expr4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr4({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // dotProduct = <left:expr4> _ '⋅' <ONL> <right:expr3>
        bool n_dotProduct_2_L_DOT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_DOT)
                return false;
            a_dotProduct_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dotProduct_2_L_DOT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dotProduct_2_L_DOT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dotProduct = <left:expr4> '⋅' _ <ONL> <right:expr3>
        bool n_dotProduct_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_dotProduct_4_right_expr3(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dotProduct_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dotProduct_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // dotProduct = <left:expr4> '⋅' <ONL> _ <right:expr3>
        bool n_dotProduct_4_right_expr3(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dotProduct_4_right_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dotProduct_4_right_expr3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr3({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // division
        bool n_division(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_division(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_division);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_division>();
                for (auto par : parentStates) par->subNode = state->node;
                a_division_1_left_expr4({state}, nextStates, curNode);
            }
        }
    
        // division = _ <left:expr4> '/' <ONL> <right:expr3>
        bool n_division_1_left_expr4(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_division_2_L_DIV(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_division_1_left_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_division_1_left_expr4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr4({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // division = <left:expr4> _ '/' <ONL> <right:expr3>
        bool n_division_2_L_DIV(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_DIV)
                return false;
            a_division_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_division_2_L_DIV(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_division_2_L_DIV];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // division = <left:expr4> '/' _ <ONL> <right:expr3>
        bool n_division_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_division_4_right_expr3(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_division_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_division_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // division = <left:expr4> '/' <ONL> _ <right:expr3>
        bool n_division_4_right_expr3(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_division_4_right_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_division_4_right_expr3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr3({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // divisionInt
        bool n_divisionInt(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_divisionInt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_divisionInt);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_divisionInt>();
                for (auto par : parentStates) par->subNode = state->node;
                a_divisionInt_1_left_expr4({state}, nextStates, curNode);
            }
        }
    
        // divisionInt = _ <left:expr4> '/%' <ONL> <right:expr3>
        bool n_divisionInt_1_left_expr4(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_divisionInt_2_L_INT_DIV(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_divisionInt_1_left_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_divisionInt_1_left_expr4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr4({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // divisionInt = <left:expr4> _ '/%' <ONL> <right:expr3>
        bool n_divisionInt_2_L_INT_DIV(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_INT_DIV)
                return false;
            a_divisionInt_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_divisionInt_2_L_INT_DIV(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_divisionInt_2_L_INT_DIV];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // divisionInt = <left:expr4> '/%' _ <ONL> <right:expr3>
        bool n_divisionInt_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_divisionInt_4_right_expr3(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_divisionInt_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_divisionInt_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // divisionInt = <left:expr4> '/%' <ONL> _ <right:expr3>
        bool n_divisionInt_4_right_expr3(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_divisionInt_4_right_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_divisionInt_4_right_expr3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr3({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // modulo
        bool n_modulo(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_modulo(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_modulo);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_modulo>();
                for (auto par : parentStates) par->subNode = state->node;
                a_modulo_1_left_expr4({state}, nextStates, curNode);
            }
        }
    
        // modulo = _ <left:expr4> '%' <ONL> <right:expr3>
        bool n_modulo_1_left_expr4(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_modulo_2_L_MOD(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_modulo_1_left_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_modulo_1_left_expr4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr4({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // modulo = <left:expr4> _ '%' <ONL> <right:expr3>
        bool n_modulo_2_L_MOD(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_MOD)
                return false;
            a_modulo_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_modulo_2_L_MOD(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_modulo_2_L_MOD];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // modulo = <left:expr4> '%' _ <ONL> <right:expr3>
        bool n_modulo_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_modulo_4_right_expr3(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_modulo_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_modulo_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // modulo = <left:expr4> '%' <ONL> _ <right:expr3>
        bool n_modulo_4_right_expr3(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_modulo_4_right_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_modulo_4_right_expr3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr3({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // expr4
        bool n_expr4(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr4>();
                for (auto par : parentStates) par->subNode = state->node;
                a_expr4_1_expr3({state}, nextStates, curNode);
                a_expr4_2_multiplication({state}, nextStates, curNode);
                a_expr4_3_crossProduct({state}, nextStates, curNode);
                a_expr4_4_dotProduct({state}, nextStates, curNode);
                a_expr4_5_division({state}, nextStates, curNode);
                a_expr4_6_divisionInt({state}, nextStates, curNode);
                a_expr4_7_modulo({state}, nextStates, curNode);
            }
        }
    
        // expr4 = _ <expr3>
        bool n_expr4_1_expr3(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4_1_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr4_1_expr3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr3({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr4 = _ <multiplication>
        bool n_expr4_2_multiplication(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4_2_multiplication(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr4_2_multiplication);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_multiplication({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr4 = _ <crossProduct>
        bool n_expr4_3_crossProduct(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4_3_crossProduct(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr4_3_crossProduct);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_crossProduct({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr4 = _ <dotProduct>
        bool n_expr4_4_dotProduct(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4_4_dotProduct(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr4_4_dotProduct);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_dotProduct({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr4 = _ <division>
        bool n_expr4_5_division(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4_5_division(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr4_5_division);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_division({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr4 = _ <divisionInt>
        bool n_expr4_6_divisionInt(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4_6_divisionInt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr4_6_divisionInt);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_divisionInt({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr4 = _ <modulo>
        bool n_expr4_7_modulo(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4_7_modulo(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr4_7_modulo);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_modulo({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // addition
        bool n_addition(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_addition(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_addition);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_addition>();
                for (auto par : parentStates) par->subNode = state->node;
                a_addition_1_left_expr5({state}, nextStates, curNode);
            }
        }
    
        // addition = _ <left:expr5> '+' <ONL> <right:expr4>
        bool n_addition_1_left_expr5(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_addition_2_L_ADD(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_addition_1_left_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_addition_1_left_expr5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr5({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // addition = <left:expr5> _ '+' <ONL> <right:expr4>
        bool n_addition_2_L_ADD(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_ADD)
                return false;
            a_addition_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_addition_2_L_ADD(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_addition_2_L_ADD];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // addition = <left:expr5> '+' _ <ONL> <right:expr4>
        bool n_addition_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_addition_4_right_expr4(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_addition_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_addition_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // addition = <left:expr5> '+' <ONL> _ <right:expr4>
        bool n_addition_4_right_expr4(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_addition_4_right_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_addition_4_right_expr4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr4({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // subtraction
        bool n_subtraction(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_subtraction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_subtraction);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_subtraction>();
                for (auto par : parentStates) par->subNode = state->node;
                a_subtraction_1_left_expr5({state}, nextStates, curNode);
            }
        }
    
        // subtraction = _ <left:expr5> '-' <ONL> <right:expr4>
        bool n_subtraction_1_left_expr5(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_subtraction_2_L_SUB(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_subtraction_1_left_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_subtraction_1_left_expr5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr5({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // subtraction = <left:expr5> _ '-' <ONL> <right:expr4>
        bool n_subtraction_2_L_SUB(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SUB)
                return false;
            a_subtraction_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_subtraction_2_L_SUB(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_subtraction_2_L_SUB];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // subtraction = <left:expr5> '-' _ <ONL> <right:expr4>
        bool n_subtraction_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_subtraction_4_right_expr4(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_subtraction_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_subtraction_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // subtraction = <left:expr5> '-' <ONL> _ <right:expr4>
        bool n_subtraction_4_right_expr4(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_subtraction_4_right_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_subtraction_4_right_expr4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr4({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // expr5
        bool n_expr5(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr5>();
                for (auto par : parentStates) par->subNode = state->node;
                a_expr5_1_expr4({state}, nextStates, curNode);
                a_expr5_2_addition({state}, nextStates, curNode);
                a_expr5_3_subtraction({state}, nextStates, curNode);
            }
        }
    
        // expr5 = _ <expr4>
        bool n_expr5_1_expr4(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr5_1_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr5_1_expr4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr4({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr5 = _ <addition>
        bool n_expr5_2_addition(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr5_2_addition(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr5_2_addition);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_addition({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr5 = _ <subtraction>
        bool n_expr5_3_subtraction(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr5_3_subtraction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr5_3_subtraction);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_subtraction({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // shiftL
        bool n_shiftL(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftL>();
                for (auto par : parentStates) par->subNode = state->node;
                a_shiftL_1_left_expr6({state}, nextStates, curNode);
            }
        }
    
        // shiftL = _ <left:expr6> '<<' <ONL> <right:expr5>
        bool n_shiftL_1_left_expr6(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_shiftL_2_L_SHIFT_LEFT(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftL_1_left_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftL_1_left_expr6);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr6({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // shiftL = <left:expr6> _ '<<' <ONL> <right:expr5>
        bool n_shiftL_2_L_SHIFT_LEFT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SHIFT_LEFT)
                return false;
            a_shiftL_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftL_2_L_SHIFT_LEFT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_shiftL_2_L_SHIFT_LEFT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // shiftL = <left:expr6> '<<' _ <ONL> <right:expr5>
        bool n_shiftL_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_shiftL_4_right_expr5(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftL_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftL_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // shiftL = <left:expr6> '<<' <ONL> _ <right:expr5>
        bool n_shiftL_4_right_expr5(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftL_4_right_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftL_4_right_expr5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr5({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // shiftR
        bool n_shiftR(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftR);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftR>();
                for (auto par : parentStates) par->subNode = state->node;
                a_shiftR_1_left_expr6({state}, nextStates, curNode);
            }
        }
    
        // shiftR = _ <left:expr6> '>>' <ONL> <right:expr5>
        bool n_shiftR_1_left_expr6(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_shiftR_2_L_SHIFT_RIGHT(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftR_1_left_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftR_1_left_expr6);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr6({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // shiftR = <left:expr6> _ '>>' <ONL> <right:expr5>
        bool n_shiftR_2_L_SHIFT_RIGHT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SHIFT_RIGHT)
                return false;
            a_shiftR_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftR_2_L_SHIFT_RIGHT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_shiftR_2_L_SHIFT_RIGHT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // shiftR = <left:expr6> '>>' _ <ONL> <right:expr5>
        bool n_shiftR_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_shiftR_4_right_expr5(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftR_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftR_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // shiftR = <left:expr6> '>>' <ONL> _ <right:expr5>
        bool n_shiftR_4_right_expr5(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftR_4_right_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftR_4_right_expr5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr5({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // expr6
        bool n_expr6(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr6);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr6>();
                for (auto par : parentStates) par->subNode = state->node;
                a_expr6_1_expr5({state}, nextStates, curNode);
                a_expr6_2_shiftL({state}, nextStates, curNode);
                a_expr6_3_shiftR({state}, nextStates, curNode);
            }
        }
    
        // expr6 = _ <expr5>
        bool n_expr6_1_expr5(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr6_1_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr6_1_expr5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr5({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr6 = _ <shiftL>
        bool n_expr6_2_shiftL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr6_2_shiftL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr6_2_shiftL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_shiftL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr6 = _ <shiftR>
        bool n_expr6_3_shiftR(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr6_3_shiftR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr6_3_shiftR);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_shiftR({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // compLess
        bool n_compLess(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compLess(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compLess);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compLess>();
                for (auto par : parentStates) par->subNode = state->node;
                a_compLess_1_left_expr7({state}, nextStates, curNode);
            }
        }
    
        // compLess = _ <left:expr7> '<' <ONL> <right:expr6>
        bool n_compLess_1_left_expr7(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_compLess_2_L_LESS(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compLess_1_left_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compLess_1_left_expr7);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr7({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // compLess = <left:expr7> _ '<' <ONL> <right:expr6>
        bool n_compLess_2_L_LESS(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LESS)
                return false;
            a_compLess_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compLess_2_L_LESS(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compLess_2_L_LESS];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compLess = <left:expr7> '<' _ <ONL> <right:expr6>
        bool n_compLess_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_compLess_4_right_expr6(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compLess_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compLess_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // compLess = <left:expr7> '<' <ONL> _ <right:expr6>
        bool n_compLess_4_right_expr6(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compLess_4_right_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compLess_4_right_expr6);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr6({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // compGreat
        bool n_compGreat(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compGreat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compGreat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compGreat>();
                for (auto par : parentStates) par->subNode = state->node;
                a_compGreat_1_left_expr7({state}, nextStates, curNode);
            }
        }
    
        // compGreat = _ <left:expr7> '>' <ONL> <right:expr6>
        bool n_compGreat_1_left_expr7(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_compGreat_2_L_GREAT(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compGreat_1_left_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compGreat_1_left_expr7);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr7({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // compGreat = <left:expr7> _ '>' <ONL> <right:expr6>
        bool n_compGreat_2_L_GREAT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_GREAT)
                return false;
            a_compGreat_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compGreat_2_L_GREAT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compGreat_2_L_GREAT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compGreat = <left:expr7> '>' _ <ONL> <right:expr6>
        bool n_compGreat_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_compGreat_4_right_expr6(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compGreat_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compGreat_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // compGreat = <left:expr7> '>' <ONL> _ <right:expr6>
        bool n_compGreat_4_right_expr6(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compGreat_4_right_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compGreat_4_right_expr6);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr6({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // compLeEq
        bool n_compLeEq(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compLeEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compLeEq);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compLeEq>();
                for (auto par : parentStates) par->subNode = state->node;
                a_compLeEq_1_left_expr7({state}, nextStates, curNode);
            }
        }
    
        // compLeEq = _ <left:expr7> '<=' <ONL> <right:expr6>
        bool n_compLeEq_1_left_expr7(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_compLeEq_2_L_LEEQ(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compLeEq_1_left_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compLeEq_1_left_expr7);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr7({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // compLeEq = <left:expr7> _ '<=' <ONL> <right:expr6>
        bool n_compLeEq_2_L_LEEQ(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEEQ)
                return false;
            a_compLeEq_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compLeEq_2_L_LEEQ(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compLeEq_2_L_LEEQ];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compLeEq = <left:expr7> '<=' _ <ONL> <right:expr6>
        bool n_compLeEq_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_compLeEq_4_right_expr6(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compLeEq_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compLeEq_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // compLeEq = <left:expr7> '<=' <ONL> _ <right:expr6>
        bool n_compLeEq_4_right_expr6(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compLeEq_4_right_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compLeEq_4_right_expr6);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr6({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // compGrEq
        bool n_compGrEq(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compGrEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compGrEq);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compGrEq>();
                for (auto par : parentStates) par->subNode = state->node;
                a_compGrEq_1_left_expr7({state}, nextStates, curNode);
            }
        }
    
        // compGrEq = _ <left:expr7> '>=' <ONL> <right:expr6>
        bool n_compGrEq_1_left_expr7(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_compGrEq_2_L_GREQ(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compGrEq_1_left_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compGrEq_1_left_expr7);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr7({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // compGrEq = <left:expr7> _ '>=' <ONL> <right:expr6>
        bool n_compGrEq_2_L_GREQ(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_GREQ)
                return false;
            a_compGrEq_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compGrEq_2_L_GREQ(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compGrEq_2_L_GREQ];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compGrEq = <left:expr7> '>=' _ <ONL> <right:expr6>
        bool n_compGrEq_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_compGrEq_4_right_expr6(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compGrEq_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compGrEq_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // compGrEq = <left:expr7> '>=' <ONL> _ <right:expr6>
        bool n_compGrEq_4_right_expr6(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compGrEq_4_right_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compGrEq_4_right_expr6);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr6({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // expr7
        bool n_expr7(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr7);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr7>();
                for (auto par : parentStates) par->subNode = state->node;
                a_expr7_1_expr6({state}, nextStates, curNode);
                a_expr7_2_compLess({state}, nextStates, curNode);
                a_expr7_3_compGreat({state}, nextStates, curNode);
                a_expr7_4_compLeEq({state}, nextStates, curNode);
                a_expr7_5_compGrEq({state}, nextStates, curNode);
            }
        }
    
        // expr7 = _ <expr6>
        bool n_expr7_1_expr6(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr7_1_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr7_1_expr6);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr6({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr7 = _ <compLess>
        bool n_expr7_2_compLess(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr7_2_compLess(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr7_2_compLess);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_compLess({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr7 = _ <compGreat>
        bool n_expr7_3_compGreat(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr7_3_compGreat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr7_3_compGreat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_compGreat({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr7 = _ <compLeEq>
        bool n_expr7_4_compLeEq(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr7_4_compLeEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr7_4_compLeEq);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_compLeEq({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr7 = _ <compGrEq>
        bool n_expr7_5_compGrEq(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr7_5_compGrEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr7_5_compGrEq);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_compGrEq({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // compEqual
        bool n_compEqual(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compEqual);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compEqual>();
                for (auto par : parentStates) par->subNode = state->node;
                a_compEqual_1_left_expr8({state}, nextStates, curNode);
            }
        }
    
        // compEqual = _ <left:expr8> '?=' <ONL> <right:expr7>
        bool n_compEqual_1_left_expr8(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_compEqual_2_L_EQUAL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compEqual_1_left_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compEqual_1_left_expr8);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr8({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // compEqual = <left:expr8> _ '?=' <ONL> <right:expr7>
        bool n_compEqual_2_L_EQUAL(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_EQUAL)
                return false;
            a_compEqual_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compEqual_2_L_EQUAL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compEqual_2_L_EQUAL];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compEqual = <left:expr8> '?=' _ <ONL> <right:expr7>
        bool n_compEqual_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_compEqual_4_right_expr7(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compEqual_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compEqual_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // compEqual = <left:expr8> '?=' <ONL> _ <right:expr7>
        bool n_compEqual_4_right_expr7(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compEqual_4_right_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compEqual_4_right_expr7);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr7({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // compNotEq
        bool n_compNotEq(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compNotEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compNotEq);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compNotEq>();
                for (auto par : parentStates) par->subNode = state->node;
                a_compNotEq_1_left_expr8({state}, nextStates, curNode);
            }
        }
    
        // compNotEq = _ <left:expr8> '!=' <ONL> <right:expr7>
        bool n_compNotEq_1_left_expr8(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_compNotEq_2_L_NOTEQ(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compNotEq_1_left_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compNotEq_1_left_expr8);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr8({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // compNotEq = <left:expr8> _ '!=' <ONL> <right:expr7>
        bool n_compNotEq_2_L_NOTEQ(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NOTEQ)
                return false;
            a_compNotEq_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compNotEq_2_L_NOTEQ(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compNotEq_2_L_NOTEQ];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compNotEq = <left:expr8> '!=' _ <ONL> <right:expr7>
        bool n_compNotEq_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_compNotEq_4_right_expr7(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compNotEq_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compNotEq_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // compNotEq = <left:expr8> '!=' <ONL> _ <right:expr7>
        bool n_compNotEq_4_right_expr7(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compNotEq_4_right_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compNotEq_4_right_expr7);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr7({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // compAssigned
        bool n_compAssigned(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compAssigned(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compAssigned);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compAssigned>();
                for (auto par : parentStates) par->subNode = state->node;
                a_compAssigned_1_left_expr8({state}, nextStates, curNode);
            }
        }
    
        // compAssigned = _ <left:expr8> '?->' <ONL> <right:expr7>
        bool n_compAssigned_1_left_expr8(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_compAssigned_2_L_ASSIGNED(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compAssigned_1_left_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compAssigned_1_left_expr8);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr8({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // compAssigned = <left:expr8> _ '?->' <ONL> <right:expr7>
        bool n_compAssigned_2_L_ASSIGNED(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_ASSIGNED)
                return false;
            a_compAssigned_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compAssigned_2_L_ASSIGNED(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compAssigned_2_L_ASSIGNED];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compAssigned = <left:expr8> '?->' _ <ONL> <right:expr7>
        bool n_compAssigned_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_compAssigned_4_right_expr7(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compAssigned_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compAssigned_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // compAssigned = <left:expr8> '?->' <ONL> _ <right:expr7>
        bool n_compAssigned_4_right_expr7(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compAssigned_4_right_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compAssigned_4_right_expr7);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr7({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // compNotAss
        bool n_compNotAss(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compNotAss(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compNotAss);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compNotAss>();
                for (auto par : parentStates) par->subNode = state->node;
                a_compNotAss_1_left_expr8({state}, nextStates, curNode);
            }
        }
    
        // compNotAss = _ <left:expr8> '!->' <ONL> <right:expr7>
        bool n_compNotAss_1_left_expr8(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_compNotAss_2_L_NOTASS(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compNotAss_1_left_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compNotAss_1_left_expr8);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr8({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // compNotAss = <left:expr8> _ '!->' <ONL> <right:expr7>
        bool n_compNotAss_2_L_NOTASS(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NOTASS)
                return false;
            a_compNotAss_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compNotAss_2_L_NOTASS(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compNotAss_2_L_NOTASS];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compNotAss = <left:expr8> '!->' _ <ONL> <right:expr7>
        bool n_compNotAss_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_compNotAss_4_right_expr7(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_compNotAss_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compNotAss_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // compNotAss = <left:expr8> '!->' <ONL> _ <right:expr7>
        bool n_compNotAss_4_right_expr7(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compNotAss_4_right_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_compNotAss_4_right_expr7);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr7({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // expr8
        bool n_expr8(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr8);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr8>();
                for (auto par : parentStates) par->subNode = state->node;
                a_expr8_1_expr7({state}, nextStates, curNode);
                a_expr8_2_compEqual({state}, nextStates, curNode);
                a_expr8_3_compNotEq({state}, nextStates, curNode);
                a_expr8_4_compAssigned({state}, nextStates, curNode);
                a_expr8_5_compNotAss({state}, nextStates, curNode);
            }
        }
    
        // expr8 = _ <expr7>
        bool n_expr8_1_expr7(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr8_1_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr8_1_expr7);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr7({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr8 = _ <compEqual>
        bool n_expr8_2_compEqual(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr8_2_compEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr8_2_compEqual);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_compEqual({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr8 = _ <compNotEq>
        bool n_expr8_3_compNotEq(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr8_3_compNotEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr8_3_compNotEq);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_compNotEq({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr8 = _ <compAssigned>
        bool n_expr8_4_compAssigned(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr8_4_compAssigned(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr8_4_compAssigned);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_compAssigned({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr8 = _ <compNotAss>
        bool n_expr8_5_compNotAss(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr8_5_compNotAss(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr8_5_compNotAss);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_compNotAss({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // logAnd
        bool n_logAnd(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logAnd(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logAnd);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_logAnd>();
                for (auto par : parentStates) par->subNode = state->node;
                a_logAnd_1_left_expr9({state}, nextStates, curNode);
            }
        }
    
        // logAnd = _ <left:expr9> '&' <ONL> <right:expr8>
        bool n_logAnd_1_left_expr9(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_logAnd_2_L_AND(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_logAnd_1_left_expr9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logAnd_1_left_expr9);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr9({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // logAnd = <left:expr9> _ '&' <ONL> <right:expr8>
        bool n_logAnd_2_L_AND(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_AND)
                return false;
            a_logAnd_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_logAnd_2_L_AND(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_logAnd_2_L_AND];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // logAnd = <left:expr9> '&' _ <ONL> <right:expr8>
        bool n_logAnd_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_logAnd_4_right_expr8(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_logAnd_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logAnd_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // logAnd = <left:expr9> '&' <ONL> _ <right:expr8>
        bool n_logAnd_4_right_expr8(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logAnd_4_right_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logAnd_4_right_expr8);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr8({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // expr9
        bool n_expr9(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr9);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr9>();
                for (auto par : parentStates) par->subNode = state->node;
                a_expr9_1_expr8({state}, nextStates, curNode);
                a_expr9_2_logAnd({state}, nextStates, curNode);
            }
        }
    
        // expr9 = _ <expr8>
        bool n_expr9_1_expr8(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr9_1_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr9_1_expr8);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr8({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr9 = _ <logAnd>
        bool n_expr9_2_logAnd(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr9_2_logAnd(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr9_2_logAnd);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_logAnd({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // logXOr
        bool n_logXOr(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logXOr(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logXOr);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_logXOr>();
                for (auto par : parentStates) par->subNode = state->node;
                a_logXOr_1_left_expr10({state}, nextStates, curNode);
            }
        }
    
        // logXOr = _ <left:expr10> '^' <ONL> <right:expr9>
        bool n_logXOr_1_left_expr10(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_logXOr_2_L_XOR(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_logXOr_1_left_expr10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logXOr_1_left_expr10);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr10({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // logXOr = <left:expr10> _ '^' <ONL> <right:expr9>
        bool n_logXOr_2_L_XOR(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_XOR)
                return false;
            a_logXOr_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_logXOr_2_L_XOR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_logXOr_2_L_XOR];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // logXOr = <left:expr10> '^' _ <ONL> <right:expr9>
        bool n_logXOr_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_logXOr_4_right_expr9(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_logXOr_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logXOr_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // logXOr = <left:expr10> '^' <ONL> _ <right:expr9>
        bool n_logXOr_4_right_expr9(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logXOr_4_right_expr9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logXOr_4_right_expr9);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr9({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // expr10
        bool n_expr10(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr10);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr10>();
                for (auto par : parentStates) par->subNode = state->node;
                a_expr10_1_expr9({state}, nextStates, curNode);
                a_expr10_2_logXOr({state}, nextStates, curNode);
            }
        }
    
        // expr10 = _ <expr9>
        bool n_expr10_1_expr9(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr10_1_expr9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr10_1_expr9);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr9({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // expr10 = _ <logXOr>
        bool n_expr10_2_logXOr(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr10_2_logXOr(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_expr10_2_logXOr);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_logXOr({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // logOr
        bool n_logOr(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logOr(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logOr);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_logOr>();
                for (auto par : parentStates) par->subNode = state->node;
                a_logOr_1_left_exprLeast({state}, nextStates, curNode);
            }
        }
    
        // logOr = _ <left:exprLeast> '|' <ONL> <right:expr10>
        bool n_logOr_1_left_exprLeast(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_logOr_2_L_OR(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_logOr_1_left_exprLeast(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logOr_1_left_exprLeast);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_exprLeast({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // logOr = <left:exprLeast> _ '|' <ONL> <right:expr10>
        bool n_logOr_2_L_OR(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_OR)
                return false;
            a_logOr_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_logOr_2_L_OR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_logOr_2_L_OR];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // logOr = <left:exprLeast> '|' _ <ONL> <right:expr10>
        bool n_logOr_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_logOr_4_right_expr10(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_logOr_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logOr_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // logOr = <left:exprLeast> '|' <ONL> _ <right:expr10>
        bool n_logOr_4_right_expr10(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["right"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logOr_4_right_expr10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_logOr_4_right_expr10);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr10({state}, nextStates, curNode);
            state->node->nodeLists["right"].push_back(state->subNode);
            }
        }
    
        // exprLeast
        bool n_exprLeast(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_exprLeast(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_exprLeast);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_exprLeast>();
                for (auto par : parentStates) par->subNode = state->node;
                a_exprLeast_1_expr10({state}, nextStates, curNode);
                a_exprLeast_2_logOr({state}, nextStates, curNode);
            }
        }
    
        // exprLeast = _ <expr10>
        bool n_exprLeast_1_expr10(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_exprLeast_1_expr10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_exprLeast_1_expr10);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expr10({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // exprLeast = _ <logOr>
        bool n_exprLeast_2_logOr(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_exprLeast_2_logOr(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_exprLeast_2_logOr);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_logOr({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // literal
        bool n_literal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_literal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_literal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_literal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_literal_1_contextLiteral({state}, nextStates, curNode);
                a_literal_2_valueLiteral({state}, nextStates, curNode);
                a_literal_3_listLiteral({state}, nextStates, curNode);
                a_literal_4_setLiteral({state}, nextStates, curNode);
                a_literal_5_dictLiteral({state}, nextStates, curNode);
            }
        }
    
        // literal 	= _ <contextLiteral>
        bool n_literal_1_contextLiteral(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_literal_1_contextLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_literal_1_contextLiteral);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextLiteral({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // literal = _ <valueLiteral>
        bool n_literal_2_valueLiteral(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_literal_2_valueLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_literal_2_valueLiteral);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_valueLiteral({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // literal = _ <listLiteral>
        bool n_literal_3_listLiteral(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_literal_3_listLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_literal_3_listLiteral);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_listLiteral({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // literal = _ <setLiteral>
        bool n_literal_4_setLiteral(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_literal_4_setLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_literal_4_setLiteral);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_setLiteral({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // literal = _ <dictLiteral>
        bool n_literal_5_dictLiteral(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_literal_5_dictLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_literal_5_dictLiteral);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_dictLiteral({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // valueLiteral
        bool n_valueLiteral(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                for (auto par : parentStates) par->subNode = state->node;
                a_valueLiteral_1_num_L_NUM_LIT({state}, nextStates, curNode);
                a_valueLiteral_4_str_L_NUM_B_LIT({state}, nextStates, curNode);
                a_valueLiteral_7_str_L_NUM_O_LIT({state}, nextStates, curNode);
                a_valueLiteral_10_str_L_NUM_X_LIT({state}, nextStates, curNode);
                a_valueLiteral_13_str_L_STR_LIT({state}, nextStates, curNode);
            }
        }
    
        // valueLiteral 	= _ num:L_NUM_LIT [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_1_num_L_NUM_LIT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NUM_LIT)
                return false;
            curState->node->tokenLists["num"].push_back(token);
            a_valueLiteral_2_opt(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_valueLiteral_1_num_L_NUM_LIT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_1_num_L_NUM_LIT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral 	= num:L_NUM_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_2_opt(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_2_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_2_opt);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_valueLiteral_3_suf_L_LIT_SUFFIX({state}, nextStates, curNode);
            }
        }
    
        // valueLiteral 	= num:L_NUM_LIT [ _ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_3_suf_L_LIT_SUFFIX(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LIT_SUFFIX)
                return false;
            curState->node->tokenLists["suf"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_3_suf_L_LIT_SUFFIX(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_3_suf_L_LIT_SUFFIX];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral = _ str:L_NUM_B_LIT [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_4_str_L_NUM_B_LIT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NUM_B_LIT)
                return false;
            curState->node->tokenLists["str"].push_back(token);
            a_valueLiteral_5_opt(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_valueLiteral_4_str_L_NUM_B_LIT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_4_str_L_NUM_B_LIT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral = str:L_NUM_B_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_5_opt(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_5_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_5_opt);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_valueLiteral_6_suf_L_LIT_SUFFIX({state}, nextStates, curNode);
            }
        }
    
        // valueLiteral = str:L_NUM_B_LIT [ _ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_6_suf_L_LIT_SUFFIX(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LIT_SUFFIX)
                return false;
            curState->node->tokenLists["suf"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_6_suf_L_LIT_SUFFIX(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_6_suf_L_LIT_SUFFIX];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral = _ str:L_NUM_O_LIT [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_7_str_L_NUM_O_LIT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NUM_O_LIT)
                return false;
            curState->node->tokenLists["str"].push_back(token);
            a_valueLiteral_8_opt(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_valueLiteral_7_str_L_NUM_O_LIT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_7_str_L_NUM_O_LIT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral = str:L_NUM_O_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_8_opt(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_8_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_8_opt);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_valueLiteral_9_suf_L_LIT_SUFFIX({state}, nextStates, curNode);
            }
        }
    
        // valueLiteral = str:L_NUM_O_LIT [ _ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_9_suf_L_LIT_SUFFIX(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LIT_SUFFIX)
                return false;
            curState->node->tokenLists["suf"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_9_suf_L_LIT_SUFFIX(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_9_suf_L_LIT_SUFFIX];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral = _ str:L_NUM_X_LIT [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_10_str_L_NUM_X_LIT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NUM_X_LIT)
                return false;
            curState->node->tokenLists["str"].push_back(token);
            a_valueLiteral_11_opt(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_valueLiteral_10_str_L_NUM_X_LIT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_10_str_L_NUM_X_LIT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral = str:L_NUM_X_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_11_opt(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_11_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_11_opt);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_valueLiteral_12_suf_L_LIT_SUFFIX({state}, nextStates, curNode);
            }
        }
    
        // valueLiteral = str:L_NUM_X_LIT [ _ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_12_suf_L_LIT_SUFFIX(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LIT_SUFFIX)
                return false;
            curState->node->tokenLists["suf"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_12_suf_L_LIT_SUFFIX(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_12_suf_L_LIT_SUFFIX];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral = _ str:L_STR_LIT [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_13_str_L_STR_LIT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_STR_LIT)
                return false;
            curState->node->tokenLists["str"].push_back(token);
            a_valueLiteral_14_opt(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_valueLiteral_13_str_L_STR_LIT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_13_str_L_STR_LIT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral = str:L_STR_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_14_opt(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_14_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_14_opt);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_valueLiteral_15_suf_L_LIT_SUFFIX({state}, nextStates, curNode);
            }
        }
    
        // valueLiteral = str:L_STR_LIT [ _ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_15_suf_L_LIT_SUFFIX(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LIT_SUFFIX)
                return false;
            curState->node->tokenLists["suf"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_15_suf_L_LIT_SUFFIX(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_15_suf_L_LIT_SUFFIX];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral
        bool n_listLiteral(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_listLiteral);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_listLiteral>();
                for (auto par : parentStates) par->subNode = state->node;
                a_listLiteral_1_L_LEFT_BRACK({state}, nextStates, curNode);
                a_listLiteral_7_L_LEFT_BRACK({state}, nextStates, curNode);
            }
        }
    
        // listLiteral = _ '[' <items:expression> (',' <items:expression>)* ']'
        bool n_listLiteral_1_L_LEFT_BRACK(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_BRACK)
                return false;
            a_listLiteral_2_items_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_listLiteral_1_L_LEFT_BRACK(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_1_L_LEFT_BRACK];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral = '[' _ <items:expression> (',' <items:expression>)* ']'
        bool n_listLiteral_2_items_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            a_listLiteral_3_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_listLiteral_2_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_2_items_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // listLiteral = '[' <items:expression> _ (',' <items:expression>)* ']'
        bool n_listLiteral_3_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            a_listLiteral_6_L_RIGHT_BRACK(curState->parentStates, nextStates, curState->node);
            a_listLiteral_3_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_listLiteral_3_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_3_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_listLiteral_4_L_COMMA({state}, nextStates, curNode);
            }
        }
    
        // listLiteral = '[' <items:expression> (_ ',' <items:expression>)* ']'
        bool n_listLiteral_4_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            a_listLiteral_5_items_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_listLiteral_4_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_4_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral = '[' <items:expression> (',' _ <items:expression>)* ']'
        bool n_listLiteral_5_items_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_5_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_5_items_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // listLiteral = '[' <items:expression> (',' <items:expression>)* _ ']'
        bool n_listLiteral_6_L_RIGHT_BRACK(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_BRACK)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_6_L_RIGHT_BRACK(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_6_L_RIGHT_BRACK];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral = _ '[' <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> ']'
        bool n_listLiteral_7_L_LEFT_BRACK(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_BRACK)
                return false;
            a_listLiteral_8_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_listLiteral_7_L_LEFT_BRACK(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_7_L_LEFT_BRACK];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral = '[' _ <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> ']'
        bool n_listLiteral_8_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_listLiteral_9_items_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_listLiteral_8_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_8_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // listLiteral = '[' <ONL> _ <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> ']'
        bool n_listLiteral_9_items_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            a_listLiteral_10_L_COMMA(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_listLiteral_9_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_9_items_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // listLiteral = '[' <ONL> <items:expression> _ ',' (<ONL> <items:expression> ',')* <ONL> ']'
        bool n_listLiteral_10_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            a_listLiteral_11_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_listLiteral_10_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_10_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' _ (<ONL> <items:expression> ',')* <ONL> ']'
        bool n_listLiteral_11_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            a_listLiteral_15_ONL(curState->parentStates, nextStates, curState->node);
            a_listLiteral_11_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_listLiteral_11_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_11_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_listLiteral_12_ONL({state}, nextStates, curNode);
            }
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' (_ <ONL> <items:expression> ',')* <ONL> ']'
        bool n_listLiteral_12_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_listLiteral_13_items_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_listLiteral_12_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_12_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' (<ONL> _ <items:expression> ',')* <ONL> ']'
        bool n_listLiteral_13_items_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            a_listLiteral_14_L_COMMA(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_listLiteral_13_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_13_items_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' (<ONL> <items:expression> _ ',')* <ONL> ']'
        bool n_listLiteral_14_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_14_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_14_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* _ <ONL> ']'
        bool n_listLiteral_15_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_listLiteral_16_L_RIGHT_BRACK(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_listLiteral_15_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_15_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> _ ']'
        bool n_listLiteral_16_L_RIGHT_BRACK(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_BRACK)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_16_L_RIGHT_BRACK(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_16_L_RIGHT_BRACK];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral
        bool n_setLiteral(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_setLiteral);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_setLiteral>();
                for (auto par : parentStates) par->subNode = state->node;
                a_setLiteral_1_L_LEFT_BRACE({state}, nextStates, curNode);
                a_setLiteral_7_L_LEFT_BRACE({state}, nextStates, curNode);
            }
        }
    
        // setLiteral 	= _ '{' <items:expression> (',' <items:expression>)* '}'
        bool n_setLiteral_1_L_LEFT_BRACE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_BRACE)
                return false;
            a_setLiteral_2_items_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_setLiteral_1_L_LEFT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_1_L_LEFT_BRACE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral 	= '{' _ <items:expression> (',' <items:expression>)* '}'
        bool n_setLiteral_2_items_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            a_setLiteral_3_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_setLiteral_2_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_2_items_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // setLiteral 	= '{' <items:expression> _ (',' <items:expression>)* '}'
        bool n_setLiteral_3_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            a_setLiteral_6_L_RIGHT_BRACE(curState->parentStates, nextStates, curState->node);
            a_setLiteral_3_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_setLiteral_3_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_3_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_setLiteral_4_L_COMMA({state}, nextStates, curNode);
            }
        }
    
        // setLiteral 	= '{' <items:expression> (_ ',' <items:expression>)* '}'
        bool n_setLiteral_4_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            a_setLiteral_5_items_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_setLiteral_4_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_4_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral 	= '{' <items:expression> (',' _ <items:expression>)* '}'
        bool n_setLiteral_5_items_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_5_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_5_items_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // setLiteral 	= '{' <items:expression> (',' <items:expression>)* _ '}'
        bool n_setLiteral_6_L_RIGHT_BRACE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_BRACE)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_6_L_RIGHT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_6_L_RIGHT_BRACE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral = _ '{' <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> '}'
        bool n_setLiteral_7_L_LEFT_BRACE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_BRACE)
                return false;
            a_setLiteral_8_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_setLiteral_7_L_LEFT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_7_L_LEFT_BRACE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral = '{' _ <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> '}'
        bool n_setLiteral_8_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_setLiteral_9_items_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_setLiteral_8_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_8_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // setLiteral = '{' <ONL> _ <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> '}'
        bool n_setLiteral_9_items_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            a_setLiteral_10_L_COMMA(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_setLiteral_9_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_9_items_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // setLiteral = '{' <ONL> <items:expression> _ ',' (<ONL> <items:expression> ',')* <ONL> '}'
        bool n_setLiteral_10_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            a_setLiteral_11_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_setLiteral_10_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_10_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' _ (<ONL> <items:expression> ',')* <ONL> '}'
        bool n_setLiteral_11_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            a_setLiteral_15_ONL(curState->parentStates, nextStates, curState->node);
            a_setLiteral_11_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_setLiteral_11_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_11_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_setLiteral_12_ONL({state}, nextStates, curNode);
            }
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' (_ <ONL> <items:expression> ',')* <ONL> '}'
        bool n_setLiteral_12_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_setLiteral_13_items_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_setLiteral_12_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_12_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' (<ONL> _ <items:expression> ',')* <ONL> '}'
        bool n_setLiteral_13_items_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            a_setLiteral_14_L_COMMA(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_setLiteral_13_items_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_13_items_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' (<ONL> <items:expression> _ ',')* <ONL> '}'
        bool n_setLiteral_14_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_14_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_14_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* _ <ONL> '}'
        bool n_setLiteral_15_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_setLiteral_16_L_RIGHT_BRACE(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_setLiteral_15_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_15_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> _ '}'
        bool n_setLiteral_16_L_RIGHT_BRACE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_BRACE)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_16_L_RIGHT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_16_L_RIGHT_BRACE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral
        bool n_dictLiteral(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dictLiteral>();
                for (auto par : parentStates) par->subNode = state->node;
                a_dictLiteral_1_L_LEFT_BRACE({state}, nextStates, curNode);
                a_dictLiteral_8_L_LEFT_BRACE({state}, nextStates, curNode);
            }
        }
    
        // dictLiteral = _ '{' ':' <items:dictEntry> (',' <items:dictEntry>)* '}'
        bool n_dictLiteral_1_L_LEFT_BRACE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_BRACE)
                return false;
            a_dictLiteral_2_L_COLON(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_1_L_LEFT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_1_L_LEFT_BRACE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = '{' _ ':' <items:dictEntry> (',' <items:dictEntry>)* '}'
        bool n_dictLiteral_2_L_COLON(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            a_dictLiteral_3_items_dictEntry(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_2_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_2_L_COLON];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = '{' ':' _ <items:dictEntry> (',' <items:dictEntry>)* '}'
        bool n_dictLiteral_3_items_dictEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            a_dictLiteral_4_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_3_items_dictEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_3_items_dictEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_dictEntry({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // dictLiteral = '{' ':' <items:dictEntry> _ (',' <items:dictEntry>)* '}'
        bool n_dictLiteral_4_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            a_dictLiteral_7_L_RIGHT_BRACE(curState->parentStates, nextStates, curState->node);
            a_dictLiteral_4_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_4_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_4_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_dictLiteral_5_L_COMMA({state}, nextStates, curNode);
            }
        }
    
        // dictLiteral = '{' ':' <items:dictEntry> (_ ',' <items:dictEntry>)* '}'
        bool n_dictLiteral_5_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            a_dictLiteral_6_items_dictEntry(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_5_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_5_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = '{' ':' <items:dictEntry> (',' _ <items:dictEntry>)* '}'
        bool n_dictLiteral_6_items_dictEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_6_items_dictEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_6_items_dictEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_dictEntry({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // dictLiteral = '{' ':' <items:dictEntry> (',' <items:dictEntry>)* _ '}'
        bool n_dictLiteral_7_L_RIGHT_BRACE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_BRACE)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_7_L_RIGHT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_7_L_RIGHT_BRACE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = _ '{' ':' <ONL> <items:dictEntry> ',' (<ONL> <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_8_L_LEFT_BRACE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_BRACE)
                return false;
            a_dictLiteral_9_L_COLON(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_8_L_LEFT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_8_L_LEFT_BRACE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = '{' _ ':' <ONL> <items:dictEntry> ',' (<ONL> <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_9_L_COLON(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            a_dictLiteral_10_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_9_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_9_L_COLON];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = '{' ':' _ <ONL> <items:dictEntry> ',' (<ONL> <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_10_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_dictLiteral_11_items_dictEntry(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_10_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_10_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // dictLiteral = '{' ':' <ONL> _ <items:dictEntry> ',' (<ONL> <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_11_items_dictEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            a_dictLiteral_12_L_COMMA(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_11_items_dictEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_11_items_dictEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_dictEntry({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> _ ',' (<ONL> <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_12_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            a_dictLiteral_13_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_12_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_12_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' _ (<ONL> <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_13_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            a_dictLiteral_17_ONL(curState->parentStates, nextStates, curState->node);
            a_dictLiteral_13_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_13_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_13_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_dictLiteral_14_ONL({state}, nextStates, curNode);
            }
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' (_ <ONL> <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_14_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_dictLiteral_15_items_dictEntry(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_14_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_14_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' (<ONL> _ <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_15_items_dictEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            a_dictLiteral_16_L_COMMA(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_15_items_dictEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_15_items_dictEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_dictEntry({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' (<ONL> <items:dictEntry> _ ',')* <ONL> '}'
        bool n_dictLiteral_16_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_16_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_16_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' (<ONL> <items:dictEntry> ',')* _ <ONL> '}'
        bool n_dictLiteral_17_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_dictLiteral_18_L_RIGHT_BRACE(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictLiteral_17_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_17_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' (<ONL> <items:dictEntry> ',')* <ONL> _ '}'
        bool n_dictLiteral_18_L_RIGHT_BRACE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_BRACE)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_18_L_RIGHT_BRACE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_18_L_RIGHT_BRACE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictEntry
        bool n_dictEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dictEntry>();
                for (auto par : parentStates) par->subNode = state->node;
                a_dictEntry_1_key_expression({state}, nextStates, curNode);
            }
        }
    
        // dictEntry = _ <key:expression> ':' <ONL> <value:expression>
        bool n_dictEntry_1_key_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["key"].push_back(curState->subNode);
            a_dictEntry_2_L_COLON(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictEntry_1_key_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictEntry_1_key_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["key"].push_back(state->subNode);
            }
        }
    
        // dictEntry = <key:expression> _ ':' <ONL> <value:expression>
        bool n_dictEntry_2_L_COLON(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            a_dictEntry_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictEntry_2_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictEntry_2_L_COLON];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictEntry = <key:expression> ':' _ <ONL> <value:expression>
        bool n_dictEntry_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_dictEntry_4_value_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dictEntry_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictEntry_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // dictEntry = <key:expression> ':' <ONL> _ <value:expression>
        bool n_dictEntry_4_value_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["value"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictEntry_4_value_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dictEntry_4_value_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["value"].push_back(state->subNode);
            }
        }
    
        // contextLiteral
        bool n_contextLiteral(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextLiteral>();
                for (auto par : parentStates) par->subNode = state->node;
                a_contextLiteral_1_L_LEFT_PAR({state}, nextStates, curNode);
                a_contextLiteral_7_L_LEFT_PAR({state}, nextStates, curNode);
            }
        }
    
        // contextLiteral 	= _ '(' <items:memberDecl> (',' <items:memberDecl>)* ')'
        bool n_contextLiteral_1_L_LEFT_PAR(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_PAR)
                return false;
            a_contextLiteral_2_items_memberDecl(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextLiteral_1_L_LEFT_PAR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_1_L_LEFT_PAR];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextLiteral 	= '(' _ <items:memberDecl> (',' <items:memberDecl>)* ')'
        bool n_contextLiteral_2_items_memberDecl(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            a_contextLiteral_3_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextLiteral_2_items_memberDecl(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_2_items_memberDecl);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_memberDecl({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // contextLiteral 	= '(' <items:memberDecl> _ (',' <items:memberDecl>)* ')'
        bool n_contextLiteral_3_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            a_contextLiteral_6_L_RIGHT_PAR(curState->parentStates, nextStates, curState->node);
            a_contextLiteral_3_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextLiteral_3_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_3_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextLiteral_4_L_COMMA({state}, nextStates, curNode);
            }
        }
    
        // contextLiteral 	= '(' <items:memberDecl> (_ ',' <items:memberDecl>)* ')'
        bool n_contextLiteral_4_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            a_contextLiteral_5_items_memberDecl(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextLiteral_4_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_4_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextLiteral 	= '(' <items:memberDecl> (',' _ <items:memberDecl>)* ')'
        bool n_contextLiteral_5_items_memberDecl(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_5_items_memberDecl(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_5_items_memberDecl);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_memberDecl({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // contextLiteral 	= '(' <items:memberDecl> (',' <items:memberDecl>)* _ ')'
        bool n_contextLiteral_6_L_RIGHT_PAR(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_PAR)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_6_L_RIGHT_PAR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_6_L_RIGHT_PAR];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextLiteral = _ '(' <ONL> <items:memberDecl> (',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        bool n_contextLiteral_7_L_LEFT_PAR(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_PAR)
                return false;
            a_contextLiteral_8_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextLiteral_7_L_LEFT_PAR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_7_L_LEFT_PAR];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextLiteral = '(' _ <ONL> <items:memberDecl> (',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        bool n_contextLiteral_8_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_contextLiteral_9_items_memberDecl(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextLiteral_8_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_8_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // contextLiteral = '(' <ONL> _ <items:memberDecl> (',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        bool n_contextLiteral_9_items_memberDecl(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            a_contextLiteral_10_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextLiteral_9_items_memberDecl(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_9_items_memberDecl);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_memberDecl({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> _ (',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        bool n_contextLiteral_10_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            a_contextLiteral_14_L_COMMA(curState->parentStates, nextStates, curState->node);
            a_contextLiteral_10_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextLiteral_10_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_10_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextLiteral_11_L_COMMA({state}, nextStates, curNode);
            }
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> (_ ',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        bool n_contextLiteral_11_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            a_contextLiteral_12_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextLiteral_11_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_11_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> (',' _ <ONL> <items:memberDecl>)* ',' <ONL> ')'
        bool n_contextLiteral_12_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_contextLiteral_13_items_memberDecl(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextLiteral_12_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_12_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> (',' <ONL> _ <items:memberDecl>)* ',' <ONL> ')'
        bool n_contextLiteral_13_items_memberDecl(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_13_items_memberDecl(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_13_items_memberDecl);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_memberDecl({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> (',' <ONL> <items:memberDecl>)* _ ',' <ONL> ')'
        bool n_contextLiteral_14_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            a_contextLiteral_15_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextLiteral_14_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_14_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> (',' <ONL> <items:memberDecl>)* ',' _ <ONL> ')'
        bool n_contextLiteral_15_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_contextLiteral_16_L_RIGHT_PAR(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_contextLiteral_15_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_15_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> (',' <ONL> <items:memberDecl>)* ',' <ONL> _ ')'
        bool n_contextLiteral_16_L_RIGHT_PAR(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_PAR)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_16_L_RIGHT_PAR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_16_L_RIGHT_PAR];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // memberDecl
        bool n_memberDecl(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_memberDecl(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_memberDecl);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_memberDecl>();
                for (auto par : parentStates) par->subNode = state->node;
                a_memberDecl_1_member_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // memberDecl = _ member:L_IDENTIFIER '=' <value:expression>
        bool n_memberDecl_1_member_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists["member"].push_back(token);
            a_memberDecl_2_L_CHANGE(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_memberDecl_1_member_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_memberDecl_1_member_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // memberDecl = member:L_IDENTIFIER _ '=' <value:expression>
        bool n_memberDecl_2_L_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CHANGE)
                return false;
            a_memberDecl_3_value_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_memberDecl_2_L_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_memberDecl_2_L_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // memberDecl = member:L_IDENTIFIER '=' _ <value:expression>
        bool n_memberDecl_3_value_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["value"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_memberDecl_3_value_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_memberDecl_3_value_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["value"].push_back(state->subNode);
            }
        }
    
        // statement
        bool n_statement(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_statement);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_statement>();
                for (auto par : parentStates) par->subNode = state->node;
                a_statement_1_expression({state}, nextStates, curNode);
                a_statement_2_definition({state}, nextStates, curNode);
                a_statement_3_varDeclaration({state}, nextStates, curNode);
                a_statement_4_assignmentEqual({state}, nextStates, curNode);
                a_statement_5_ifStat({state}, nextStates, curNode);
                a_statement_6_loopStat({state}, nextStates, curNode);
                a_statement_7_jumpStat({state}, nextStates, curNode);
                a_statement_8_withStat({state}, nextStates, curNode);
            }
        }
    
        // statement 	= _ <expression>
        bool n_statement_1_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement_1_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_statement_1_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // statement = _ <definition>
        bool n_statement_2_definition(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement_2_definition(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_statement_2_definition);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_definition({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // statement = _ <varDeclaration>
        bool n_statement_3_varDeclaration(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement_3_varDeclaration(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_statement_3_varDeclaration);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_varDeclaration({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // statement = _ <assignmentEqual>
        bool n_statement_4_assignmentEqual(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement_4_assignmentEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_statement_4_assignmentEqual);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_assignmentEqual({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // statement = _ <ifStat>
        bool n_statement_5_ifStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement_5_ifStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_statement_5_ifStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ifStat({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // statement = _ <loopStat>
        bool n_statement_6_loopStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement_6_loopStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_statement_6_loopStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_loopStat({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // statement = _ <jumpStat>
        bool n_statement_7_jumpStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement_7_jumpStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_statement_7_jumpStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_jumpStat({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // statement = _ <withStat>
        bool n_statement_8_withStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement_8_withStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_statement_8_withStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_withStat({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // definition
        bool n_definition(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_definition(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_definition);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_definition>();
                for (auto par : parentStates) par->subNode = state->node;
                a_definition_1_L_IDENTIFIER({state}, nextStates, curNode);
                a_definition_6_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // definition 	= _ 'def' <id:identifier> '='? <ONL> <val:expression>
        bool n_definition_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_definition_2_id_identifier(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_definition_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_definition_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // definition 	= 'def' _ <id:identifier> '='? <ONL> <val:expression>
        bool n_definition_2_id_identifier(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["id"].push_back(curState->subNode);
            a_definition_3_L_CHANGE(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_definition_2_id_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_definition_2_id_identifier);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_identifier({state}, nextStates, curNode);
            state->node->nodeLists["id"].push_back(state->subNode);
            }
        }
    
        // definition 	= 'def' <id:identifier> _ '='? <ONL> <val:expression>
        bool n_definition_3_L_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CHANGE)
                return false;
            a_definition_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_definition_3_L_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_definition_3_L_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // definition 	= 'def' <id:identifier> '='? _ <ONL> <val:expression>
        bool n_definition_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_definition_5_val_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_definition_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_definition_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // definition 	= 'def' <id:identifier> '='? <ONL> _ <val:expression>
        bool n_definition_5_val_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_definition_5_val_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_definition_5_val_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // definition = _ 'def' <id:identifier> ':' '\n' <contextBodyClosedBlock>
        bool n_definition_6_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_definition_7_id_identifier(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_definition_6_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_definition_6_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // definition = 'def' _ <id:identifier> ':' '\n' <contextBodyClosedBlock>
        bool n_definition_7_id_identifier(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["id"].push_back(curState->subNode);
            a_definition_8_L_COLON(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_definition_7_id_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_definition_7_id_identifier);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_identifier({state}, nextStates, curNode);
            state->node->nodeLists["id"].push_back(state->subNode);
            }
        }
    
        // definition = 'def' <id:identifier> _ ':' '\n' <contextBodyClosedBlock>
        bool n_definition_8_L_COLON(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            a_definition_9_L_NEW_LN(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_definition_8_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_definition_8_L_COLON];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // definition = 'def' <id:identifier> ':' _ '\n' <contextBodyClosedBlock>
        bool n_definition_9_L_NEW_LN(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            a_definition_10_contextBodyClosedBlock(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_definition_9_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_definition_9_L_NEW_LN];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // definition = 'def' <id:identifier> ':' '\n' _ <contextBodyClosedBlock>
        bool n_definition_10_contextBodyClosedBlock(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_definition_10_contextBodyClosedBlock(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_definition_10_contextBodyClosedBlock);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextBodyClosedBlock({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // varDeclaration
        bool n_varDeclaration(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varDeclaration(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varDeclaration);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varDeclaration>();
                for (auto par : parentStates) par->subNode = state->node;
                a_varDeclaration_1_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // varDeclaration 	= _ 'var' <body:varRefDeclBody>
        bool n_varDeclaration_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_varDeclaration_2_body_varRefDeclBody(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_varDeclaration_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_varDeclaration_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // varDeclaration 	= 'var' _ <body:varRefDeclBody>
        bool n_varDeclaration_2_body_varRefDeclBody(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["body"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varDeclaration_2_body_varRefDeclBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varDeclaration_2_body_varRefDeclBody);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_varRefDeclBody({state}, nextStates, curNode);
            state->node->nodeLists["body"].push_back(state->subNode);
            }
        }
    
        // refDeclaration
        bool n_refDeclaration(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_refDeclaration(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_refDeclaration);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_refDeclaration>();
                for (auto par : parentStates) par->subNode = state->node;
                a_refDeclaration_1_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // refDeclaration 	= _ 'ref' <body:varRefDeclBody>
        bool n_refDeclaration_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_refDeclaration_2_body_varRefDeclBody(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_refDeclaration_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_refDeclaration_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // refDeclaration 	= 'ref' _ <body:varRefDeclBody>
        bool n_refDeclaration_2_body_varRefDeclBody(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["body"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_refDeclaration_2_body_varRefDeclBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_refDeclaration_2_body_varRefDeclBody);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_varRefDeclBody({state}, nextStates, curNode);
            state->node->nodeLists["body"].push_back(state->subNode);
            }
        }
    
        // varRefDeclBody
        bool n_varRefDeclBody(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclBody);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varRefDeclBody>();
                for (auto par : parentStates) par->subNode = state->node;
                a_varRefDeclBody_1_items_varRefDeclEntry({state}, nextStates, curNode);
            }
        }
    
        // varRefDeclBody = _ <items:varRefDeclEntry> (',' <ONL> <items:varRefDeclEntry>)*
        bool n_varRefDeclBody_1_items_varRefDeclEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            a_varRefDeclBody_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_varRefDeclBody_1_items_varRefDeclEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclBody_1_items_varRefDeclEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_varRefDeclEntry({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // varRefDeclBody = <items:varRefDeclEntry> _ (',' <ONL> <items:varRefDeclEntry>)*
        bool n_varRefDeclBody_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_varRefDeclBody_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_varRefDeclBody_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclBody_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_varRefDeclBody_3_L_COMMA({state}, nextStates, curNode);
            }
        }
    
        // varRefDeclBody = <items:varRefDeclEntry> (_ ',' <ONL> <items:varRefDeclEntry>)*
        bool n_varRefDeclBody_3_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            a_varRefDeclBody_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_varRefDeclBody_3_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_varRefDeclBody_3_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // varRefDeclBody = <items:varRefDeclEntry> (',' _ <ONL> <items:varRefDeclEntry>)*
        bool n_varRefDeclBody_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_varRefDeclBody_5_items_varRefDeclEntry(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_varRefDeclBody_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclBody_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // varRefDeclBody = <items:varRefDeclEntry> (',' <ONL> _ <items:varRefDeclEntry>)*
        bool n_varRefDeclBody_5_items_varRefDeclEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["items"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclBody_5_items_varRefDeclEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclBody_5_items_varRefDeclEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_varRefDeclEntry({state}, nextStates, curNode);
            state->node->nodeLists["items"].push_back(state->subNode);
            }
        }
    
        // varRefDeclEntry
        bool n_varRefDeclEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varRefDeclEntry>();
                for (auto par : parentStates) par->subNode = state->node;
                a_varRefDeclEntry_1_equal_varRefDeclEntryEqual({state}, nextStates, curNode);
                a_varRefDeclEntry_2_assign_varRefDeclEntryAssign({state}, nextStates, curNode);
            }
        }
    
        // varRefDeclEntry 	= _ <equal:varRefDeclEntryEqual>
        bool n_varRefDeclEntry_1_equal_varRefDeclEntryEqual(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["equal"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclEntry_1_equal_varRefDeclEntryEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntry_1_equal_varRefDeclEntryEqual);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_varRefDeclEntryEqual({state}, nextStates, curNode);
            state->node->nodeLists["equal"].push_back(state->subNode);
            }
        }
    
        // varRefDeclEntry = _ <assign:varRefDeclEntryAssign>
        bool n_varRefDeclEntry_2_assign_varRefDeclEntryAssign(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["assign"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclEntry_2_assign_varRefDeclEntryAssign(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntry_2_assign_varRefDeclEntryAssign);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_varRefDeclEntryAssign({state}, nextStates, curNode);
            state->node->nodeLists["assign"].push_back(state->subNode);
            }
        }
    
        // varRefDeclEntryEqual
        bool n_varRefDeclEntryEqual(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclEntryEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntryEqual);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varRefDeclEntryEqual>();
                for (auto par : parentStates) par->subNode = state->node;
                a_varRefDeclEntryEqual_1_id_identifier({state}, nextStates, curNode);
            }
        }
    
        // varRefDeclEntryEqual = _ <id:identifier> '=' <ONL> <val:expression>
        bool n_varRefDeclEntryEqual_1_id_identifier(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["id"].push_back(curState->subNode);
            a_varRefDeclEntryEqual_2_L_CHANGE(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_varRefDeclEntryEqual_1_id_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntryEqual_1_id_identifier);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_identifier({state}, nextStates, curNode);
            state->node->nodeLists["id"].push_back(state->subNode);
            }
        }
    
        // varRefDeclEntryEqual = <id:identifier> _ '=' <ONL> <val:expression>
        bool n_varRefDeclEntryEqual_2_L_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CHANGE)
                return false;
            a_varRefDeclEntryEqual_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_varRefDeclEntryEqual_2_L_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_varRefDeclEntryEqual_2_L_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // varRefDeclEntryEqual = <id:identifier> '=' _ <ONL> <val:expression>
        bool n_varRefDeclEntryEqual_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_varRefDeclEntryEqual_4_val_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_varRefDeclEntryEqual_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntryEqual_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // varRefDeclEntryEqual = <id:identifier> '=' <ONL> _ <val:expression>
        bool n_varRefDeclEntryEqual_4_val_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclEntryEqual_4_val_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntryEqual_4_val_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // varRefDeclEntryAssign
        bool n_varRefDeclEntryAssign(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclEntryAssign(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntryAssign);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varRefDeclEntryAssign>();
                for (auto par : parentStates) par->subNode = state->node;
                a_varRefDeclEntryAssign_1_id_identifier({state}, nextStates, curNode);
            }
        }
    
        // varRefDeclEntryAssign = _ <id:identifier> '->' <ONL> <val:expression>
        bool n_varRefDeclEntryAssign_1_id_identifier(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["id"].push_back(curState->subNode);
            a_varRefDeclEntryAssign_2_L_ASSIGN(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_varRefDeclEntryAssign_1_id_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntryAssign_1_id_identifier);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_identifier({state}, nextStates, curNode);
            state->node->nodeLists["id"].push_back(state->subNode);
            }
        }
    
        // varRefDeclEntryAssign = <id:identifier> _ '->' <ONL> <val:expression>
        bool n_varRefDeclEntryAssign_2_L_ASSIGN(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_ASSIGN)
                return false;
            a_varRefDeclEntryAssign_3_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_varRefDeclEntryAssign_2_L_ASSIGN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_varRefDeclEntryAssign_2_L_ASSIGN];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // varRefDeclEntryAssign = <id:identifier> '->' _ <ONL> <val:expression>
        bool n_varRefDeclEntryAssign_3_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_varRefDeclEntryAssign_4_val_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_varRefDeclEntryAssign_3_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntryAssign_3_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // varRefDeclEntryAssign = <id:identifier> '->' <ONL> _ <val:expression>
        bool n_varRefDeclEntryAssign_4_val_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclEntryAssign_4_val_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntryAssign_4_val_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // ifStat
        bool n_ifStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_ifStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ifStat>();
                for (auto par : parentStates) par->subNode = state->node;
                a_ifStat_1_L_IDENTIFIER({state}, nextStates, curNode);
                a_ifStat_7_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // ifStat 	= _ 'if' <cond:expression> ':' <exec1:statement> [ <elseStatPart> ]
        bool n_ifStat_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_ifStat_2_cond_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_ifStat_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ifStat_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // ifStat 	= 'if' _ <cond:expression> ':' <exec1:statement> [ <elseStatPart> ]
        bool n_ifStat_2_cond_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["cond"].push_back(curState->subNode);
            a_ifStat_3_L_COLON(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_ifStat_2_cond_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_ifStat_2_cond_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["cond"].push_back(state->subNode);
            }
        }
    
        // ifStat 	= 'if' <cond:expression> _ ':' <exec1:statement> [ <elseStatPart> ]
        bool n_ifStat_3_L_COLON(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            a_ifStat_4_exec1_statement(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_ifStat_3_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ifStat_3_L_COLON];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // ifStat 	= 'if' <cond:expression> ':' _ <exec1:statement> [ <elseStatPart> ]
        bool n_ifStat_4_exec1_statement(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["exec1"].push_back(curState->subNode);
            a_ifStat_5_opt(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_ifStat_4_exec1_statement(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_ifStat_4_exec1_statement);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_statement({state}, nextStates, curNode);
            state->node->nodeLists["exec1"].push_back(state->subNode);
            }
        }
    
        // ifStat 	= 'if' <cond:expression> ':' <exec1:statement> _ [ <elseStatPart> ]
        bool n_ifStat_5_opt(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_5_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_ifStat_5_opt);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ifStat_6_elseStatPart({state}, nextStates, curNode);
            }
        }
    
        // ifStat 	= 'if' <cond:expression> ':' <exec1:statement> [ _ <elseStatPart> ]
        bool n_ifStat_6_elseStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_6_elseStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_ifStat_6_elseStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_elseStatPart({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // ifStat = _ 'if' <cond:expression> ':' '\n' <exec1:contextBody> [ <elseStatPart> ] 'ok'
        bool n_ifStat_7_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_ifStat_8_cond_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_ifStat_7_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ifStat_7_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // ifStat = 'if' _ <cond:expression> ':' '\n' <exec1:contextBody> [ <elseStatPart> ] 'ok'
        bool n_ifStat_8_cond_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["cond"].push_back(curState->subNode);
            a_ifStat_9_L_COLON(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_ifStat_8_cond_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_ifStat_8_cond_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["cond"].push_back(state->subNode);
            }
        }
    
        // ifStat = 'if' <cond:expression> _ ':' '\n' <exec1:contextBody> [ <elseStatPart> ] 'ok'
        bool n_ifStat_9_L_COLON(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            a_ifStat_10_L_NEW_LN(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_ifStat_9_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ifStat_9_L_COLON];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // ifStat = 'if' <cond:expression> ':' _ '\n' <exec1:contextBody> [ <elseStatPart> ] 'ok'
        bool n_ifStat_10_L_NEW_LN(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            a_ifStat_11_exec1_contextBody(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_ifStat_10_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ifStat_10_L_NEW_LN];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // ifStat = 'if' <cond:expression> ':' '\n' _ <exec1:contextBody> [ <elseStatPart> ] 'ok'
        bool n_ifStat_11_exec1_contextBody(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["exec1"].push_back(curState->subNode);
            a_ifStat_12_opt(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_ifStat_11_exec1_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_ifStat_11_exec1_contextBody);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextBody({state}, nextStates, curNode);
            state->node->nodeLists["exec1"].push_back(state->subNode);
            }
        }
    
        // ifStat = 'if' <cond:expression> ':' '\n' <exec1:contextBody> _ [ <elseStatPart> ] 'ok'
        bool n_ifStat_12_opt(StatePtr curState, StateSet& nextStates, const Token& token) {
            a_ifStat_14_L_IDENTIFIER(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_ifStat_12_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_ifStat_12_opt);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ifStat_13_elseStatPart({state}, nextStates, curNode);
            }
        }
    
        // ifStat = 'if' <cond:expression> ':' '\n' <exec1:contextBody> [ _ <elseStatPart> ] 'ok'
        bool n_ifStat_13_elseStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_13_elseStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_ifStat_13_elseStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_elseStatPart({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // ifStat = 'if' <cond:expression> ':' '\n' <exec1:contextBody> [ <elseStatPart> ] _ 'ok'
        bool n_ifStat_14_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_14_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ifStat_14_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart
        bool n_elseStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_elseStatPart>();
                for (auto par : parentStates) par->subNode = state->node;
                a_elseStatPart_1_L_IDENTIFIER({state}, nextStates, curNode);
                a_elseStatPart_4_L_IDENTIFIER({state}, nextStates, curNode);
                a_elseStatPart_8_L_IDENTIFIER({state}, nextStates, curNode);
                a_elseStatPart_14_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // elseStatPart 	= _ 'else' ':' <statement>
        bool n_elseStatPart_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_elseStatPart_2_L_COLON(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart 	= 'else' _ ':' <statement>
        bool n_elseStatPart_2_L_COLON(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            a_elseStatPart_3_statement(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_2_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_2_L_COLON];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart 	= 'else' ':' _ <statement>
        bool n_elseStatPart_3_statement(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_3_statement(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_3_statement);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_statement({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // elseStatPart = _ 'else' ':' '\n' <contextBody>
        bool n_elseStatPart_4_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_elseStatPart_5_L_COLON(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_4_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_4_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = 'else' _ ':' '\n' <contextBody>
        bool n_elseStatPart_5_L_COLON(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            a_elseStatPart_6_L_NEW_LN(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_5_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_5_L_COLON];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = 'else' ':' _ '\n' <contextBody>
        bool n_elseStatPart_6_L_NEW_LN(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            a_elseStatPart_7_contextBody(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_6_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_6_L_NEW_LN];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = 'else' ':' '\n' _ <contextBody>
        bool n_elseStatPart_7_contextBody(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_7_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_7_contextBody);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextBody({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // elseStatPart = _ 'elif' <expression> ':' <statement> [ <elseStatPart> ]
        bool n_elseStatPart_8_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_elseStatPart_9_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_8_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_8_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = 'elif' _ <expression> ':' <statement> [ <elseStatPart> ]
        bool n_elseStatPart_9_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_elseStatPart_10_L_COLON(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_9_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_9_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // elseStatPart = 'elif' <expression> _ ':' <statement> [ <elseStatPart> ]
        bool n_elseStatPart_10_L_COLON(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            a_elseStatPart_11_statement(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_10_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_10_L_COLON];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' _ <statement> [ <elseStatPart> ]
        bool n_elseStatPart_11_statement(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_elseStatPart_12_opt(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_11_statement(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_11_statement);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_statement({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' <statement> _ [ <elseStatPart> ]
        bool n_elseStatPart_12_opt(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_12_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_12_opt);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_elseStatPart_13_elseStatPart({state}, nextStates, curNode);
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' <statement> [ _ <elseStatPart> ]
        bool n_elseStatPart_13_elseStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_13_elseStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_13_elseStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_elseStatPart({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // elseStatPart = _ 'elif' <expression> ':' '\n' <contextBody> [ <elseStatPart> ] 'ok'
        bool n_elseStatPart_14_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_elseStatPart_15_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_14_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_14_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = 'elif' _ <expression> ':' '\n' <contextBody> [ <elseStatPart> ] 'ok'
        bool n_elseStatPart_15_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_elseStatPart_16_L_COLON(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_15_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_15_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // elseStatPart = 'elif' <expression> _ ':' '\n' <contextBody> [ <elseStatPart> ] 'ok'
        bool n_elseStatPart_16_L_COLON(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            a_elseStatPart_17_L_NEW_LN(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_16_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_16_L_COLON];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' _ '\n' <contextBody> [ <elseStatPart> ] 'ok'
        bool n_elseStatPart_17_L_NEW_LN(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            a_elseStatPart_18_contextBody(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_17_L_NEW_LN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_17_L_NEW_LN];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' '\n' _ <contextBody> [ <elseStatPart> ] 'ok'
        bool n_elseStatPart_18_contextBody(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_elseStatPart_19_opt(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_18_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_18_contextBody);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextBody({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' '\n' <contextBody> _ [ <elseStatPart> ] 'ok'
        bool n_elseStatPart_19_opt(StatePtr curState, StateSet& nextStates, const Token& token) {
            a_elseStatPart_21_L_IDENTIFIER(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_elseStatPart_19_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_19_opt);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_elseStatPart_20_elseStatPart({state}, nextStates, curNode);
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' '\n' <contextBody> [ _ <elseStatPart> ] 'ok'
        bool n_elseStatPart_20_elseStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_20_elseStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_20_elseStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_elseStatPart({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' '\n' <contextBody> [ <elseStatPart> ] _ 'ok'
        bool n_elseStatPart_21_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_21_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_21_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // loopStat
        bool n_loopStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_loopStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_loopStat>();
                for (auto par : parentStates) par->subNode = state->node;
                a_loopStat_1_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // loopStat = _ 'repeat' <parts:loopStatPart> (';' <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        bool n_loopStat_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_loopStat_2_parts_loopStatPart(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_loopStat_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_loopStat_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // loopStat = 'repeat' _ <parts:loopStatPart> (';' <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        bool n_loopStat_2_parts_loopStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["parts"].push_back(curState->subNode);
            a_loopStat_3_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_loopStat_2_parts_loopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_loopStat_2_parts_loopStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_loopStatPart({state}, nextStates, curNode);
            state->node->nodeLists["parts"].push_back(state->subNode);
            }
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> _ (';' <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        bool n_loopStat_3_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            a_loopStat_6_L_COLON(curState->parentStates, nextStates, curState->node);
            a_loopStat_3_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_loopStat_3_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_loopStat_3_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_loopStat_4_L_SEMICOLON({state}, nextStates, curNode);
            }
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> (_ ';' <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        bool n_loopStat_4_L_SEMICOLON(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SEMICOLON)
                return false;
            a_loopStat_5_parts_loopStatPart(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_loopStat_4_L_SEMICOLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_loopStat_4_L_SEMICOLON];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> (';' _ <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        bool n_loopStat_5_parts_loopStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["parts"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStat_5_parts_loopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_loopStat_5_parts_loopStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_loopStatPart({state}, nextStates, curNode);
            state->node->nodeLists["parts"].push_back(state->subNode);
            }
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> (';' <parts:loopStatPart>)* _ ':' <contextBodyClosedBlock>
        bool n_loopStat_6_L_COLON(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            a_loopStat_7_contextBodyClosedBlock(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_loopStat_6_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_loopStat_6_L_COLON];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> (';' <parts:loopStatPart>)* ':' _ <contextBodyClosedBlock>
        bool n_loopStat_7_contextBodyClosedBlock(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStat_7_contextBodyClosedBlock(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_loopStat_7_contextBodyClosedBlock);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextBodyClosedBlock({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // loopStatPart
        bool n_loopStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_loopStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_loopStatPart>();
                for (auto par : parentStates) par->subNode = state->node;
                a_loopStatPart_1_timesLoopStatPart({state}, nextStates, curNode);
                a_loopStatPart_2_forLoopStatPart({state}, nextStates, curNode);
                a_loopStatPart_3_whileLoopStatPart({state}, nextStates, curNode);
            }
        }
    
        // loopStatPart 	= _ <timesLoopStatPart>
        bool n_loopStatPart_1_timesLoopStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStatPart_1_timesLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_loopStatPart_1_timesLoopStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_timesLoopStatPart({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // loopStatPart = _ <forLoopStatPart>
        bool n_loopStatPart_2_forLoopStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStatPart_2_forLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_loopStatPart_2_forLoopStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_forLoopStatPart({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // loopStatPart = _ <whileLoopStatPart>
        bool n_loopStatPart_3_whileLoopStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStatPart_3_whileLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_loopStatPart_3_whileLoopStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_whileLoopStatPart({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // timesLoopStatPart
        bool n_timesLoopStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_timesLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_timesLoopStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_timesLoopStatPart>();
                for (auto par : parentStates) par->subNode = state->node;
                a_timesLoopStatPart_1_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // timesLoopStatPart = _ 'times' <count:expression>
        bool n_timesLoopStatPart_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_timesLoopStatPart_2_count_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_timesLoopStatPart_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_timesLoopStatPart_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // timesLoopStatPart = 'times' _ <count:expression>
        bool n_timesLoopStatPart_2_count_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["count"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_timesLoopStatPart_2_count_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_timesLoopStatPart_2_count_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["count"].push_back(state->subNode);
            }
        }
    
        // forLoopStatPart
        bool n_forLoopStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_forLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_forLoopStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_forLoopStatPart>();
                for (auto par : parentStates) par->subNode = state->node;
                a_forLoopStatPart_1_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // forLoopStatPart = _ 'for' <id:identifier> 'in' <iterator:expression>
        bool n_forLoopStatPart_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_forLoopStatPart_2_id_identifier(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_forLoopStatPart_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_forLoopStatPart_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // forLoopStatPart = 'for' _ <id:identifier> 'in' <iterator:expression>
        bool n_forLoopStatPart_2_id_identifier(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["id"].push_back(curState->subNode);
            a_forLoopStatPart_3_L_IDENTIFIER(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_forLoopStatPart_2_id_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_forLoopStatPart_2_id_identifier);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_identifier({state}, nextStates, curNode);
            state->node->nodeLists["id"].push_back(state->subNode);
            }
        }
    
        // forLoopStatPart = 'for' <id:identifier> _ 'in' <iterator:expression>
        bool n_forLoopStatPart_3_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_forLoopStatPart_4_iterator_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_forLoopStatPart_3_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_forLoopStatPart_3_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // forLoopStatPart = 'for' <id:identifier> 'in' _ <iterator:expression>
        bool n_forLoopStatPart_4_iterator_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["iterator"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_forLoopStatPart_4_iterator_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_forLoopStatPart_4_iterator_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["iterator"].push_back(state->subNode);
            }
        }
    
        // whileLoopStatPart
        bool n_whileLoopStatPart(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_whileLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_whileLoopStatPart);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_whileLoopStatPart>();
                for (auto par : parentStates) par->subNode = state->node;
                a_whileLoopStatPart_1_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // whileLoopStatPart = _ 'while' <cond:expression>
        bool n_whileLoopStatPart_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_whileLoopStatPart_2_cond_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_whileLoopStatPart_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_whileLoopStatPart_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // whileLoopStatPart = 'while' _ <cond:expression>
        bool n_whileLoopStatPart_2_cond_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["cond"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_whileLoopStatPart_2_cond_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_whileLoopStatPart_2_cond_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["cond"].push_back(state->subNode);
            }
        }
    
        // jumpStat
        bool n_jumpStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_jumpStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_jumpStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_jumpStat>();
                for (auto par : parentStates) par->subNode = state->node;
                a_jumpStat_1_breakStat({state}, nextStates, curNode);
                a_jumpStat_2_continueStat({state}, nextStates, curNode);
                a_jumpStat_3_returnStat({state}, nextStates, curNode);
            }
        }
    
        // jumpStat 	= _ <breakStat>
        bool n_jumpStat_1_breakStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_jumpStat_1_breakStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_jumpStat_1_breakStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_breakStat({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // jumpStat = _ <continueStat>
        bool n_jumpStat_2_continueStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_jumpStat_2_continueStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_jumpStat_2_continueStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_continueStat({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // jumpStat = _ <returnStat>
        bool n_jumpStat_3_returnStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_jumpStat_3_returnStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_jumpStat_3_returnStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_returnStat({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // breakStat
        bool n_breakStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_breakStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_breakStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_breakStat>();
                for (auto par : parentStates) par->subNode = state->node;
                a_breakStat_1_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // breakStat = _ 'break'
        bool n_breakStat_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_breakStat_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_breakStat_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // continueStat
        bool n_continueStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_continueStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_continueStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_continueStat>();
                for (auto par : parentStates) par->subNode = state->node;
                a_continueStat_1_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // continueStat = _ 'continue'
        bool n_continueStat_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_continueStat_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_continueStat_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // returnStat
        bool n_returnStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_returnStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_returnStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_returnStat>();
                for (auto par : parentStates) par->subNode = state->node;
                a_returnStat_1_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // returnStat = _ 'return' [ <val:expression> ]
        bool n_returnStat_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_returnStat_2_opt(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_returnStat_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_returnStat_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // returnStat = 'return' _ [ <val:expression> ]
        bool n_returnStat_2_opt(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_returnStat_2_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_returnStat_2_opt);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_returnStat_3_val_expression({state}, nextStates, curNode);
            }
        }
    
        // returnStat = 'return' [ _ <val:expression> ]
        bool n_returnStat_3_val_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_returnStat_3_val_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_returnStat_3_val_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // withStat
        bool n_withStat(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_withStat);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_withStat>();
                for (auto par : parentStates) par->subNode = state->node;
                a_withStat_1_L_IDENTIFIER({state}, nextStates, curNode);
            }
        }
    
        // withStat = _ 'with' <entries:withStatEntry> [ ',' <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        bool n_withStat_1_L_IDENTIFIER(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            a_withStat_2_entries_withStatEntry(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_withStat_1_L_IDENTIFIER(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_withStat_1_L_IDENTIFIER];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // withStat = 'with' _ <entries:withStatEntry> [ ',' <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        bool n_withStat_2_entries_withStatEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["entries"].push_back(curState->subNode);
            a_withStat_3_opt(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_withStat_2_entries_withStatEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_withStat_2_entries_withStatEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_withStatEntry({state}, nextStates, curNode);
            state->node->nodeLists["entries"].push_back(state->subNode);
            }
        }
    
        // withStat = 'with' <entries:withStatEntry> _ [ ',' <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        bool n_withStat_3_opt(StatePtr curState, StateSet& nextStates, const Token& token) {
            a_withStat_6_L_COLON(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_withStat_3_opt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_withStat_3_opt);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_withStat_4_L_COMMA({state}, nextStates, curNode);
            }
        }
    
        // withStat = 'with' <entries:withStatEntry> [ _ ',' <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        bool n_withStat_4_L_COMMA(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            a_withStat_5_entries_withStatEntry(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_withStat_4_L_COMMA(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_withStat_4_L_COMMA];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // withStat = 'with' <entries:withStatEntry> [ ',' _ <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        bool n_withStat_5_entries_withStatEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["entries"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStat_5_entries_withStatEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_withStat_5_entries_withStatEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_withStatEntry({state}, nextStates, curNode);
            state->node->nodeLists["entries"].push_back(state->subNode);
            }
        }
    
        // withStat = 'with' <entries:withStatEntry> [ ',' <entries:withStatEntry> ] _ ':' <contextBodyClosedBlock>
        bool n_withStat_6_L_COLON(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            a_withStat_7_contextBodyClosedBlock(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_withStat_6_L_COLON(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_withStat_6_L_COLON];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // withStat = 'with' <entries:withStatEntry> [ ',' <entries:withStatEntry> ] ':' _ <contextBodyClosedBlock>
        bool n_withStat_7_contextBodyClosedBlock(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStat_7_contextBodyClosedBlock(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_withStat_7_contextBodyClosedBlock);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_contextBodyClosedBlock({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // withStatEntry
        bool n_withStatEntry(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStatEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_withStatEntry);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_withStatEntry>();
                for (auto par : parentStates) par->subNode = state->node;
                a_withStatEntry_1_id_identifier({state}, nextStates, curNode);
                a_withStatEntry_4_val_expression({state}, nextStates, curNode);
            }
        }
    
        // withStatEntry 	= _ <id:identifier> '=' <val:expression>
        bool n_withStatEntry_1_id_identifier(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["id"].push_back(curState->subNode);
            a_withStatEntry_2_L_CHANGE(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_withStatEntry_1_id_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_withStatEntry_1_id_identifier);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_identifier({state}, nextStates, curNode);
            state->node->nodeLists["id"].push_back(state->subNode);
            }
        }
    
        // withStatEntry 	= <id:identifier> _ '=' <val:expression>
        bool n_withStatEntry_2_L_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CHANGE)
                return false;
            a_withStatEntry_3_val_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_withStatEntry_2_L_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_withStatEntry_2_L_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // withStatEntry 	= <id:identifier> '=' _ <val:expression>
        bool n_withStatEntry_3_val_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStatEntry_3_val_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_withStatEntry_3_val_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // withStatEntry = _ <val:expression>
        bool n_withStatEntry_4_val_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["val"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStatEntry_4_val_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_withStatEntry_4_val_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["val"].push_back(state->subNode);
            }
        }
    
        // assignmentEqual
        bool n_assignmentEqual(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                for (auto par : parentStates) par->subNode = state->node;
                a_assignmentEqual_1_assignRef({state}, nextStates, curNode);
                a_assignmentEqual_2_changeVal({state}, nextStates, curNode);
                a_assignmentEqual_3_addChangeVal({state}, nextStates, curNode);
                a_assignmentEqual_4_subChangeVal({state}, nextStates, curNode);
                a_assignmentEqual_5_mulChangeVal({state}, nextStates, curNode);
                a_assignmentEqual_6_crossChangeVal({state}, nextStates, curNode);
                a_assignmentEqual_7_dotChangeVal({state}, nextStates, curNode);
                a_assignmentEqual_8_divChangeVal({state}, nextStates, curNode);
                a_assignmentEqual_9_intDivChangeVal({state}, nextStates, curNode);
                a_assignmentEqual_10_modChangeVal({state}, nextStates, curNode);
                a_assignmentEqual_11_shiftRChangeVal({state}, nextStates, curNode);
                a_assignmentEqual_12_shiftLChangeVal({state}, nextStates, curNode);
                a_assignmentEqual_13_andChangeVal({state}, nextStates, curNode);
                a_assignmentEqual_14_orChangeVal({state}, nextStates, curNode);
                a_assignmentEqual_15_xorChangeVal({state}, nextStates, curNode);
            }
        }
    
        // assignmentEqual = _ <assignRef>
        bool n_assignmentEqual_1_assignRef(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_1_assignRef(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_1_assignRef);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_assignRef({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <changeVal>
        bool n_assignmentEqual_2_changeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_2_changeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_2_changeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_changeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <addChangeVal>
        bool n_assignmentEqual_3_addChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_3_addChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_3_addChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_addChangeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <subChangeVal>
        bool n_assignmentEqual_4_subChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_4_subChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_4_subChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_subChangeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <mulChangeVal>
        bool n_assignmentEqual_5_mulChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_5_mulChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_5_mulChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_mulChangeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <crossChangeVal>
        bool n_assignmentEqual_6_crossChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_6_crossChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_6_crossChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_crossChangeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <dotChangeVal>
        bool n_assignmentEqual_7_dotChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_7_dotChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_7_dotChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_dotChangeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <divChangeVal>
        bool n_assignmentEqual_8_divChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_8_divChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_8_divChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_divChangeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <intDivChangeVal>
        bool n_assignmentEqual_9_intDivChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_9_intDivChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_9_intDivChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_intDivChangeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <modChangeVal>
        bool n_assignmentEqual_10_modChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_10_modChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_10_modChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_modChangeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <shiftRChangeVal>
        bool n_assignmentEqual_11_shiftRChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_11_shiftRChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_11_shiftRChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_shiftRChangeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <shiftLChangeVal>
        bool n_assignmentEqual_12_shiftLChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_12_shiftLChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_12_shiftLChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_shiftLChangeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <andChangeVal>
        bool n_assignmentEqual_13_andChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_13_andChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_13_andChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_andChangeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <orChangeVal>
        bool n_assignmentEqual_14_orChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_14_orChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_14_orChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_orChangeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignmentEqual = _ <xorChangeVal>
        bool n_assignmentEqual_15_xorChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual_15_xorChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual_15_xorChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_xorChangeVal({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignRef
        bool n_assignRef(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignRef(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignRef);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignRef>();
                for (auto par : parentStates) par->subNode = state->node;
                a_assignRef_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // assignRef = _ <left:expression> ( '->' <ONL> <rights:expression> )+
        bool n_assignRef_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_assignRef_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_assignRef_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignRef_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // assignRef = <left:expression> _ ( '->' <ONL> <rights:expression> )+
        bool n_assignRef_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_assignRef_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_assignRef_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignRef_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_assignRef_3_L_ASSIGN({state}, nextStates, curNode);
            }
        }
    
        // assignRef = <left:expression> ( _ '->' <ONL> <rights:expression> )+
        bool n_assignRef_3_L_ASSIGN(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_ASSIGN)
                return false;
            a_assignRef_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_assignRef_3_L_ASSIGN(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_assignRef_3_L_ASSIGN];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // assignRef = <left:expression> ( '->' _ <ONL> <rights:expression> )+
        bool n_assignRef_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_assignRef_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_assignRef_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignRef_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // assignRef = <left:expression> ( '->' <ONL> _ <rights:expression> )+
        bool n_assignRef_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignRef_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_assignRef_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // changeVal
        bool n_changeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_changeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_changeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_changeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_changeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // changeVal = _ <left:expression> ( '=' <ONL> <rights:expression> )+
        bool n_changeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_changeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_changeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_changeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // changeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        bool n_changeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_changeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_changeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_changeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_changeVal_3_L_CHANGE({state}, nextStates, curNode);
            }
        }
    
        // changeVal = <left:expression> ( _ '=' <ONL> <rights:expression> )+
        bool n_changeVal_3_L_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CHANGE)
                return false;
            a_changeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_changeVal_3_L_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_changeVal_3_L_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // changeVal = <left:expression> ( '=' _ <ONL> <rights:expression> )+
        bool n_changeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_changeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_changeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_changeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // changeVal = <left:expression> ( '=' <ONL> _ <rights:expression> )+
        bool n_changeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_changeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_changeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // addChangeVal
        bool n_addChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_addChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_addChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_addChangeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_addChangeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // addChangeVal = _ <left:expression> ( '+=' <ONL> <rights:expression> )+
        bool n_addChangeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_addChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_addChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_addChangeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // addChangeVal = <left:expression> _ ( '+=' <ONL> <rights:expression> )+
        bool n_addChangeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_addChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_addChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_addChangeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_addChangeVal_3_L_ADD_CHANGE({state}, nextStates, curNode);
            }
        }
    
        // addChangeVal = <left:expression> ( _ '+=' <ONL> <rights:expression> )+
        bool n_addChangeVal_3_L_ADD_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_ADD_CHANGE)
                return false;
            a_addChangeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_addChangeVal_3_L_ADD_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_addChangeVal_3_L_ADD_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // addChangeVal = <left:expression> ( '+=' _ <ONL> <rights:expression> )+
        bool n_addChangeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_addChangeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_addChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_addChangeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // addChangeVal = <left:expression> ( '+=' <ONL> _ <rights:expression> )+
        bool n_addChangeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_addChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_addChangeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // subChangeVal
        bool n_subChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_subChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_subChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_subChangeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_subChangeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // subChangeVal = _ <left:expression> ( '-=' <ONL> <rights:expression> )+
        bool n_subChangeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_subChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_subChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_subChangeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // subChangeVal = <left:expression> _ ( '-=' <ONL> <rights:expression> )+
        bool n_subChangeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_subChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_subChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_subChangeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_subChangeVal_3_L_SUB_CHANGE({state}, nextStates, curNode);
            }
        }
    
        // subChangeVal = <left:expression> ( _ '-=' <ONL> <rights:expression> )+
        bool n_subChangeVal_3_L_SUB_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SUB_CHANGE)
                return false;
            a_subChangeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_subChangeVal_3_L_SUB_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_subChangeVal_3_L_SUB_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // subChangeVal = <left:expression> ( '-=' _ <ONL> <rights:expression> )+
        bool n_subChangeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_subChangeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_subChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_subChangeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // subChangeVal = <left:expression> ( '-=' <ONL> _ <rights:expression> )+
        bool n_subChangeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_subChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_subChangeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // mulChangeVal
        bool n_mulChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_mulChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_mulChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_mulChangeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_mulChangeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // mulChangeVal = _ <left:expression> ( '*=' <ONL> <rights:expression> )+
        bool n_mulChangeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_mulChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_mulChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_mulChangeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // mulChangeVal = <left:expression> _ ( '*=' <ONL> <rights:expression> )+
        bool n_mulChangeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_mulChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_mulChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_mulChangeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_mulChangeVal_3_L_MUL_CHANGE({state}, nextStates, curNode);
            }
        }
    
        // mulChangeVal = <left:expression> ( _ '*=' <ONL> <rights:expression> )+
        bool n_mulChangeVal_3_L_MUL_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_MUL_CHANGE)
                return false;
            a_mulChangeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_mulChangeVal_3_L_MUL_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_mulChangeVal_3_L_MUL_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // mulChangeVal = <left:expression> ( '*=' _ <ONL> <rights:expression> )+
        bool n_mulChangeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_mulChangeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_mulChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_mulChangeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // mulChangeVal = <left:expression> ( '*=' <ONL> _ <rights:expression> )+
        bool n_mulChangeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_mulChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_mulChangeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // crossChangeVal
        bool n_crossChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_crossChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_crossChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_crossChangeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_crossChangeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // crossChangeVal = _ <left:expression> ( '×=' <ONL> <rights:expression> )+
        bool n_crossChangeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_crossChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_crossChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_crossChangeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // crossChangeVal = <left:expression> _ ( '×=' <ONL> <rights:expression> )+
        bool n_crossChangeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_crossChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_crossChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_crossChangeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_crossChangeVal_3_L_CROSS({state}, nextStates, curNode);
            }
        }
    
        // crossChangeVal = <left:expression> ( _ '×=' <ONL> <rights:expression> )+
        bool n_crossChangeVal_3_L_CROSS(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CROSS)
                return false;
            a_crossChangeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_crossChangeVal_3_L_CROSS(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_crossChangeVal_3_L_CROSS];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // crossChangeVal = <left:expression> ( '×=' _ <ONL> <rights:expression> )+
        bool n_crossChangeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_crossChangeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_crossChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_crossChangeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // crossChangeVal = <left:expression> ( '×=' <ONL> _ <rights:expression> )+
        bool n_crossChangeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_crossChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_crossChangeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // dotChangeVal
        bool n_dotChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dotChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dotChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dotChangeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_dotChangeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // dotChangeVal = _ <left:expression> ( '⋅=' <ONL> <rights:expression> )+
        bool n_dotChangeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_dotChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dotChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dotChangeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // dotChangeVal = <left:expression> _ ( '⋅=' <ONL> <rights:expression> )+
        bool n_dotChangeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_dotChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dotChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dotChangeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_dotChangeVal_3_L_DOT({state}, nextStates, curNode);
            }
        }
    
        // dotChangeVal = <left:expression> ( _ '⋅=' <ONL> <rights:expression> )+
        bool n_dotChangeVal_3_L_DOT(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_DOT)
                return false;
            a_dotChangeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dotChangeVal_3_L_DOT(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dotChangeVal_3_L_DOT];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dotChangeVal = <left:expression> ( '⋅=' _ <ONL> <rights:expression> )+
        bool n_dotChangeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_dotChangeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_dotChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dotChangeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // dotChangeVal = <left:expression> ( '⋅=' <ONL> _ <rights:expression> )+
        bool n_dotChangeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dotChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_dotChangeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // divChangeVal
        bool n_divChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_divChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_divChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_divChangeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_divChangeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // divChangeVal = _ <left:expression> ( '/=' <ONL> <rights:expression> )+
        bool n_divChangeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_divChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_divChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_divChangeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // divChangeVal = <left:expression> _ ( '/=' <ONL> <rights:expression> )+
        bool n_divChangeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_divChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_divChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_divChangeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_divChangeVal_3_L_DIV_CHANGE({state}, nextStates, curNode);
            }
        }
    
        // divChangeVal = <left:expression> ( _ '/=' <ONL> <rights:expression> )+
        bool n_divChangeVal_3_L_DIV_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_DIV_CHANGE)
                return false;
            a_divChangeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_divChangeVal_3_L_DIV_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_divChangeVal_3_L_DIV_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // divChangeVal = <left:expression> ( '/=' _ <ONL> <rights:expression> )+
        bool n_divChangeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_divChangeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_divChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_divChangeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // divChangeVal = <left:expression> ( '/=' <ONL> _ <rights:expression> )+
        bool n_divChangeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_divChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_divChangeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // intDivChangeVal
        bool n_intDivChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_intDivChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_intDivChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_intDivChangeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_intDivChangeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // intDivChangeVal = _ <left:expression> ( '/%=' <ONL> <rights:expression> )+
        bool n_intDivChangeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_intDivChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_intDivChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_intDivChangeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // intDivChangeVal = <left:expression> _ ( '/%=' <ONL> <rights:expression> )+
        bool n_intDivChangeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_intDivChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_intDivChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_intDivChangeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_intDivChangeVal_3_L_INT_DIV_CHANGE({state}, nextStates, curNode);
            }
        }
    
        // intDivChangeVal = <left:expression> ( _ '/%=' <ONL> <rights:expression> )+
        bool n_intDivChangeVal_3_L_INT_DIV_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_INT_DIV_CHANGE)
                return false;
            a_intDivChangeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_intDivChangeVal_3_L_INT_DIV_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_intDivChangeVal_3_L_INT_DIV_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // intDivChangeVal = <left:expression> ( '/%=' _ <ONL> <rights:expression> )+
        bool n_intDivChangeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_intDivChangeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_intDivChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_intDivChangeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // intDivChangeVal = <left:expression> ( '/%=' <ONL> _ <rights:expression> )+
        bool n_intDivChangeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_intDivChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_intDivChangeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // modChangeVal
        bool n_modChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_modChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_modChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_modChangeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_modChangeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // modChangeVal = _ <left:expression> ( '%=' <ONL> <rights:expression> )+
        bool n_modChangeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_modChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_modChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_modChangeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // modChangeVal = <left:expression> _ ( '%=' <ONL> <rights:expression> )+
        bool n_modChangeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_modChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_modChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_modChangeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_modChangeVal_3_L_MOD_CHANGE({state}, nextStates, curNode);
            }
        }
    
        // modChangeVal = <left:expression> ( _ '%=' <ONL> <rights:expression> )+
        bool n_modChangeVal_3_L_MOD_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_MOD_CHANGE)
                return false;
            a_modChangeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_modChangeVal_3_L_MOD_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_modChangeVal_3_L_MOD_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // modChangeVal = <left:expression> ( '%=' _ <ONL> <rights:expression> )+
        bool n_modChangeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_modChangeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_modChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_modChangeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // modChangeVal = <left:expression> ( '%=' <ONL> _ <rights:expression> )+
        bool n_modChangeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_modChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_modChangeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // shiftRChangeVal
        bool n_shiftRChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftRChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftRChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftRChangeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_shiftRChangeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // shiftRChangeVal = _ <left:expression> ( '>>=' <ONL> <rights:expression> )+
        bool n_shiftRChangeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_shiftRChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftRChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftRChangeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // shiftRChangeVal = <left:expression> _ ( '>>=' <ONL> <rights:expression> )+
        bool n_shiftRChangeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_shiftRChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftRChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftRChangeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_shiftRChangeVal_3_L_SHIFT_RIGHT_CHANGE({state}, nextStates, curNode);
            }
        }
    
        // shiftRChangeVal = <left:expression> ( _ '>>=' <ONL> <rights:expression> )+
        bool n_shiftRChangeVal_3_L_SHIFT_RIGHT_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SHIFT_RIGHT_CHANGE)
                return false;
            a_shiftRChangeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftRChangeVal_3_L_SHIFT_RIGHT_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_shiftRChangeVal_3_L_SHIFT_RIGHT_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // shiftRChangeVal = <left:expression> ( '>>=' _ <ONL> <rights:expression> )+
        bool n_shiftRChangeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_shiftRChangeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftRChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftRChangeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // shiftRChangeVal = <left:expression> ( '>>=' <ONL> _ <rights:expression> )+
        bool n_shiftRChangeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftRChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftRChangeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // shiftLChangeVal
        bool n_shiftLChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftLChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftLChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftLChangeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_shiftLChangeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // shiftLChangeVal = _ <left:expression> ( '<<=' <ONL> <rights:expression> )+
        bool n_shiftLChangeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_shiftLChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftLChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftLChangeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // shiftLChangeVal = <left:expression> _ ( '<<=' <ONL> <rights:expression> )+
        bool n_shiftLChangeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_shiftLChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftLChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftLChangeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_shiftLChangeVal_3_L_SHIFT_LEFT_CHANGE({state}, nextStates, curNode);
            }
        }
    
        // shiftLChangeVal = <left:expression> ( _ '<<=' <ONL> <rights:expression> )+
        bool n_shiftLChangeVal_3_L_SHIFT_LEFT_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SHIFT_LEFT_CHANGE)
                return false;
            a_shiftLChangeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftLChangeVal_3_L_SHIFT_LEFT_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_shiftLChangeVal_3_L_SHIFT_LEFT_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // shiftLChangeVal = <left:expression> ( '<<=' _ <ONL> <rights:expression> )+
        bool n_shiftLChangeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_shiftLChangeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_shiftLChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftLChangeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // shiftLChangeVal = <left:expression> ( '<<=' <ONL> _ <rights:expression> )+
        bool n_shiftLChangeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftLChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_shiftLChangeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // andChangeVal
        bool n_andChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_andChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_andChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_andChangeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_andChangeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // andChangeVal = _ <left:expression> ( '&=' <ONL> <rights:expression> )+
        bool n_andChangeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_andChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_andChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_andChangeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // andChangeVal = <left:expression> _ ( '&=' <ONL> <rights:expression> )+
        bool n_andChangeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_andChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_andChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_andChangeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_andChangeVal_3_L_AND_CHANGE({state}, nextStates, curNode);
            }
        }
    
        // andChangeVal = <left:expression> ( _ '&=' <ONL> <rights:expression> )+
        bool n_andChangeVal_3_L_AND_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_AND_CHANGE)
                return false;
            a_andChangeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_andChangeVal_3_L_AND_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_andChangeVal_3_L_AND_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // andChangeVal = <left:expression> ( '&=' _ <ONL> <rights:expression> )+
        bool n_andChangeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_andChangeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_andChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_andChangeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // andChangeVal = <left:expression> ( '&=' <ONL> _ <rights:expression> )+
        bool n_andChangeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_andChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_andChangeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // orChangeVal
        bool n_orChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_orChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_orChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_orChangeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_orChangeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // orChangeVal = _ <left:expression> ( '|=' <ONL> <rights:expression> )+
        bool n_orChangeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_orChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_orChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_orChangeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // orChangeVal = <left:expression> _ ( '|=' <ONL> <rights:expression> )+
        bool n_orChangeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_orChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_orChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_orChangeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_orChangeVal_3_L_OR_CHANGE({state}, nextStates, curNode);
            }
        }
    
        // orChangeVal = <left:expression> ( _ '|=' <ONL> <rights:expression> )+
        bool n_orChangeVal_3_L_OR_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_OR_CHANGE)
                return false;
            a_orChangeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_orChangeVal_3_L_OR_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_orChangeVal_3_L_OR_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // orChangeVal = <left:expression> ( '|=' _ <ONL> <rights:expression> )+
        bool n_orChangeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_orChangeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_orChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_orChangeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // orChangeVal = <left:expression> ( '|=' <ONL> _ <rights:expression> )+
        bool n_orChangeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_orChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_orChangeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    
        // xorChangeVal
        bool n_xorChangeVal(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_xorChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_xorChangeVal);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_xorChangeVal>();
                for (auto par : parentStates) par->subNode = state->node;
                a_xorChangeVal_1_left_expression({state}, nextStates, curNode);
            }
        }
    
        // xorChangeVal = _ <left:expression> ( '^=' <ONL> <rights:expression> )+
        bool n_xorChangeVal_1_left_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["left"].push_back(curState->subNode);
            a_xorChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_xorChangeVal_1_left_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_xorChangeVal_1_left_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["left"].push_back(state->subNode);
            }
        }
    
        // xorChangeVal = <left:expression> _ ( '^=' <ONL> <rights:expression> )+
        bool n_xorChangeVal_2_sub(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            a_xorChangeVal_2_sub(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_xorChangeVal_2_sub(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_xorChangeVal_2_sub);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_xorChangeVal_3_L_XOR_CHANGE({state}, nextStates, curNode);
            }
        }
    
        // xorChangeVal = <left:expression> ( _ '^=' <ONL> <rights:expression> )+
        bool n_xorChangeVal_3_L_XOR_CHANGE(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_XOR_CHANGE)
                return false;
            a_xorChangeVal_4_ONL(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_xorChangeVal_3_L_XOR_CHANGE(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_xorChangeVal_3_L_XOR_CHANGE];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // xorChangeVal = <left:expression> ( '^=' _ <ONL> <rights:expression> )+
        bool n_xorChangeVal_4_ONL(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists[""].push_back(curState->subNode);
            a_xorChangeVal_5_rights_expression(curState->parentStates, nextStates, curState->node);
            return true;
        }
        void a_xorChangeVal_4_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_xorChangeVal_4_ONL);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_ONL({state}, nextStates, curNode);
            state->node->nodeLists[""].push_back(state->subNode);
            }
        }
    
        // xorChangeVal = <left:expression> ( '^=' <ONL> _ <rights:expression> )+
        bool n_xorChangeVal_5_rights_expression(StatePtr curState, StateSet& nextStates, const Token& token) {
            curState->node->nodeLists["rights"].push_back(curState->subNode);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_xorChangeVal_5_rights_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates.getHidden(&n_xorChangeVal_5_rights_expression);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
                a_expression({state}, nextStates, curNode);
            state->node->nodeLists["rights"].push_back(state->subNode);
            }
        }
    }
    
    ParseNode::~ParseNode() {
    };
    void ParseNode::process() {
    };
    
    void ParseNode::pullFrom(ParseNode& other) {
        for (auto& varNodesPair : other.nodeLists) {
            const std::string &varName = varNodesPair.first;
            auto &otherList = varNodesPair.second;
            auto &myList = nodeLists[varName];
            myList.splice(otherList.begin(), otherList);
        }
        for (auto& varTokensPair : other.tokenLists) {
            const std::string &varName = varTokensPair.first;
            auto &otherList = varTokensPair.second;
            auto &myList = tokenLists[varName];
            otherList.splice(myList.begin(), myList);
        }
    };
    
    ParseNode_file::~ParseNode_file() {}
    ParseNode_ONL::~ParseNode_ONL() {}
    ParseNode_contextBody::~ParseNode_contextBody() {}
    ParseNode_contextBodyClosedBlock::~ParseNode_contextBodyClosedBlock() {}
    ParseNode_contextDescriptionEntry::~ParseNode_contextDescriptionEntry() {}
    ParseNode_traitAssertion::~ParseNode_traitAssertion() {}
    ParseNode_expression::~ParseNode_expression() {}
    ParseNode_expr0::~ParseNode_expr0() {}
    ParseNode_identifier::~ParseNode_identifier() {}
    ParseNode_suffixFunction::~ParseNode_suffixFunction() {}
    ParseNode_expr1::~ParseNode_expr1() {}
    ParseNode_suffixInc::~ParseNode_suffixInc() {}
    ParseNode_suffixDec::~ParseNode_suffixDec() {}
    ParseNode_copy::~ParseNode_copy() {}
    ParseNode_prefixFunction::~ParseNode_prefixFunction() {}
    ParseNode_expr2::~ParseNode_expr2() {}
    ParseNode_prefixInc::~ParseNode_prefixInc() {}
    ParseNode_prefixDec::~ParseNode_prefixDec() {}
    ParseNode_plus::~ParseNode_plus() {}
    ParseNode_minus::~ParseNode_minus() {}
    ParseNode_logNot::~ParseNode_logNot() {}
    ParseNode_expr3::~ParseNode_expr3() {}
    ParseNode_multiplication::~ParseNode_multiplication() {}
    ParseNode_crossProduct::~ParseNode_crossProduct() {}
    ParseNode_dotProduct::~ParseNode_dotProduct() {}
    ParseNode_division::~ParseNode_division() {}
    ParseNode_divisionInt::~ParseNode_divisionInt() {}
    ParseNode_modulo::~ParseNode_modulo() {}
    ParseNode_expr4::~ParseNode_expr4() {}
    ParseNode_addition::~ParseNode_addition() {}
    ParseNode_subtraction::~ParseNode_subtraction() {}
    ParseNode_expr5::~ParseNode_expr5() {}
    ParseNode_shiftL::~ParseNode_shiftL() {}
    ParseNode_shiftR::~ParseNode_shiftR() {}
    ParseNode_expr6::~ParseNode_expr6() {}
    ParseNode_compLess::~ParseNode_compLess() {}
    ParseNode_compGreat::~ParseNode_compGreat() {}
    ParseNode_compLeEq::~ParseNode_compLeEq() {}
    ParseNode_compGrEq::~ParseNode_compGrEq() {}
    ParseNode_expr7::~ParseNode_expr7() {}
    ParseNode_compEqual::~ParseNode_compEqual() {}
    ParseNode_compNotEq::~ParseNode_compNotEq() {}
    ParseNode_compAssigned::~ParseNode_compAssigned() {}
    ParseNode_compNotAss::~ParseNode_compNotAss() {}
    ParseNode_expr8::~ParseNode_expr8() {}
    ParseNode_logAnd::~ParseNode_logAnd() {}
    ParseNode_expr9::~ParseNode_expr9() {}
    ParseNode_logXOr::~ParseNode_logXOr() {}
    ParseNode_expr10::~ParseNode_expr10() {}
    ParseNode_logOr::~ParseNode_logOr() {}
    ParseNode_exprLeast::~ParseNode_exprLeast() {}
    ParseNode_literal::~ParseNode_literal() {}
    ParseNode_valueLiteral::~ParseNode_valueLiteral() {}
    ParseNode_listLiteral::~ParseNode_listLiteral() {}
    ParseNode_setLiteral::~ParseNode_setLiteral() {}
    ParseNode_dictLiteral::~ParseNode_dictLiteral() {}
    ParseNode_dictEntry::~ParseNode_dictEntry() {}
    ParseNode_contextLiteral::~ParseNode_contextLiteral() {}
    ParseNode_memberDecl::~ParseNode_memberDecl() {}
    ParseNode_statement::~ParseNode_statement() {}
    ParseNode_definition::~ParseNode_definition() {}
    ParseNode_varDeclaration::~ParseNode_varDeclaration() {}
    ParseNode_refDeclaration::~ParseNode_refDeclaration() {}
    ParseNode_varRefDeclBody::~ParseNode_varRefDeclBody() {}
    ParseNode_varRefDeclEntry::~ParseNode_varRefDeclEntry() {}
    ParseNode_varRefDeclEntryEqual::~ParseNode_varRefDeclEntryEqual() {}
    ParseNode_varRefDeclEntryAssign::~ParseNode_varRefDeclEntryAssign() {}
    ParseNode_ifStat::~ParseNode_ifStat() {}
    ParseNode_elseStatPart::~ParseNode_elseStatPart() {}
    ParseNode_loopStat::~ParseNode_loopStat() {}
    ParseNode_loopStatPart::~ParseNode_loopStatPart() {}
    ParseNode_timesLoopStatPart::~ParseNode_timesLoopStatPart() {}
    ParseNode_forLoopStatPart::~ParseNode_forLoopStatPart() {}
    ParseNode_whileLoopStatPart::~ParseNode_whileLoopStatPart() {}
    ParseNode_jumpStat::~ParseNode_jumpStat() {}
    ParseNode_breakStat::~ParseNode_breakStat() {}
    ParseNode_continueStat::~ParseNode_continueStat() {}
    ParseNode_returnStat::~ParseNode_returnStat() {}
    ParseNode_withStat::~ParseNode_withStat() {}
    ParseNode_withStatEntry::~ParseNode_withStatEntry() {}
    ParseNode_assignmentEqual::~ParseNode_assignmentEqual() {}
    ParseNode_assignRef::~ParseNode_assignRef() {}
    ParseNode_changeVal::~ParseNode_changeVal() {}
    ParseNode_addChangeVal::~ParseNode_addChangeVal() {}
    ParseNode_subChangeVal::~ParseNode_subChangeVal() {}
    ParseNode_mulChangeVal::~ParseNode_mulChangeVal() {}
    ParseNode_crossChangeVal::~ParseNode_crossChangeVal() {}
    ParseNode_dotChangeVal::~ParseNode_dotChangeVal() {}
    ParseNode_divChangeVal::~ParseNode_divChangeVal() {}
    ParseNode_intDivChangeVal::~ParseNode_intDivChangeVal() {}
    ParseNode_modChangeVal::~ParseNode_modChangeVal() {}
    ParseNode_shiftRChangeVal::~ParseNode_shiftRChangeVal() {}
    ParseNode_shiftLChangeVal::~ParseNode_shiftLChangeVal() {}
    ParseNode_andChangeVal::~ParseNode_andChangeVal() {}
    ParseNode_orChangeVal::~ParseNode_orChangeVal() {}
    ParseNode_xorChangeVal::~ParseNode_xorChangeVal() {}

    ParseNodePtr parse(const std::list<Token> &input, std::list<ParserError>& outErrors)
    {
        ParseNodePtr res;
        return res;
    }

}
