// This file is autogenerated. Do not edit!

#include "chakralParser.h"
#include <iostream>

namespace ChakraL
{

    namespace
    {
        
        void a_file(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_file__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_file_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ONL__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ONL_1__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ONL_1__cont(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ONL_1__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ONL_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_1__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_1__cont(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_1__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_1__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBody_1__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBodyClosedBlock(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBodyClosedBlock__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBodyClosedBlock_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBodyClosedBlock__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBodyClosedBlock_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBodyClosedBlock_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBodyClosedBlock_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextDescriptionEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextDescriptionEntry__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextDescriptionEntry_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextDescriptionEntry_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextDescriptionEntry__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextDescriptionEntry_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextDescriptionEntry_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_traitAssertion(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_traitAssertion__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_traitAssertion_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_traitAssertion_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expression__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expression_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr0__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr0_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr0_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr0_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_identifier__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_identifier_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
    
        // file
        void a_file(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_file__poss1(parentStates, nextStates, outputVar);
        }
    
        // file
        bool n_file__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_file__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_file__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_file>();
                a_file_1({state}, nextStates, state->node);
            }
        }
    
        // file = _ <:contextBody>
        void a_file_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextBody(parentStates, nextStates, &(curNode->nodeLists[":"].emplace_back(nullptr)));
        }
    
        // ONL
        void a_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_ONL__poss1(parentStates, nextStates, outputVar);
        }
    
        // ONL
        bool n_ONL__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ONL__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_ONL__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ONL>();
                a_ONL_1__repeat({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // ONL = _ '\n'*
        void a_ONL_1__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_ONL_1__cont(parentStates, nextStates, outputVar);
            a_ONL_1__cycle(parentStates, nextStates, outputVar);
        }
    
        // ONL = _ '\n'*
        bool n_ONL_1__cont(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ONL_1__cont(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_ONL_1__cont];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ONL>();
            }
        }
    
        // ONL = _ '\n'*
        bool n_ONL_1__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ONL_1__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_ONL_1__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ONL>();
                a_ONL_1({state}, nextStates, state->node);
            }
        }
    
        // ONL = _ '\n'*
        bool n_ONL_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ONL_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ONL_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextBody
        void a_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextBody__poss1(parentStates, nextStates, outputVar);
        }
    
        // contextBody
        bool n_contextBody__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextBody__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBody>();
                a_contextBody_1__repeat({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // contextBody = _ ( <descs:contextDescriptionEntry> | '\n')*
        void a_contextBody_1__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextBody_1__cont(parentStates, nextStates, outputVar);
            a_contextBody_1__cycle(parentStates, nextStates, outputVar);
        }
    
        // contextBody = _ ( <descs:contextDescriptionEntry> | '\n')*
        bool n_contextBody_1__cont(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody_1__cont(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_contextBody_1__cont];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBody>();
            }
        }
    
        // contextBody = _ ( <descs:contextDescriptionEntry> | '\n')*
        bool n_contextBody_1__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody_1__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextBody_1__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBody>();
                a_contextBody_1({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // contextBody = _ ( <descs:contextDescriptionEntry> | '\n')*
        void a_contextBody_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextBody_1__poss1(parentStates, nextStates, outputVar);
            a_contextBody_1__poss2(parentStates, nextStates, outputVar);
        }
    
        // contextBody = _ ( <descs:contextDescriptionEntry> | '\n')*
        bool n_contextBody_1__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody_1__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextBody_1__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBody>();
                a_contextBody_2({state}, nextStates, state->node);
            }
        }
    
        // contextBody = ( _ <descs:contextDescriptionEntry> | '\n')*
        void a_contextBody_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextDescriptionEntry(parentStates, nextStates, &(curNode->nodeLists["descs"].emplace_back(nullptr)));
        }
    
        // contextBody = _ ( <descs:contextDescriptionEntry> | '\n')*
        bool n_contextBody_1__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody_1__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextBody_1__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBody>();
                a_contextBody_3({state}, nextStates, state->node);
            }
        }
    
        // contextBody = ( <descs:contextDescriptionEntry> | _ '\n')*
        bool n_contextBody_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextBody_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextBodyClosedBlock
        void a_contextBodyClosedBlock(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextBodyClosedBlock__poss1(parentStates, nextStates, outputVar);
            a_contextBodyClosedBlock__poss2(parentStates, nextStates, outputVar);
        }
    
        // contextBodyClosedBlock
        bool n_contextBodyClosedBlock__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBodyClosedBlock__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextBodyClosedBlock__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBodyClosedBlock>();
                a_contextBodyClosedBlock_1({state}, nextStates, state->node);
            }
        }
    
        // contextBodyClosedBlock 	= _ <descs:contextDescriptionEntry>
        void a_contextBodyClosedBlock_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextDescriptionEntry(parentStates, nextStates, &(curNode->nodeLists["descs"].emplace_back(nullptr)));
        }
    
        // contextBodyClosedBlock
        bool n_contextBodyClosedBlock__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBodyClosedBlock__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextBodyClosedBlock__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBodyClosedBlock>();
                a_contextBodyClosedBlock_2({state}, nextStates, state->node);
            }
        }
    
        // contextBodyClosedBlock = '\n' <:contextBody> _ 'ok'
        bool n_contextBodyClosedBlock_4(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBodyClosedBlock_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextBodyClosedBlock_4];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextBodyClosedBlock = '\n' _ <:contextBody> 'ok'
        void a_contextBodyClosedBlock_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextBody(parentStates, nextStates, &(curNode->nodeLists[":"].emplace_back(nullptr)));
        }
    
        // contextBodyClosedBlock = _ '\n' <:contextBody> 'ok'
        bool n_contextBodyClosedBlock_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBodyClosedBlock_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextBodyClosedBlock_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextDescriptionEntry
        void a_contextDescriptionEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextDescriptionEntry__poss1(parentStates, nextStates, outputVar);
            a_contextDescriptionEntry__poss2(parentStates, nextStates, outputVar);
        }
    
        // contextDescriptionEntry
        bool n_contextDescriptionEntry__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextDescriptionEntry__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextDescriptionEntry__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextDescriptionEntry>();
                a_contextDescriptionEntry_1({state}, nextStates, state->node);
            }
        }
    
        // contextDescriptionEntry = <statement> _ '\n'
        bool n_contextDescriptionEntry_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextDescriptionEntry_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextDescriptionEntry_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextDescriptionEntry = _ <statement> '\n'
        void a_contextDescriptionEntry_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
