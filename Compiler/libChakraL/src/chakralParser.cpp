// This file is autogenerated. Do not edit!

#include "chakralParser.h"
#include <iostream>

namespace ChakraL
{

    namespace
    {
        
        void a_file(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_file__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_file_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ONL__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ONL_1__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ONL_1__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ONL_1__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ONL_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_1__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_1__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_1__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_1__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBody_1__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBody_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBodyClosedBlock(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBodyClosedBlock__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBodyClosedBlock_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBodyClosedBlock__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextBodyClosedBlock_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBodyClosedBlock_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextBodyClosedBlock_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextDescriptionEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextDescriptionEntry__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextDescriptionEntry_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextDescriptionEntry_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextDescriptionEntry__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextDescriptionEntry_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextDescriptionEntry_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_traitAssertion(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_traitAssertion__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_traitAssertion_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_traitAssertion_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expression__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expression_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr0__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr0_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr0_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr0__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr0_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_identifier__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_identifier_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixFunction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_suffixFunction__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_suffixFunction_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixFunction_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixFunction_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixFunction_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr1__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr1_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr1__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr1_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixInc(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_suffixInc__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_suffixInc_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixInc_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixDec(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_suffixDec__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_suffixDec_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_suffixDec_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_copy(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_copy__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_copy_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_copy_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_copy_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixFunction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_prefixFunction__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_prefixFunction_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixFunction_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr2_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr2__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr2_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr2__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr2_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr2__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr2_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr2__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr2_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixInc(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_prefixInc__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_prefixInc_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixInc_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixInc_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixDec(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_prefixDec__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_prefixDec_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixDec_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_prefixDec_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_plus(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_plus__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_plus_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_plus_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_plus_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_minus(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_minus__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_minus_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_minus_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_minus_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logNot(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_logNot__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_logNot_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logNot_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logNot_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr3__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr3_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr3__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr3_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr3__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr3_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr3__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr3_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr3__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr3_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr3__poss6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr3_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_multiplication(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_multiplication__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_multiplication_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_multiplication_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_multiplication_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_multiplication_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossProduct(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_crossProduct__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_crossProduct_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossProduct_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossProduct_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossProduct_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotProduct(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dotProduct__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dotProduct_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotProduct_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotProduct_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotProduct_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_division(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_division__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_division_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_division_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_division_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_division_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divisionInt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_divisionInt__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_divisionInt_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divisionInt_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divisionInt_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divisionInt_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modulo(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_modulo__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_modulo_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modulo_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modulo_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modulo_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr4__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr4_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr4_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr4_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr4_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr4_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4__poss6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr4_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr4__poss7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr4_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addition(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_addition__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_addition_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addition_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addition_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addition_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subtraction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_subtraction__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_subtraction_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subtraction_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subtraction_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subtraction_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr5__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr5_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr5__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr5_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr5__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr5_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftL__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftL_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftL_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftL_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftL_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftR__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftR_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftR_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftR_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftR_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr6__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr6_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr6__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr6_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr6__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr6_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLess(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compLess__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compLess_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLess_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLess_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLess_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGreat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compGreat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compGreat_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGreat_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGreat_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGreat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLeEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compLeEq__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compLeEq_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLeEq_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLeEq_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compLeEq_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGrEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compGrEq__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compGrEq_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGrEq_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGrEq_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compGrEq_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr7__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr7_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr7__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr7_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr7__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr7_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr7__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr7_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr7__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr7_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compEqual__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compEqual_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compEqual_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compEqual_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compEqual_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compNotEq__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compNotEq_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotEq_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotEq_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotEq_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compAssigned(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compAssigned__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compAssigned_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compAssigned_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compAssigned_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compAssigned_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotAss(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compNotAss__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_compNotAss_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotAss_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotAss_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_compNotAss_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr8__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr8_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr8__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr8_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr8__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr8_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr8__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr8_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr8__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr8_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logAnd(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_logAnd__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_logAnd_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logAnd_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logAnd_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logAnd_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr9__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr9_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr9__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr9_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logXOr(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_logXOr__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_logXOr_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logXOr_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logXOr_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logXOr_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr10__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr10_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_expr10__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_expr10_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logOr(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_logOr__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_logOr_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logOr_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logOr_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_logOr_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_exprLeast(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_exprLeast__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_exprLeast_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_exprLeast__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_exprLeast_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_literal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_literal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_literal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_literal__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_literal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_literal__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_literal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_literal__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_literal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_literal__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_literal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_2__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_2__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_5__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_5__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_5__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_5__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_8__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_8__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_8__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_8__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_11__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_11__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_11__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_11__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_14__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_14__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_14__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_14__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_valueLiteral_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_valueLiteral_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_listLiteral__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_listLiteral_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_3__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_listLiteral_3__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_listLiteral_3__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_listLiteral_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_listLiteral_3__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_listLiteral_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_listLiteral_16(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_11__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_listLiteral_11__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_listLiteral_11__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_listLiteral_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_listLiteral_11__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_listLiteral_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_listLiteral_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_setLiteral__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_setLiteral_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_3__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_setLiteral_3__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_setLiteral_3__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_setLiteral_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_setLiteral_3__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_setLiteral_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_setLiteral_16(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_11__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_setLiteral_11__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_setLiteral_11__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_setLiteral_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_setLiteral_11__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_setLiteral_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_setLiteral_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictLiteral__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictLiteral_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_4__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictLiteral_4__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictLiteral_4__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictLiteral_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictLiteral_4__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictLiteral_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictLiteral_18(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_17(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_13__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictLiteral_13__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictLiteral_13__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictLiteral_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictLiteral_13__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictLiteral_16(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictLiteral_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictEntry__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dictEntry_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictEntry_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictEntry_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dictEntry_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextLiteral__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextLiteral_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_3__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextLiteral_3__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextLiteral_3__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextLiteral_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextLiteral_3__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextLiteral_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextLiteral_16(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_10__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextLiteral_10__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextLiteral_10__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextLiteral_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextLiteral_10__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_contextLiteral_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_contextLiteral_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_memberDecl(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_memberDecl__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_memberDecl_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_memberDecl_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_memberDecl_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_statement__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_statement_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_statement_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_statement_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_statement_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_statement_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement__poss6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_statement_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement__poss7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_statement_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_statement__poss8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_statement_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_definition__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_definition_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_3__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_definition_3__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_definition_3__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_definition_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_definition_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_definition_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varDeclaration(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varDeclaration__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varDeclaration_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varDeclaration_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_refDeclaration(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_refDeclaration__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_refDeclaration_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_refDeclaration_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclBody__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclBody_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclBody_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclBody_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclBody_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclBody_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclBody_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclBody_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclBody_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclBody_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclEntry__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclEntry_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntry__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclEntry_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclEntryEqual__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclEntryEqual_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryEqual_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryEqual_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryEqual_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryAssign(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclEntryAssign__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_varRefDeclEntryAssign_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryAssign_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryAssign_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_varRefDeclEntryAssign_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ifStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ifStat_5__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ifStat_5__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ifStat_5__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ifStat_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ifStat_5__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ifStat_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ifStat_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_12__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ifStat_12__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ifStat_12__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ifStat_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ifStat_12__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_ifStat_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_ifStat_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_12__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_12__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_12__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_12__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_21(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_19__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_19__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_19__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_19(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_19__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_elseStatPart_20(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_18(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_17(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_16(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_elseStatPart_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_loopStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_loopStat_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat_3__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_loopStat_3__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_loopStat_3__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_loopStat_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_loopStat_3__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_loopStat_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_loopStatPart__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_loopStatPart_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStatPart__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_loopStatPart_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_loopStatPart__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_loopStatPart_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_timesLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_timesLoopStatPart__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_timesLoopStatPart_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_timesLoopStatPart_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_forLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_forLoopStatPart__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_forLoopStatPart_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_forLoopStatPart_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_forLoopStatPart_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_forLoopStatPart_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_whileLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_whileLoopStatPart__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_whileLoopStatPart_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_whileLoopStatPart_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_jumpStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_jumpStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_jumpStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_jumpStat__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_jumpStat_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_jumpStat__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_jumpStat_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_breakStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_breakStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_breakStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_continueStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_continueStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_continueStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_returnStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_returnStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_returnStat_2__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_returnStat_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_returnStat_2__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_returnStat_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_returnStat_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_returnStat_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_returnStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_withStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_withStat_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat_3__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_withStat_3__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_withStat_3__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_withStat_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_withStat_3__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_withStat_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStatEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_withStatEntry__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_withStatEntry_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStatEntry_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStatEntry_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_withStatEntry__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_withStatEntry_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignmentEqual__poss15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignmentEqual_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignRef(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignRef__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignRef_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignRef_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignRef_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignRef_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignRef_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_assignRef_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignRef_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignRef_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_assignRef_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_changeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_changeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_changeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_changeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_changeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_changeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_changeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_changeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_changeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_changeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_changeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_addChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_addChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_addChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_addChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_addChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_addChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_addChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_addChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_subChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_subChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_subChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_subChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_subChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_subChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_subChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_subChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_mulChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_mulChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_mulChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_mulChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_mulChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_mulChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_mulChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_mulChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_mulChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_mulChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_mulChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_crossChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_crossChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_crossChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_crossChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_crossChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_crossChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_crossChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_crossChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dotChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dotChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dotChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dotChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dotChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dotChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_dotChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_dotChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_divChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_divChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_divChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_divChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_divChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_divChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_divChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_divChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_intDivChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_intDivChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_intDivChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_intDivChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_intDivChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_intDivChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_intDivChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_intDivChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_intDivChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_intDivChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_intDivChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_modChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_modChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_modChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_modChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_modChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_modChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_modChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_modChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftRChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftRChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftRChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftRChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftRChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftRChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftRChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftRChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftRChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftRChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftRChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftLChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftLChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftLChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftLChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftLChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftLChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftLChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_shiftLChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftLChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftLChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_shiftLChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_andChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_andChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_andChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_andChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_andChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_andChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_andChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_andChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_andChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_andChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_andChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_orChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_orChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_orChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_orChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_orChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_orChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_orChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_orChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_orChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_orChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_orChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_xorChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_xorChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_xorChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_xorChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_xorChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_xorChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_xorChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar);
        void a_xorChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_xorChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_xorChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
        void a_xorChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode);
    
        // file
        void a_file(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_file__poss1(parentStates, nextStates, outputVar);
        }
    
        // file
        bool n_file__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_file__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_file__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_file>();
                a_file_1({state}, nextStates, state->node);
            }
        }
    
        // file = _ <:contextBody>
        void a_file_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextBody(parentStates, nextStates, &(curNode->nodeLists[":"].emplace_back(nullptr)));
        }
    
        // ONL
        void a_ONL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_ONL__poss1(parentStates, nextStates, outputVar);
        }
    
        // ONL
        bool n_ONL__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ONL__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_ONL__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ONL>();
                a_ONL_1__repeat({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // ONL = _ '\n'*
        void a_ONL_1__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_ONL_1__skip(parentStates, nextStates, outputVar);
            a_ONL_1__cycle(parentStates, nextStates, outputVar);
        }
    
        // ONL = _ '\n'*
        bool n_ONL_1__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ONL_1__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_ONL_1__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ONL>();
            }
        }
    
        // ONL = _ '\n'*
        bool n_ONL_1__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ONL_1__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_ONL_1__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ONL>();
                a_ONL_1({state}, nextStates, state->node);
            }
        }
    
        // ONL = _ '\n'*
        bool n_ONL_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ONL_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ONL_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextBody
        void a_contextBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextBody__poss1(parentStates, nextStates, outputVar);
        }
    
        // contextBody
        bool n_contextBody__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextBody__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBody>();
                a_contextBody_1__repeat({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // contextBody = _ ( <descs:contextDescriptionEntry> | '\n')*
        void a_contextBody_1__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextBody_1__skip(parentStates, nextStates, outputVar);
            a_contextBody_1__cycle(parentStates, nextStates, outputVar);
        }
    
        // contextBody = _ ( <descs:contextDescriptionEntry> | '\n')*
        bool n_contextBody_1__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody_1__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_contextBody_1__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBody>();
            }
        }
    
        // contextBody = _ ( <descs:contextDescriptionEntry> | '\n')*
        bool n_contextBody_1__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody_1__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextBody_1__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBody>();
                a_contextBody_1({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // contextBody = _ ( <descs:contextDescriptionEntry> | '\n')*
        void a_contextBody_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextBody_1__poss1(parentStates, nextStates, outputVar);
            a_contextBody_1__poss2(parentStates, nextStates, outputVar);
        }
    
        // contextBody = _ ( <descs:contextDescriptionEntry> | '\n')*
        bool n_contextBody_1__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody_1__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextBody_1__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBody>();
                a_contextBody_2({state}, nextStates, state->node);
            }
        }
    
        // contextBody = ( _ <descs:contextDescriptionEntry> | '\n')*
        void a_contextBody_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextDescriptionEntry(parentStates, nextStates, &(curNode->nodeLists["descs"].emplace_back(nullptr)));
        }
    
        // contextBody = _ ( <descs:contextDescriptionEntry> | '\n')*
        bool n_contextBody_1__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody_1__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextBody_1__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBody>();
                a_contextBody_3({state}, nextStates, state->node);
            }
        }
    
        // contextBody = ( <descs:contextDescriptionEntry> | _ '\n')*
        bool n_contextBody_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBody_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextBody_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextBodyClosedBlock
        void a_contextBodyClosedBlock(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextBodyClosedBlock__poss1(parentStates, nextStates, outputVar);
            a_contextBodyClosedBlock__poss2(parentStates, nextStates, outputVar);
        }
    
        // contextBodyClosedBlock
        bool n_contextBodyClosedBlock__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBodyClosedBlock__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextBodyClosedBlock__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBodyClosedBlock>();
                a_contextBodyClosedBlock_1({state}, nextStates, state->node);
            }
        }
    
        // contextBodyClosedBlock 	= _ <descs:contextDescriptionEntry>
        void a_contextBodyClosedBlock_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextDescriptionEntry(parentStates, nextStates, &(curNode->nodeLists["descs"].emplace_back(nullptr)));
        }
    
        // contextBodyClosedBlock
        bool n_contextBodyClosedBlock__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBodyClosedBlock__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextBodyClosedBlock__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextBodyClosedBlock>();
                a_contextBodyClosedBlock_2({state}, nextStates, state->node);
            }
        }
    
        // contextBodyClosedBlock = '\n' <:contextBody> _ 'ok'
        bool n_contextBodyClosedBlock_4(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBodyClosedBlock_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextBodyClosedBlock_4];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextBodyClosedBlock = '\n' _ <:contextBody> 'ok'
        void a_contextBodyClosedBlock_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextBody(parentStates, nextStates, &(curNode->nodeLists[":"].emplace_back(nullptr)));
        }
    
        // contextBodyClosedBlock = _ '\n' <:contextBody> 'ok'
        bool n_contextBodyClosedBlock_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextBodyClosedBlock_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextBodyClosedBlock_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextDescriptionEntry
        void a_contextDescriptionEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextDescriptionEntry__poss1(parentStates, nextStates, outputVar);
            a_contextDescriptionEntry__poss2(parentStates, nextStates, outputVar);
        }
    
        // contextDescriptionEntry
        bool n_contextDescriptionEntry__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextDescriptionEntry__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextDescriptionEntry__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextDescriptionEntry>();
                a_contextDescriptionEntry_1({state}, nextStates, state->node);
            }
        }
    
        // contextDescriptionEntry = <statement> _ '\n'
        bool n_contextDescriptionEntry_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextDescriptionEntry_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextDescriptionEntry_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextDescriptionEntry = _ <statement> '\n'
        void a_contextDescriptionEntry_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_statement(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // contextDescriptionEntry
        bool n_contextDescriptionEntry__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextDescriptionEntry__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextDescriptionEntry__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextDescriptionEntry>();
                a_contextDescriptionEntry_3({state}, nextStates, state->node);
            }
        }
    
        // contextDescriptionEntry = <traitAssertion> _ '\n'
        bool n_contextDescriptionEntry_4(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextDescriptionEntry_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextDescriptionEntry_4];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextDescriptionEntry = _ <traitAssertion> '\n'
        void a_contextDescriptionEntry_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_traitAssertion(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // traitAssertion
        void a_traitAssertion(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_traitAssertion__poss1(parentStates, nextStates, outputVar);
        }
    
        // traitAssertion
        bool n_traitAssertion__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_traitAssertion__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_traitAssertion__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_traitAssertion>();
                a_traitAssertion_1({state}, nextStates, state->node);
            }
        }
    
        // traitAssertion = '??' _ <cond:expression>
        void a_traitAssertion_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["cond"].emplace_back(nullptr)));
        }
    
        // traitAssertion = _ '??' <cond:expression>
        bool n_traitAssertion_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_TRAIT_COND)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_traitAssertion_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_traitAssertion_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // expression
        void a_expression(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_expression__poss1(parentStates, nextStates, outputVar);
        }
    
        // expression
        bool n_expression__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expression__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expression__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expression>();
                a_expression_1({state}, nextStates, state->node);
            }
        }
    
        // expression = _ <exprLeast>
        void a_expression_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_exprLeast(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr0
        void a_expr0(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_expr0__poss1(parentStates, nextStates, outputVar);
            a_expr0__poss2(parentStates, nextStates, outputVar);
            a_expr0__poss3(parentStates, nextStates, outputVar);
        }
    
        // expr0
        bool n_expr0__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr0__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr0__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr0>();
                a_expr0_1({state}, nextStates, state->node);
            }
        }
    
        // expr0 	= _ <identifier>
        void a_expr0_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_identifier(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr0
        bool n_expr0__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr0__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr0__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr0>();
                a_expr0_2({state}, nextStates, state->node);
            }
        }
    
        // expr0 = '(' <ONL> <expression> ')' _ <ONL>
        void a_expr0_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr0 = '(' <ONL> <expression> _ ')' <ONL>
        bool n_expr0_5(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_PAR)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr0_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_expr0_5];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // expr0 = '(' <ONL> _ <expression> ')' <ONL>
        void a_expr0_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr0 = '(' _ <ONL> <expression> ')' <ONL>
        void a_expr0_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr0 = _ '(' <ONL> <expression> ')' <ONL>
        bool n_expr0_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_PAR)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr0_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_expr0_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // expr0
        bool n_expr0__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr0__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr0__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr0>();
                a_expr0_7({state}, nextStates, state->node);
            }
        }
    
        // expr0 = _ <literal>
        void a_expr0_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_literal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // identifier
        void a_identifier(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_identifier__poss1(parentStates, nextStates, outputVar);
        }
    
        // identifier
        bool n_identifier__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_identifier__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_identifier__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_identifier>();
                a_identifier_1({state}, nextStates, state->node);
            }
        }
    
        // identifier = _ name:L_IDENTIFIER
        bool n_identifier_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists["name"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_identifier_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_identifier_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // suffixFunction
        void a_suffixFunction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_suffixFunction__poss1(parentStates, nextStates, outputVar);
        }
    
        // suffixFunction
        bool n_suffixFunction__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_suffixFunction__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_suffixFunction__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_suffixFunction>();
                a_suffixFunction_1({state}, nextStates, state->node);
            }
        }
    
        // suffixFunction = <left:expr1> '.' <ONL> _ <right:expr0>
        void a_suffixFunction_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr0(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // suffixFunction = <left:expr1> '.' _ <ONL> <right:expr0>
        void a_suffixFunction_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // suffixFunction = <left:expr1> _ '.' <ONL> <right:expr0>
        bool n_suffixFunction_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_MEMBER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_suffixFunction_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_suffixFunction_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // suffixFunction = _ <left:expr1> '.' <ONL> <right:expr0>
        void a_suffixFunction_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr1(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // expr1
        void a_expr1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_expr1__poss1(parentStates, nextStates, outputVar);
            a_expr1__poss2(parentStates, nextStates, outputVar);
        }
    
        // expr1
        bool n_expr1__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr1__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr1__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr1>();
                a_expr1_1({state}, nextStates, state->node);
            }
        }
    
        // expr1 = _ <expr0>
        void a_expr1_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr0(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr1
        bool n_expr1__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr1__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr1__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr1>();
                a_expr1_2({state}, nextStates, state->node);
            }
        }
    
        // expr1 = _ <suffixFunction>
        void a_expr1_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_suffixFunction(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // suffixInc
        void a_suffixInc(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_suffixInc__poss1(parentStates, nextStates, outputVar);
        }
    
        // suffixInc
        bool n_suffixInc__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_suffixInc__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_suffixInc__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_suffixInc>();
                a_suffixInc_1({state}, nextStates, state->node);
            }
        }
    
        // suffixInc = <val:expr2> _ '++'
        bool n_suffixInc_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_INCREMENT)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_suffixInc_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_suffixInc_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // suffixInc = _ <val:expr2> '++'
        void a_suffixInc_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr2(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // suffixDec
        void a_suffixDec(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_suffixDec__poss1(parentStates, nextStates, outputVar);
        }
    
        // suffixDec
        bool n_suffixDec__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_suffixDec__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_suffixDec__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_suffixDec>();
                a_suffixDec_1({state}, nextStates, state->node);
            }
        }
    
        // suffixDec = <val:expr2> _ '--'
        bool n_suffixDec_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_DECREMENT)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_suffixDec_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_suffixDec_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // suffixDec = _ <val:expr2> '--'
        void a_suffixDec_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr2(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // copy
        void a_copy(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_copy__poss1(parentStates, nextStates, outputVar);
        }
    
        // copy
        bool n_copy__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_copy__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_copy__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_copy>();
                a_copy_1({state}, nextStates, state->node);
            }
        }
    
        // copy = 'new' <ONL> _ <val:expr2>
        void a_copy_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr2(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // copy = 'new' _ <ONL> <val:expr2>
        void a_copy_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // copy = _ 'new' <ONL> <val:expr2>
        bool n_copy_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_copy_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_copy_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // prefixFunction
        void a_prefixFunction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_prefixFunction__poss1(parentStates, nextStates, outputVar);
        }
    
        // prefixFunction
        bool n_prefixFunction__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_prefixFunction__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_prefixFunction__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_prefixFunction>();
                a_prefixFunction_1({state}, nextStates, state->node);
            }
        }
    
        // prefixFunction = <left:expr1> _ <right:expr2>
        void a_prefixFunction_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr2(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // prefixFunction = _ <left:expr1> <right:expr2>
        void a_prefixFunction_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr1(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // expr2
        void a_expr2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_expr2__poss1(parentStates, nextStates, outputVar);
            a_expr2__poss2(parentStates, nextStates, outputVar);
            a_expr2__poss3(parentStates, nextStates, outputVar);
            a_expr2__poss4(parentStates, nextStates, outputVar);
            a_expr2__poss5(parentStates, nextStates, outputVar);
        }
    
        // expr2
        bool n_expr2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr2>();
                a_expr2_1({state}, nextStates, state->node);
            }
        }
    
        // expr2 = _ <expr1>
        void a_expr2_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr1(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr2
        bool n_expr2__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr2__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr2__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr2>();
                a_expr2_2({state}, nextStates, state->node);
            }
        }
    
        // expr2 = _ <suffixInc>
        void a_expr2_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_suffixInc(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr2
        bool n_expr2__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr2__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr2__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr2>();
                a_expr2_3({state}, nextStates, state->node);
            }
        }
    
        // expr2 = _ <suffixDec>
        void a_expr2_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_suffixDec(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr2
        bool n_expr2__poss4(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr2__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr2__poss4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr2>();
                a_expr2_4({state}, nextStates, state->node);
            }
        }
    
        // expr2 = _ <copy>
        void a_expr2_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_copy(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr2
        bool n_expr2__poss5(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr2__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr2__poss5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr2>();
                a_expr2_5({state}, nextStates, state->node);
            }
        }
    
        // expr2 = _ <prefixFunction>
        void a_expr2_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_prefixFunction(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // prefixInc
        void a_prefixInc(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_prefixInc__poss1(parentStates, nextStates, outputVar);
        }
    
        // prefixInc
        bool n_prefixInc__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_prefixInc__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_prefixInc__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_prefixInc>();
                a_prefixInc_1({state}, nextStates, state->node);
            }
        }
    
        // prefixInc = '++' <ONL> _ <val:expr3>
        void a_prefixInc_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr3(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // prefixInc = '++' _ <ONL> <val:expr3>
        void a_prefixInc_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // prefixInc = _ '++' <ONL> <val:expr3>
        bool n_prefixInc_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_INCREMENT)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_prefixInc_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_prefixInc_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // prefixDec
        void a_prefixDec(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_prefixDec__poss1(parentStates, nextStates, outputVar);
        }
    
        // prefixDec
        bool n_prefixDec__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_prefixDec__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_prefixDec__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_prefixDec>();
                a_prefixDec_1({state}, nextStates, state->node);
            }
        }
    
        // prefixDec = '--' <ONL> _ <val:expr3>
        void a_prefixDec_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr3(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // prefixDec = '--' _ <ONL> <val:expr3>
        void a_prefixDec_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // prefixDec = _ '--' <ONL> <val:expr3>
        bool n_prefixDec_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_DECREMENT)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_prefixDec_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_prefixDec_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // plus
        void a_plus(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_plus__poss1(parentStates, nextStates, outputVar);
        }
    
        // plus
        bool n_plus__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_plus__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_plus__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_plus>();
                a_plus_1({state}, nextStates, state->node);
            }
        }
    
        // plus = '+' <ONL> _ <val:expr3>
        void a_plus_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr3(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // plus = '+' _ <ONL> <val:expr3>
        void a_plus_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // plus = _ '+' <ONL> <val:expr3>
        bool n_plus_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_ADD)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_plus_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_plus_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // minus
        void a_minus(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_minus__poss1(parentStates, nextStates, outputVar);
        }
    
        // minus
        bool n_minus__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_minus__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_minus__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_minus>();
                a_minus_1({state}, nextStates, state->node);
            }
        }
    
        // minus = '-' <ONL> _ <val:expr3>
        void a_minus_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr3(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // minus = '-' _ <ONL> <val:expr3>
        void a_minus_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // minus = _ '-' <ONL> <val:expr3>
        bool n_minus_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SUB)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_minus_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_minus_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // logNot
        void a_logNot(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_logNot__poss1(parentStates, nextStates, outputVar);
        }
    
        // logNot
        bool n_logNot__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logNot__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_logNot__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_logNot>();
                a_logNot_1({state}, nextStates, state->node);
            }
        }
    
        // logNot = '!' <ONL> _ <val:expr3>
        void a_logNot_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr3(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // logNot = '!' _ <ONL> <val:expr3>
        void a_logNot_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // logNot = _ '!' <ONL> <val:expr3>
        bool n_logNot_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NOT)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logNot_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_logNot_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // expr3
        void a_expr3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_expr3__poss1(parentStates, nextStates, outputVar);
            a_expr3__poss2(parentStates, nextStates, outputVar);
            a_expr3__poss3(parentStates, nextStates, outputVar);
            a_expr3__poss4(parentStates, nextStates, outputVar);
            a_expr3__poss5(parentStates, nextStates, outputVar);
            a_expr3__poss6(parentStates, nextStates, outputVar);
        }
    
        // expr3
        bool n_expr3__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr3__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr3__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr3>();
                a_expr3_1({state}, nextStates, state->node);
            }
        }
    
        // expr3 = _ <expr2>
        void a_expr3_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr2(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr3
        bool n_expr3__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr3__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr3__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr3>();
                a_expr3_2({state}, nextStates, state->node);
            }
        }
    
        // expr3 = _ <prefixInc>
        void a_expr3_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_prefixInc(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr3
        bool n_expr3__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr3__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr3__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr3>();
                a_expr3_3({state}, nextStates, state->node);
            }
        }
    
        // expr3 = _ <prefixDec>
        void a_expr3_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_prefixDec(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr3
        bool n_expr3__poss4(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr3__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr3__poss4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr3>();
                a_expr3_4({state}, nextStates, state->node);
            }
        }
    
        // expr3 = _ <plus>
        void a_expr3_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_plus(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr3
        bool n_expr3__poss5(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr3__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr3__poss5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr3>();
                a_expr3_5({state}, nextStates, state->node);
            }
        }
    
        // expr3 = _ <minus>
        void a_expr3_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_minus(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr3
        bool n_expr3__poss6(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr3__poss6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr3__poss6);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr3>();
                a_expr3_6({state}, nextStates, state->node);
            }
        }
    
        // expr3 = _ <logNot>
        void a_expr3_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_logNot(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // multiplication
        void a_multiplication(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_multiplication__poss1(parentStates, nextStates, outputVar);
        }
    
        // multiplication
        bool n_multiplication__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_multiplication__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_multiplication__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_multiplication>();
                a_multiplication_1({state}, nextStates, state->node);
            }
        }
    
        // multiplication = <left:expr4> '*' <ONL> _ <right:expr3>
        void a_multiplication_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr3(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // multiplication = <left:expr4> '*' _ <ONL> <right:expr3>
        void a_multiplication_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // multiplication = <left:expr4> _ '*' <ONL> <right:expr3>
        bool n_multiplication_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_MUL)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_multiplication_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_multiplication_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // multiplication = _ <left:expr4> '*' <ONL> <right:expr3>
        void a_multiplication_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr4(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // crossProduct
        void a_crossProduct(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_crossProduct__poss1(parentStates, nextStates, outputVar);
        }
    
        // crossProduct
        bool n_crossProduct__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_crossProduct__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_crossProduct__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_crossProduct>();
                a_crossProduct_1({state}, nextStates, state->node);
            }
        }
    
        // crossProduct = <left:expr4> '' <ONL> _ <right:expr3>
        void a_crossProduct_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr3(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // crossProduct = <left:expr4> '' _ <ONL> <right:expr3>
        void a_crossProduct_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // crossProduct = <left:expr4> _ '' <ONL> <right:expr3>
        bool n_crossProduct_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CROSS)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_crossProduct_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_crossProduct_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // crossProduct = _ <left:expr4> '' <ONL> <right:expr3>
        void a_crossProduct_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr4(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // dotProduct
        void a_dotProduct(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_dotProduct__poss1(parentStates, nextStates, outputVar);
        }
    
        // dotProduct
        bool n_dotProduct__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dotProduct__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_dotProduct__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dotProduct>();
                a_dotProduct_1({state}, nextStates, state->node);
            }
        }
    
        // dotProduct = <left:expr4> '' <ONL> _ <right:expr3>
        void a_dotProduct_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr3(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // dotProduct = <left:expr4> '' _ <ONL> <right:expr3>
        void a_dotProduct_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // dotProduct = <left:expr4> _ '' <ONL> <right:expr3>
        bool n_dotProduct_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_DOT)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dotProduct_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dotProduct_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dotProduct = _ <left:expr4> '' <ONL> <right:expr3>
        void a_dotProduct_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr4(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // division
        void a_division(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_division__poss1(parentStates, nextStates, outputVar);
        }
    
        // division
        bool n_division__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_division__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_division__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_division>();
                a_division_1({state}, nextStates, state->node);
            }
        }
    
        // division = <left:expr4> '/' <ONL> _ <right:expr3>
        void a_division_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr3(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // division = <left:expr4> '/' _ <ONL> <right:expr3>
        void a_division_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // division = <left:expr4> _ '/' <ONL> <right:expr3>
        bool n_division_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_DIV)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_division_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_division_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // division = _ <left:expr4> '/' <ONL> <right:expr3>
        void a_division_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr4(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // divisionInt
        void a_divisionInt(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_divisionInt__poss1(parentStates, nextStates, outputVar);
        }
    
        // divisionInt
        bool n_divisionInt__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_divisionInt__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_divisionInt__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_divisionInt>();
                a_divisionInt_1({state}, nextStates, state->node);
            }
        }
    
        // divisionInt = <left:expr4> '/%' <ONL> _ <right:expr3>
        void a_divisionInt_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr3(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // divisionInt = <left:expr4> '/%' _ <ONL> <right:expr3>
        void a_divisionInt_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // divisionInt = <left:expr4> _ '/%' <ONL> <right:expr3>
        bool n_divisionInt_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_INT_DIV)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_divisionInt_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_divisionInt_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // divisionInt = _ <left:expr4> '/%' <ONL> <right:expr3>
        void a_divisionInt_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr4(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // modulo
        void a_modulo(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_modulo__poss1(parentStates, nextStates, outputVar);
        }
    
        // modulo
        bool n_modulo__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_modulo__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_modulo__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_modulo>();
                a_modulo_1({state}, nextStates, state->node);
            }
        }
    
        // modulo = <left:expr4> '%' <ONL> _ <right:expr3>
        void a_modulo_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr3(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // modulo = <left:expr4> '%' _ <ONL> <right:expr3>
        void a_modulo_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // modulo = <left:expr4> _ '%' <ONL> <right:expr3>
        bool n_modulo_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_MOD)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_modulo_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_modulo_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // modulo = _ <left:expr4> '%' <ONL> <right:expr3>
        void a_modulo_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr4(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // expr4
        void a_expr4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_expr4__poss1(parentStates, nextStates, outputVar);
            a_expr4__poss2(parentStates, nextStates, outputVar);
            a_expr4__poss3(parentStates, nextStates, outputVar);
            a_expr4__poss4(parentStates, nextStates, outputVar);
            a_expr4__poss5(parentStates, nextStates, outputVar);
            a_expr4__poss6(parentStates, nextStates, outputVar);
            a_expr4__poss7(parentStates, nextStates, outputVar);
        }
    
        // expr4
        bool n_expr4__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr4__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr4>();
                a_expr4_1({state}, nextStates, state->node);
            }
        }
    
        // expr4 = _ <expr3>
        void a_expr4_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr3(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr4
        bool n_expr4__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr4__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr4>();
                a_expr4_2({state}, nextStates, state->node);
            }
        }
    
        // expr4 = _ <multiplication>
        void a_expr4_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_multiplication(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr4
        bool n_expr4__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr4__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr4>();
                a_expr4_3({state}, nextStates, state->node);
            }
        }
    
        // expr4 = _ <crossProduct>
        void a_expr4_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_crossProduct(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr4
        bool n_expr4__poss4(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr4__poss4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr4>();
                a_expr4_4({state}, nextStates, state->node);
            }
        }
    
        // expr4 = _ <dotProduct>
        void a_expr4_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_dotProduct(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr4
        bool n_expr4__poss5(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr4__poss5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr4>();
                a_expr4_5({state}, nextStates, state->node);
            }
        }
    
        // expr4 = _ <division>
        void a_expr4_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_division(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr4
        bool n_expr4__poss6(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4__poss6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr4__poss6);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr4>();
                a_expr4_6({state}, nextStates, state->node);
            }
        }
    
        // expr4 = _ <divisionInt>
        void a_expr4_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_divisionInt(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr4
        bool n_expr4__poss7(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr4__poss7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr4__poss7);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr4>();
                a_expr4_7({state}, nextStates, state->node);
            }
        }
    
        // expr4 = _ <modulo>
        void a_expr4_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_modulo(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // addition
        void a_addition(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_addition__poss1(parentStates, nextStates, outputVar);
        }
    
        // addition
        bool n_addition__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_addition__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_addition__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_addition>();
                a_addition_1({state}, nextStates, state->node);
            }
        }
    
        // addition = <left:expr5> '+' <ONL> _ <right:expr4>
        void a_addition_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr4(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // addition = <left:expr5> '+' _ <ONL> <right:expr4>
        void a_addition_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // addition = <left:expr5> _ '+' <ONL> <right:expr4>
        bool n_addition_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_ADD)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_addition_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_addition_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // addition = _ <left:expr5> '+' <ONL> <right:expr4>
        void a_addition_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr5(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // subtraction
        void a_subtraction(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_subtraction__poss1(parentStates, nextStates, outputVar);
        }
    
        // subtraction
        bool n_subtraction__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_subtraction__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_subtraction__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_subtraction>();
                a_subtraction_1({state}, nextStates, state->node);
            }
        }
    
        // subtraction = <left:expr5> '-' <ONL> _ <right:expr4>
        void a_subtraction_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr4(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // subtraction = <left:expr5> '-' _ <ONL> <right:expr4>
        void a_subtraction_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // subtraction = <left:expr5> _ '-' <ONL> <right:expr4>
        bool n_subtraction_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SUB)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_subtraction_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_subtraction_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // subtraction = _ <left:expr5> '-' <ONL> <right:expr4>
        void a_subtraction_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr5(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // expr5
        void a_expr5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_expr5__poss1(parentStates, nextStates, outputVar);
            a_expr5__poss2(parentStates, nextStates, outputVar);
            a_expr5__poss3(parentStates, nextStates, outputVar);
        }
    
        // expr5
        bool n_expr5__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr5__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr5__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr5>();
                a_expr5_1({state}, nextStates, state->node);
            }
        }
    
        // expr5 = _ <expr4>
        void a_expr5_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr4(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr5
        bool n_expr5__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr5__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr5__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr5>();
                a_expr5_2({state}, nextStates, state->node);
            }
        }
    
        // expr5 = _ <addition>
        void a_expr5_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_addition(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr5
        bool n_expr5__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr5__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr5__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr5>();
                a_expr5_3({state}, nextStates, state->node);
            }
        }
    
        // expr5 = _ <subtraction>
        void a_expr5_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_subtraction(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // shiftL
        void a_shiftL(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_shiftL__poss1(parentStates, nextStates, outputVar);
        }
    
        // shiftL
        bool n_shiftL__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftL__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_shiftL__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftL>();
                a_shiftL_1({state}, nextStates, state->node);
            }
        }
    
        // shiftL = <left:expr6> '<<' <ONL> _ <right:expr5>
        void a_shiftL_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr5(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // shiftL = <left:expr6> '<<' _ <ONL> <right:expr5>
        void a_shiftL_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // shiftL = <left:expr6> _ '<<' <ONL> <right:expr5>
        bool n_shiftL_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SHIFT_LEFT)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftL_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_shiftL_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // shiftL = _ <left:expr6> '<<' <ONL> <right:expr5>
        void a_shiftL_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr6(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // shiftR
        void a_shiftR(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_shiftR__poss1(parentStates, nextStates, outputVar);
        }
    
        // shiftR
        bool n_shiftR__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftR__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_shiftR__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftR>();
                a_shiftR_1({state}, nextStates, state->node);
            }
        }
    
        // shiftR = <left:expr6> '>>' <ONL> _ <right:expr5>
        void a_shiftR_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr5(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // shiftR = <left:expr6> '>>' _ <ONL> <right:expr5>
        void a_shiftR_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // shiftR = <left:expr6> _ '>>' <ONL> <right:expr5>
        bool n_shiftR_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SHIFT_RIGHT)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftR_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_shiftR_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // shiftR = _ <left:expr6> '>>' <ONL> <right:expr5>
        void a_shiftR_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr6(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // expr6
        void a_expr6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_expr6__poss1(parentStates, nextStates, outputVar);
            a_expr6__poss2(parentStates, nextStates, outputVar);
            a_expr6__poss3(parentStates, nextStates, outputVar);
        }
    
        // expr6
        bool n_expr6__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr6__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr6__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr6>();
                a_expr6_1({state}, nextStates, state->node);
            }
        }
    
        // expr6 = _ <expr5>
        void a_expr6_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr5(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr6
        bool n_expr6__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr6__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr6__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr6>();
                a_expr6_2({state}, nextStates, state->node);
            }
        }
    
        // expr6 = _ <shiftL>
        void a_expr6_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_shiftL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr6
        bool n_expr6__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr6__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr6__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr6>();
                a_expr6_3({state}, nextStates, state->node);
            }
        }
    
        // expr6 = _ <shiftR>
        void a_expr6_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_shiftR(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // compLess
        void a_compLess(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_compLess__poss1(parentStates, nextStates, outputVar);
        }
    
        // compLess
        bool n_compLess__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compLess__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_compLess__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compLess>();
                a_compLess_1({state}, nextStates, state->node);
            }
        }
    
        // compLess = <left:expr7> '<' <ONL> _ <right:expr6>
        void a_compLess_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr6(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // compLess = <left:expr7> '<' _ <ONL> <right:expr6>
        void a_compLess_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // compLess = <left:expr7> _ '<' <ONL> <right:expr6>
        bool n_compLess_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LESS)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compLess_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compLess_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compLess = _ <left:expr7> '<' <ONL> <right:expr6>
        void a_compLess_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr7(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // compGreat
        void a_compGreat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_compGreat__poss1(parentStates, nextStates, outputVar);
        }
    
        // compGreat
        bool n_compGreat__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compGreat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_compGreat__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compGreat>();
                a_compGreat_1({state}, nextStates, state->node);
            }
        }
    
        // compGreat = <left:expr7> '>' <ONL> _ <right:expr6>
        void a_compGreat_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr6(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // compGreat = <left:expr7> '>' _ <ONL> <right:expr6>
        void a_compGreat_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // compGreat = <left:expr7> _ '>' <ONL> <right:expr6>
        bool n_compGreat_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_GREAT)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compGreat_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compGreat_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compGreat = _ <left:expr7> '>' <ONL> <right:expr6>
        void a_compGreat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr7(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // compLeEq
        void a_compLeEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_compLeEq__poss1(parentStates, nextStates, outputVar);
        }
    
        // compLeEq
        bool n_compLeEq__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compLeEq__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_compLeEq__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compLeEq>();
                a_compLeEq_1({state}, nextStates, state->node);
            }
        }
    
        // compLeEq = <left:expr7> '<=' <ONL> _ <right:expr6>
        void a_compLeEq_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr6(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // compLeEq = <left:expr7> '<=' _ <ONL> <right:expr6>
        void a_compLeEq_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // compLeEq = <left:expr7> _ '<=' <ONL> <right:expr6>
        bool n_compLeEq_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEEQ)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compLeEq_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compLeEq_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compLeEq = _ <left:expr7> '<=' <ONL> <right:expr6>
        void a_compLeEq_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr7(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // compGrEq
        void a_compGrEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_compGrEq__poss1(parentStates, nextStates, outputVar);
        }
    
        // compGrEq
        bool n_compGrEq__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compGrEq__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_compGrEq__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compGrEq>();
                a_compGrEq_1({state}, nextStates, state->node);
            }
        }
    
        // compGrEq = <left:expr7> '>=' <ONL> _ <right:expr6>
        void a_compGrEq_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr6(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // compGrEq = <left:expr7> '>=' _ <ONL> <right:expr6>
        void a_compGrEq_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // compGrEq = <left:expr7> _ '>=' <ONL> <right:expr6>
        bool n_compGrEq_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_GREQ)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compGrEq_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compGrEq_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compGrEq = _ <left:expr7> '>=' <ONL> <right:expr6>
        void a_compGrEq_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr7(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // expr7
        void a_expr7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_expr7__poss1(parentStates, nextStates, outputVar);
            a_expr7__poss2(parentStates, nextStates, outputVar);
            a_expr7__poss3(parentStates, nextStates, outputVar);
            a_expr7__poss4(parentStates, nextStates, outputVar);
            a_expr7__poss5(parentStates, nextStates, outputVar);
        }
    
        // expr7
        bool n_expr7__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr7__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr7__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr7>();
                a_expr7_1({state}, nextStates, state->node);
            }
        }
    
        // expr7 = _ <expr6>
        void a_expr7_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr6(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr7
        bool n_expr7__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr7__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr7__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr7>();
                a_expr7_2({state}, nextStates, state->node);
            }
        }
    
        // expr7 = _ <compLess>
        void a_expr7_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_compLess(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr7
        bool n_expr7__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr7__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr7__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr7>();
                a_expr7_3({state}, nextStates, state->node);
            }
        }
    
        // expr7 = _ <compGreat>
        void a_expr7_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_compGreat(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr7
        bool n_expr7__poss4(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr7__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr7__poss4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr7>();
                a_expr7_4({state}, nextStates, state->node);
            }
        }
    
        // expr7 = _ <compLeEq>
        void a_expr7_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_compLeEq(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr7
        bool n_expr7__poss5(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr7__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr7__poss5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr7>();
                a_expr7_5({state}, nextStates, state->node);
            }
        }
    
        // expr7 = _ <compGrEq>
        void a_expr7_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_compGrEq(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // compEqual
        void a_compEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_compEqual__poss1(parentStates, nextStates, outputVar);
        }
    
        // compEqual
        bool n_compEqual__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compEqual__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_compEqual__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compEqual>();
                a_compEqual_1({state}, nextStates, state->node);
            }
        }
    
        // compEqual = <left:expr8> '?=' <ONL> _ <right:expr7>
        void a_compEqual_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr7(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // compEqual = <left:expr8> '?=' _ <ONL> <right:expr7>
        void a_compEqual_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // compEqual = <left:expr8> _ '?=' <ONL> <right:expr7>
        bool n_compEqual_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_EQUAL)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compEqual_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compEqual_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compEqual = _ <left:expr8> '?=' <ONL> <right:expr7>
        void a_compEqual_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr8(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // compNotEq
        void a_compNotEq(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_compNotEq__poss1(parentStates, nextStates, outputVar);
        }
    
        // compNotEq
        bool n_compNotEq__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compNotEq__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_compNotEq__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compNotEq>();
                a_compNotEq_1({state}, nextStates, state->node);
            }
        }
    
        // compNotEq = <left:expr8> '!=' <ONL> _ <right:expr7>
        void a_compNotEq_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr7(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // compNotEq = <left:expr8> '!=' _ <ONL> <right:expr7>
        void a_compNotEq_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // compNotEq = <left:expr8> _ '!=' <ONL> <right:expr7>
        bool n_compNotEq_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NOTEQ)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compNotEq_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compNotEq_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compNotEq = _ <left:expr8> '!=' <ONL> <right:expr7>
        void a_compNotEq_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr8(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // compAssigned
        void a_compAssigned(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_compAssigned__poss1(parentStates, nextStates, outputVar);
        }
    
        // compAssigned
        bool n_compAssigned__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compAssigned__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_compAssigned__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compAssigned>();
                a_compAssigned_1({state}, nextStates, state->node);
            }
        }
    
        // compAssigned = <left:expr8> '?->' <ONL> _ <right:expr7>
        void a_compAssigned_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr7(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // compAssigned = <left:expr8> '?->' _ <ONL> <right:expr7>
        void a_compAssigned_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // compAssigned = <left:expr8> _ '?->' <ONL> <right:expr7>
        bool n_compAssigned_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_ASSIGNED)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compAssigned_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compAssigned_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compAssigned = _ <left:expr8> '?->' <ONL> <right:expr7>
        void a_compAssigned_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr8(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // compNotAss
        void a_compNotAss(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_compNotAss__poss1(parentStates, nextStates, outputVar);
        }
    
        // compNotAss
        bool n_compNotAss__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compNotAss__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_compNotAss__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_compNotAss>();
                a_compNotAss_1({state}, nextStates, state->node);
            }
        }
    
        // compNotAss = <left:expr8> '!->' <ONL> _ <right:expr7>
        void a_compNotAss_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr7(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // compNotAss = <left:expr8> '!->' _ <ONL> <right:expr7>
        void a_compNotAss_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // compNotAss = <left:expr8> _ '!->' <ONL> <right:expr7>
        bool n_compNotAss_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NOTASS)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_compNotAss_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_compNotAss_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // compNotAss = _ <left:expr8> '!->' <ONL> <right:expr7>
        void a_compNotAss_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr8(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // expr8
        void a_expr8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_expr8__poss1(parentStates, nextStates, outputVar);
            a_expr8__poss2(parentStates, nextStates, outputVar);
            a_expr8__poss3(parentStates, nextStates, outputVar);
            a_expr8__poss4(parentStates, nextStates, outputVar);
            a_expr8__poss5(parentStates, nextStates, outputVar);
        }
    
        // expr8
        bool n_expr8__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr8__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr8__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr8>();
                a_expr8_1({state}, nextStates, state->node);
            }
        }
    
        // expr8 = _ <expr7>
        void a_expr8_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr7(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr8
        bool n_expr8__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr8__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr8__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr8>();
                a_expr8_2({state}, nextStates, state->node);
            }
        }
    
        // expr8 = _ <compEqual>
        void a_expr8_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_compEqual(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr8
        bool n_expr8__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr8__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr8__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr8>();
                a_expr8_3({state}, nextStates, state->node);
            }
        }
    
        // expr8 = _ <compNotEq>
        void a_expr8_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_compNotEq(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr8
        bool n_expr8__poss4(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr8__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr8__poss4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr8>();
                a_expr8_4({state}, nextStates, state->node);
            }
        }
    
        // expr8 = _ <compAssigned>
        void a_expr8_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_compAssigned(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr8
        bool n_expr8__poss5(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr8__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr8__poss5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr8>();
                a_expr8_5({state}, nextStates, state->node);
            }
        }
    
        // expr8 = _ <compNotAss>
        void a_expr8_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_compNotAss(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // logAnd
        void a_logAnd(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_logAnd__poss1(parentStates, nextStates, outputVar);
        }
    
        // logAnd
        bool n_logAnd__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logAnd__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_logAnd__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_logAnd>();
                a_logAnd_1({state}, nextStates, state->node);
            }
        }
    
        // logAnd = <left:expr9> '&' <ONL> _ <right:expr8>
        void a_logAnd_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr8(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // logAnd = <left:expr9> '&' _ <ONL> <right:expr8>
        void a_logAnd_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // logAnd = <left:expr9> _ '&' <ONL> <right:expr8>
        bool n_logAnd_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_AND)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logAnd_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_logAnd_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // logAnd = _ <left:expr9> '&' <ONL> <right:expr8>
        void a_logAnd_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr9(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // expr9
        void a_expr9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_expr9__poss1(parentStates, nextStates, outputVar);
            a_expr9__poss2(parentStates, nextStates, outputVar);
        }
    
        // expr9
        bool n_expr9__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr9__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr9__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr9>();
                a_expr9_1({state}, nextStates, state->node);
            }
        }
    
        // expr9 = _ <expr8>
        void a_expr9_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr8(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr9
        bool n_expr9__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr9__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr9__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr9>();
                a_expr9_2({state}, nextStates, state->node);
            }
        }
    
        // expr9 = _ <logAnd>
        void a_expr9_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_logAnd(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // logXOr
        void a_logXOr(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_logXOr__poss1(parentStates, nextStates, outputVar);
        }
    
        // logXOr
        bool n_logXOr__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logXOr__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_logXOr__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_logXOr>();
                a_logXOr_1({state}, nextStates, state->node);
            }
        }
    
        // logXOr = <left:expr10> '^' <ONL> _ <right:expr9>
        void a_logXOr_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr9(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // logXOr = <left:expr10> '^' _ <ONL> <right:expr9>
        void a_logXOr_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // logXOr = <left:expr10> _ '^' <ONL> <right:expr9>
        bool n_logXOr_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_XOR)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logXOr_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_logXOr_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // logXOr = _ <left:expr10> '^' <ONL> <right:expr9>
        void a_logXOr_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr10(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // expr10
        void a_expr10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_expr10__poss1(parentStates, nextStates, outputVar);
            a_expr10__poss2(parentStates, nextStates, outputVar);
        }
    
        // expr10
        bool n_expr10__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr10__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr10__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr10>();
                a_expr10_1({state}, nextStates, state->node);
            }
        }
    
        // expr10 = _ <expr9>
        void a_expr10_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr9(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // expr10
        bool n_expr10__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_expr10__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_expr10__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_expr10>();
                a_expr10_2({state}, nextStates, state->node);
            }
        }
    
        // expr10 = _ <logXOr>
        void a_expr10_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_logXOr(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // logOr
        void a_logOr(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_logOr__poss1(parentStates, nextStates, outputVar);
        }
    
        // logOr
        bool n_logOr__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logOr__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_logOr__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_logOr>();
                a_logOr_1({state}, nextStates, state->node);
            }
        }
    
        // logOr = <left:exprLeast> '|' <ONL> _ <right:expr10>
        void a_logOr_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr10(parentStates, nextStates, &(curNode->nodeLists["right"].emplace_back(nullptr)));
        }
    
        // logOr = <left:exprLeast> '|' _ <ONL> <right:expr10>
        void a_logOr_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // logOr = <left:exprLeast> _ '|' <ONL> <right:expr10>
        bool n_logOr_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_OR)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_logOr_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_logOr_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // logOr = _ <left:exprLeast> '|' <ONL> <right:expr10>
        void a_logOr_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_exprLeast(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // exprLeast
        void a_exprLeast(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_exprLeast__poss1(parentStates, nextStates, outputVar);
            a_exprLeast__poss2(parentStates, nextStates, outputVar);
        }
    
        // exprLeast
        bool n_exprLeast__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_exprLeast__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_exprLeast__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_exprLeast>();
                a_exprLeast_1({state}, nextStates, state->node);
            }
        }
    
        // exprLeast = _ <expr10>
        void a_exprLeast_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expr10(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // exprLeast
        bool n_exprLeast__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_exprLeast__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_exprLeast__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_exprLeast>();
                a_exprLeast_2({state}, nextStates, state->node);
            }
        }
    
        // exprLeast = _ <logOr>
        void a_exprLeast_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_logOr(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // literal
        void a_literal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_literal__poss1(parentStates, nextStates, outputVar);
            a_literal__poss2(parentStates, nextStates, outputVar);
            a_literal__poss3(parentStates, nextStates, outputVar);
            a_literal__poss4(parentStates, nextStates, outputVar);
            a_literal__poss5(parentStates, nextStates, outputVar);
        }
    
        // literal
        bool n_literal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_literal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_literal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_literal>();
                a_literal_1({state}, nextStates, state->node);
            }
        }
    
        // literal 	= _ <contextLiteral>
        void a_literal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextLiteral(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // literal
        bool n_literal__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_literal__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_literal__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_literal>();
                a_literal_2({state}, nextStates, state->node);
            }
        }
    
        // literal = _ <valueLiteral>
        void a_literal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_valueLiteral(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // literal
        bool n_literal__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_literal__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_literal__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_literal>();
                a_literal_3({state}, nextStates, state->node);
            }
        }
    
        // literal = _ <listLiteral>
        void a_literal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_listLiteral(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // literal
        bool n_literal__poss4(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_literal__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_literal__poss4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_literal>();
                a_literal_4({state}, nextStates, state->node);
            }
        }
    
        // literal = _ <setLiteral>
        void a_literal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_setLiteral(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // literal
        bool n_literal__poss5(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_literal__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_literal__poss5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_literal>();
                a_literal_5({state}, nextStates, state->node);
            }
        }
    
        // literal = _ <dictLiteral>
        void a_literal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_dictLiteral(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // valueLiteral
        void a_valueLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_valueLiteral__poss1(parentStates, nextStates, outputVar);
            a_valueLiteral__poss2(parentStates, nextStates, outputVar);
            a_valueLiteral__poss3(parentStates, nextStates, outputVar);
            a_valueLiteral__poss4(parentStates, nextStates, outputVar);
            a_valueLiteral__poss5(parentStates, nextStates, outputVar);
        }
    
        // valueLiteral
        bool n_valueLiteral__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_1({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral 	= num:L_NUM_LIT _ [ suf:L_LIT_SUFFIX ]
        void a_valueLiteral_2__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_valueLiteral_2__skip(parentStates, nextStates, outputVar);
            a_valueLiteral_2__accept(parentStates, nextStates, outputVar);
        }
    
        // valueLiteral 	= num:L_NUM_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_valueLiteral_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
            }
        }
    
        // valueLiteral 	= num:L_NUM_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_2__accept(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_2__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_2__accept);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // valueLiteral 	= num:L_NUM_LIT _ [ suf:L_LIT_SUFFIX ]
        void a_valueLiteral_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_valueLiteral_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // valueLiteral 	= num:L_NUM_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_3({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral 	= num:L_NUM_LIT [ _ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LIT_SUFFIX)
                return false;
            curState->node->tokenLists["suf"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral 	= _ num:L_NUM_LIT [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NUM_LIT)
                return false;
            curState->node->tokenLists["num"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral
        bool n_valueLiteral__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_4({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral = str:L_NUM_B_LIT _ [ suf:L_LIT_SUFFIX ]
        void a_valueLiteral_5__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_valueLiteral_5__skip(parentStates, nextStates, outputVar);
            a_valueLiteral_5__accept(parentStates, nextStates, outputVar);
        }
    
        // valueLiteral = str:L_NUM_B_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_5__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_5__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_5__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_1({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral = str:L_NUM_B_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_5__accept(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_5__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_5__accept);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_5({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // valueLiteral = str:L_NUM_B_LIT _ [ suf:L_LIT_SUFFIX ]
        void a_valueLiteral_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_valueLiteral_5__poss1(parentStates, nextStates, outputVar);
        }
    
        // valueLiteral = str:L_NUM_B_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_5__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_5__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_5__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_6({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral = str:L_NUM_B_LIT [ _ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_6(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LIT_SUFFIX)
                return false;
            curState->node->tokenLists["suf"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_6];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral = _ str:L_NUM_B_LIT [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_4(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NUM_B_LIT)
                return false;
            curState->node->tokenLists["str"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_4];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral
        bool n_valueLiteral__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_7({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral = str:L_NUM_O_LIT _ [ suf:L_LIT_SUFFIX ]
        void a_valueLiteral_8__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_valueLiteral_8__skip(parentStates, nextStates, outputVar);
            a_valueLiteral_8__accept(parentStates, nextStates, outputVar);
        }
    
        // valueLiteral = str:L_NUM_O_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_8__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_8__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_8__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_4({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral = str:L_NUM_O_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_8__accept(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_8__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_8__accept);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_8({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // valueLiteral = str:L_NUM_O_LIT _ [ suf:L_LIT_SUFFIX ]
        void a_valueLiteral_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_valueLiteral_8__poss1(parentStates, nextStates, outputVar);
        }
    
        // valueLiteral = str:L_NUM_O_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_8__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_8__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_8__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_9({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral = str:L_NUM_O_LIT [ _ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_9(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LIT_SUFFIX)
                return false;
            curState->node->tokenLists["suf"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_9];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral = _ str:L_NUM_O_LIT [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_7(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NUM_O_LIT)
                return false;
            curState->node->tokenLists["str"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_7];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral
        bool n_valueLiteral__poss4(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral__poss4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_10({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral = str:L_NUM_X_LIT _ [ suf:L_LIT_SUFFIX ]
        void a_valueLiteral_11__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_valueLiteral_11__skip(parentStates, nextStates, outputVar);
            a_valueLiteral_11__accept(parentStates, nextStates, outputVar);
        }
    
        // valueLiteral = str:L_NUM_X_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_11__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_11__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_11__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_7({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral = str:L_NUM_X_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_11__accept(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_11__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_11__accept);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_11({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // valueLiteral = str:L_NUM_X_LIT _ [ suf:L_LIT_SUFFIX ]
        void a_valueLiteral_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_valueLiteral_11__poss1(parentStates, nextStates, outputVar);
        }
    
        // valueLiteral = str:L_NUM_X_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_11__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_11__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_11__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_12({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral = str:L_NUM_X_LIT [ _ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_12(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LIT_SUFFIX)
                return false;
            curState->node->tokenLists["suf"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_12];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral = _ str:L_NUM_X_LIT [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_10(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NUM_X_LIT)
                return false;
            curState->node->tokenLists["str"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_10];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral
        bool n_valueLiteral__poss5(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral__poss5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_13({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral = str:L_STR_LIT _ [ suf:L_LIT_SUFFIX ]
        void a_valueLiteral_14__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_valueLiteral_14__skip(parentStates, nextStates, outputVar);
            a_valueLiteral_14__accept(parentStates, nextStates, outputVar);
        }
    
        // valueLiteral = str:L_STR_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_14__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_14__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_14__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_10({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral = str:L_STR_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_14__accept(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_14__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_14__accept);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_14({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // valueLiteral = str:L_STR_LIT _ [ suf:L_LIT_SUFFIX ]
        void a_valueLiteral_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_valueLiteral_14__poss1(parentStates, nextStates, outputVar);
        }
    
        // valueLiteral = str:L_STR_LIT _ [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_14__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_14__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_valueLiteral_14__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_valueLiteral>();
                a_valueLiteral_15({state}, nextStates, state->node);
            }
        }
    
        // valueLiteral = str:L_STR_LIT [ _ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_15(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LIT_SUFFIX)
                return false;
            curState->node->tokenLists["suf"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_15];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // valueLiteral = _ str:L_STR_LIT [ suf:L_LIT_SUFFIX ]
        bool n_valueLiteral_13(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_STR_LIT)
                return false;
            curState->node->tokenLists["str"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_valueLiteral_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_valueLiteral_13];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral
        void a_listLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_listLiteral__poss1(parentStates, nextStates, outputVar);
            a_listLiteral__poss2(parentStates, nextStates, outputVar);
        }
    
        // listLiteral
        bool n_listLiteral__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_listLiteral__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_listLiteral>();
                a_listLiteral_1({state}, nextStates, state->node);
            }
        }
    
        // listLiteral = '[' <items:expression> (',' <items:expression>)* _ ']'
        bool n_listLiteral_6(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_BRACK)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_6];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral = '[' <items:expression> _ (',' <items:expression>)* ']'
        void a_listLiteral_3__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_listLiteral_3__skip(parentStates, nextStates, outputVar);
            a_listLiteral_3__cycle(parentStates, nextStates, outputVar);
        }
    
        // listLiteral = '[' <items:expression> _ (',' <items:expression>)* ']'
        bool n_listLiteral_3__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_3__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_3__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_listLiteral>();
                a_listLiteral_6({state}, nextStates, state->node);
            }
        }
    
        // listLiteral = '[' <items:expression> _ (',' <items:expression>)* ']'
        bool n_listLiteral_3__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_3__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_3__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_listLiteral>();
                a_listLiteral_3({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // listLiteral = '[' <items:expression> _ (',' <items:expression>)* ']'
        void a_listLiteral_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_listLiteral_3__poss1(parentStates, nextStates, outputVar);
        }
    
        // listLiteral = '[' <items:expression> _ (',' <items:expression>)* ']'
        bool n_listLiteral_3__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_3__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_3__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_listLiteral>();
                a_listLiteral_4({state}, nextStates, state->node);
            }
        }
    
        // listLiteral = '[' <items:expression> (',' _ <items:expression>)* ']'
        void a_listLiteral_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // listLiteral = '[' <items:expression> (_ ',' <items:expression>)* ']'
        bool n_listLiteral_4(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_4];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral = '[' _ <items:expression> (',' <items:expression>)* ']'
        void a_listLiteral_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // listLiteral = _ '[' <items:expression> (',' <items:expression>)* ']'
        bool n_listLiteral_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_BRACK)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral
        bool n_listLiteral__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_listLiteral__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_listLiteral>();
                a_listLiteral_7({state}, nextStates, state->node);
            }
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> _ ']'
        bool n_listLiteral_16(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_BRACK)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_16(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_16];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* _ <ONL> ']'
        void a_listLiteral_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' _ (<ONL> <items:expression> ',')* <ONL> ']'
        void a_listLiteral_11__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_listLiteral_11__skip(parentStates, nextStates, outputVar);
            a_listLiteral_11__cycle(parentStates, nextStates, outputVar);
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' _ (<ONL> <items:expression> ',')* <ONL> ']'
        bool n_listLiteral_11__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_11__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_11__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_listLiteral>();
                a_listLiteral_15({state}, nextStates, state->node);
            }
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' _ (<ONL> <items:expression> ',')* <ONL> ']'
        bool n_listLiteral_11__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_11__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_11__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_listLiteral>();
                a_listLiteral_11({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' _ (<ONL> <items:expression> ',')* <ONL> ']'
        void a_listLiteral_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_listLiteral_11__poss1(parentStates, nextStates, outputVar);
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' _ (<ONL> <items:expression> ',')* <ONL> ']'
        bool n_listLiteral_11__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_11__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_listLiteral_11__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_listLiteral>();
                a_listLiteral_12({state}, nextStates, state->node);
            }
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' (<ONL> <items:expression> _ ',')* <ONL> ']'
        bool n_listLiteral_14(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_14];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' (<ONL> _ <items:expression> ',')* <ONL> ']'
        void a_listLiteral_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // listLiteral = '[' <ONL> <items:expression> ',' (_ <ONL> <items:expression> ',')* <ONL> ']'
        void a_listLiteral_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // listLiteral = '[' <ONL> <items:expression> _ ',' (<ONL> <items:expression> ',')* <ONL> ']'
        bool n_listLiteral_10(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_10];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // listLiteral = '[' <ONL> _ <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> ']'
        void a_listLiteral_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // listLiteral = '[' _ <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> ']'
        void a_listLiteral_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // listLiteral = _ '[' <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> ']'
        bool n_listLiteral_7(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_BRACK)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_listLiteral_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_listLiteral_7];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral
        void a_setLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_setLiteral__poss1(parentStates, nextStates, outputVar);
            a_setLiteral__poss2(parentStates, nextStates, outputVar);
        }
    
        // setLiteral
        bool n_setLiteral__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_setLiteral__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_setLiteral>();
                a_setLiteral_1({state}, nextStates, state->node);
            }
        }
    
        // setLiteral 	= '{' <items:expression> (',' <items:expression>)* _ '}'
        bool n_setLiteral_6(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_BRACE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_6];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral 	= '{' <items:expression> _ (',' <items:expression>)* '}'
        void a_setLiteral_3__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_setLiteral_3__skip(parentStates, nextStates, outputVar);
            a_setLiteral_3__cycle(parentStates, nextStates, outputVar);
        }
    
        // setLiteral 	= '{' <items:expression> _ (',' <items:expression>)* '}'
        bool n_setLiteral_3__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_3__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_3__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_setLiteral>();
                a_setLiteral_6({state}, nextStates, state->node);
            }
        }
    
        // setLiteral 	= '{' <items:expression> _ (',' <items:expression>)* '}'
        bool n_setLiteral_3__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_3__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_3__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_setLiteral>();
                a_setLiteral_3({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // setLiteral 	= '{' <items:expression> _ (',' <items:expression>)* '}'
        void a_setLiteral_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_setLiteral_3__poss1(parentStates, nextStates, outputVar);
        }
    
        // setLiteral 	= '{' <items:expression> _ (',' <items:expression>)* '}'
        bool n_setLiteral_3__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_3__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_3__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_setLiteral>();
                a_setLiteral_4({state}, nextStates, state->node);
            }
        }
    
        // setLiteral 	= '{' <items:expression> (',' _ <items:expression>)* '}'
        void a_setLiteral_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // setLiteral 	= '{' <items:expression> (_ ',' <items:expression>)* '}'
        bool n_setLiteral_4(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_4];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral 	= '{' _ <items:expression> (',' <items:expression>)* '}'
        void a_setLiteral_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // setLiteral 	= _ '{' <items:expression> (',' <items:expression>)* '}'
        bool n_setLiteral_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_BRACE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral
        bool n_setLiteral__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_setLiteral__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_setLiteral>();
                a_setLiteral_7({state}, nextStates, state->node);
            }
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> _ '}'
        bool n_setLiteral_16(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_BRACE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_16(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_16];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* _ <ONL> '}'
        void a_setLiteral_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' _ (<ONL> <items:expression> ',')* <ONL> '}'
        void a_setLiteral_11__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_setLiteral_11__skip(parentStates, nextStates, outputVar);
            a_setLiteral_11__cycle(parentStates, nextStates, outputVar);
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' _ (<ONL> <items:expression> ',')* <ONL> '}'
        bool n_setLiteral_11__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_11__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_11__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_setLiteral>();
                a_setLiteral_15({state}, nextStates, state->node);
            }
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' _ (<ONL> <items:expression> ',')* <ONL> '}'
        bool n_setLiteral_11__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_11__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_11__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_setLiteral>();
                a_setLiteral_11({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' _ (<ONL> <items:expression> ',')* <ONL> '}'
        void a_setLiteral_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_setLiteral_11__poss1(parentStates, nextStates, outputVar);
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' _ (<ONL> <items:expression> ',')* <ONL> '}'
        bool n_setLiteral_11__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_11__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_setLiteral_11__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_setLiteral>();
                a_setLiteral_12({state}, nextStates, state->node);
            }
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' (<ONL> <items:expression> _ ',')* <ONL> '}'
        bool n_setLiteral_14(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_14];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' (<ONL> _ <items:expression> ',')* <ONL> '}'
        void a_setLiteral_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // setLiteral = '{' <ONL> <items:expression> ',' (_ <ONL> <items:expression> ',')* <ONL> '}'
        void a_setLiteral_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // setLiteral = '{' <ONL> <items:expression> _ ',' (<ONL> <items:expression> ',')* <ONL> '}'
        bool n_setLiteral_10(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_10];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // setLiteral = '{' <ONL> _ <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> '}'
        void a_setLiteral_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // setLiteral = '{' _ <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> '}'
        void a_setLiteral_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // setLiteral = _ '{' <ONL> <items:expression> ',' (<ONL> <items:expression> ',')* <ONL> '}'
        bool n_setLiteral_7(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_BRACE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_setLiteral_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_setLiteral_7];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral
        void a_dictLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_dictLiteral__poss1(parentStates, nextStates, outputVar);
            a_dictLiteral__poss2(parentStates, nextStates, outputVar);
        }
    
        // dictLiteral
        bool n_dictLiteral__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dictLiteral>();
                a_dictLiteral_1({state}, nextStates, state->node);
            }
        }
    
        // dictLiteral = '{' ':' <items:dictEntry> (',' <items:dictEntry>)* _ '}'
        bool n_dictLiteral_7(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_BRACE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_7];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = '{' ':' <items:dictEntry> _ (',' <items:dictEntry>)* '}'
        void a_dictLiteral_4__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_dictLiteral_4__skip(parentStates, nextStates, outputVar);
            a_dictLiteral_4__cycle(parentStates, nextStates, outputVar);
        }
    
        // dictLiteral = '{' ':' <items:dictEntry> _ (',' <items:dictEntry>)* '}'
        bool n_dictLiteral_4__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_4__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_4__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dictLiteral>();
                a_dictLiteral_7({state}, nextStates, state->node);
            }
        }
    
        // dictLiteral = '{' ':' <items:dictEntry> _ (',' <items:dictEntry>)* '}'
        bool n_dictLiteral_4__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_4__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_4__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dictLiteral>();
                a_dictLiteral_4({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // dictLiteral = '{' ':' <items:dictEntry> _ (',' <items:dictEntry>)* '}'
        void a_dictLiteral_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_dictLiteral_4__poss1(parentStates, nextStates, outputVar);
        }
    
        // dictLiteral = '{' ':' <items:dictEntry> _ (',' <items:dictEntry>)* '}'
        bool n_dictLiteral_4__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_4__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_4__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dictLiteral>();
                a_dictLiteral_5({state}, nextStates, state->node);
            }
        }
    
        // dictLiteral = '{' ':' <items:dictEntry> (',' _ <items:dictEntry>)* '}'
        void a_dictLiteral_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_dictEntry(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // dictLiteral = '{' ':' <items:dictEntry> (_ ',' <items:dictEntry>)* '}'
        bool n_dictLiteral_5(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_5];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = '{' ':' _ <items:dictEntry> (',' <items:dictEntry>)* '}'
        void a_dictLiteral_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_dictEntry(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // dictLiteral = '{' _ ':' <items:dictEntry> (',' <items:dictEntry>)* '}'
        bool n_dictLiteral_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = _ '{' ':' <items:dictEntry> (',' <items:dictEntry>)* '}'
        bool n_dictLiteral_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_BRACE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral
        bool n_dictLiteral__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dictLiteral>();
                a_dictLiteral_8({state}, nextStates, state->node);
            }
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' (<ONL> <items:dictEntry> ',')* <ONL> _ '}'
        bool n_dictLiteral_18(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_BRACE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_18(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_18];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' (<ONL> <items:dictEntry> ',')* _ <ONL> '}'
        void a_dictLiteral_17(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' _ (<ONL> <items:dictEntry> ',')* <ONL> '}'
        void a_dictLiteral_13__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_dictLiteral_13__skip(parentStates, nextStates, outputVar);
            a_dictLiteral_13__cycle(parentStates, nextStates, outputVar);
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' _ (<ONL> <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_13__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_13__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_13__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dictLiteral>();
                a_dictLiteral_17({state}, nextStates, state->node);
            }
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' _ (<ONL> <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_13__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_13__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_13__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dictLiteral>();
                a_dictLiteral_13({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' _ (<ONL> <items:dictEntry> ',')* <ONL> '}'
        void a_dictLiteral_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_dictLiteral_13__poss1(parentStates, nextStates, outputVar);
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' _ (<ONL> <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_13__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_13__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_dictLiteral_13__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dictLiteral>();
                a_dictLiteral_14({state}, nextStates, state->node);
            }
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' (<ONL> <items:dictEntry> _ ',')* <ONL> '}'
        bool n_dictLiteral_16(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_16(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_16];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' (<ONL> _ <items:dictEntry> ',')* <ONL> '}'
        void a_dictLiteral_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_dictEntry(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> ',' (_ <ONL> <items:dictEntry> ',')* <ONL> '}'
        void a_dictLiteral_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // dictLiteral = '{' ':' <ONL> <items:dictEntry> _ ',' (<ONL> <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_12(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_12];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = '{' ':' <ONL> _ <items:dictEntry> ',' (<ONL> <items:dictEntry> ',')* <ONL> '}'
        void a_dictLiteral_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_dictEntry(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // dictLiteral = '{' ':' _ <ONL> <items:dictEntry> ',' (<ONL> <items:dictEntry> ',')* <ONL> '}'
        void a_dictLiteral_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // dictLiteral = '{' _ ':' <ONL> <items:dictEntry> ',' (<ONL> <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_9(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_9];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictLiteral = _ '{' ':' <ONL> <items:dictEntry> ',' (<ONL> <items:dictEntry> ',')* <ONL> '}'
        bool n_dictLiteral_8(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_BRACE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictLiteral_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictLiteral_8];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictEntry
        void a_dictEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_dictEntry__poss1(parentStates, nextStates, outputVar);
        }
    
        // dictEntry
        bool n_dictEntry__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictEntry__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_dictEntry__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dictEntry>();
                a_dictEntry_1({state}, nextStates, state->node);
            }
        }
    
        // dictEntry = <key:expression> ':' <ONL> _ <value:expression>
        void a_dictEntry_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["value"].emplace_back(nullptr)));
        }
    
        // dictEntry = <key:expression> ':' _ <ONL> <value:expression>
        void a_dictEntry_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // dictEntry = <key:expression> _ ':' <ONL> <value:expression>
        bool n_dictEntry_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dictEntry_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dictEntry_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dictEntry = _ <key:expression> ':' <ONL> <value:expression>
        void a_dictEntry_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["key"].emplace_back(nullptr)));
        }
    
        // contextLiteral
        void a_contextLiteral(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextLiteral__poss1(parentStates, nextStates, outputVar);
            a_contextLiteral__poss2(parentStates, nextStates, outputVar);
        }
    
        // contextLiteral
        bool n_contextLiteral__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextLiteral>();
                a_contextLiteral_1({state}, nextStates, state->node);
            }
        }
    
        // contextLiteral 	= '(' <items:memberDecl> (',' <items:memberDecl>)* _ ')'
        bool n_contextLiteral_6(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_PAR)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_6];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextLiteral 	= '(' <items:memberDecl> _ (',' <items:memberDecl>)* ')'
        void a_contextLiteral_3__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextLiteral_3__skip(parentStates, nextStates, outputVar);
            a_contextLiteral_3__cycle(parentStates, nextStates, outputVar);
        }
    
        // contextLiteral 	= '(' <items:memberDecl> _ (',' <items:memberDecl>)* ')'
        bool n_contextLiteral_3__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_3__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_3__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextLiteral>();
                a_contextLiteral_6({state}, nextStates, state->node);
            }
        }
    
        // contextLiteral 	= '(' <items:memberDecl> _ (',' <items:memberDecl>)* ')'
        bool n_contextLiteral_3__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_3__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_3__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextLiteral>();
                a_contextLiteral_3({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // contextLiteral 	= '(' <items:memberDecl> _ (',' <items:memberDecl>)* ')'
        void a_contextLiteral_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextLiteral_3__poss1(parentStates, nextStates, outputVar);
        }
    
        // contextLiteral 	= '(' <items:memberDecl> _ (',' <items:memberDecl>)* ')'
        bool n_contextLiteral_3__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_3__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_3__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextLiteral>();
                a_contextLiteral_4({state}, nextStates, state->node);
            }
        }
    
        // contextLiteral 	= '(' <items:memberDecl> (',' _ <items:memberDecl>)* ')'
        void a_contextLiteral_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_memberDecl(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // contextLiteral 	= '(' <items:memberDecl> (_ ',' <items:memberDecl>)* ')'
        bool n_contextLiteral_4(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_4];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextLiteral 	= '(' _ <items:memberDecl> (',' <items:memberDecl>)* ')'
        void a_contextLiteral_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_memberDecl(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // contextLiteral 	= _ '(' <items:memberDecl> (',' <items:memberDecl>)* ')'
        bool n_contextLiteral_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_PAR)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextLiteral
        bool n_contextLiteral__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextLiteral>();
                a_contextLiteral_7({state}, nextStates, state->node);
            }
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> (',' <ONL> <items:memberDecl>)* ',' <ONL> _ ')'
        bool n_contextLiteral_16(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_RIGHT_PAR)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_16(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_16];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> (',' <ONL> <items:memberDecl>)* ',' _ <ONL> ')'
        void a_contextLiteral_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> (',' <ONL> <items:memberDecl>)* _ ',' <ONL> ')'
        bool n_contextLiteral_14(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_14];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> _ (',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        void a_contextLiteral_10__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextLiteral_10__skip(parentStates, nextStates, outputVar);
            a_contextLiteral_10__cycle(parentStates, nextStates, outputVar);
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> _ (',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        bool n_contextLiteral_10__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_10__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_10__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextLiteral>();
                a_contextLiteral_14({state}, nextStates, state->node);
            }
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> _ (',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        bool n_contextLiteral_10__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_10__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_10__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextLiteral>();
                a_contextLiteral_10({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> _ (',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        void a_contextLiteral_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_contextLiteral_10__poss1(parentStates, nextStates, outputVar);
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> _ (',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        bool n_contextLiteral_10__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_10__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_contextLiteral_10__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_contextLiteral>();
                a_contextLiteral_11({state}, nextStates, state->node);
            }
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> (',' <ONL> _ <items:memberDecl>)* ',' <ONL> ')'
        void a_contextLiteral_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_memberDecl(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> (',' _ <ONL> <items:memberDecl>)* ',' <ONL> ')'
        void a_contextLiteral_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // contextLiteral = '(' <ONL> <items:memberDecl> (_ ',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        bool n_contextLiteral_11(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_11];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // contextLiteral = '(' <ONL> _ <items:memberDecl> (',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        void a_contextLiteral_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_memberDecl(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // contextLiteral = '(' _ <ONL> <items:memberDecl> (',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        void a_contextLiteral_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // contextLiteral = _ '(' <ONL> <items:memberDecl> (',' <ONL> <items:memberDecl>)* ',' <ONL> ')'
        bool n_contextLiteral_7(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_LEFT_PAR)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_contextLiteral_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_contextLiteral_7];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // memberDecl
        void a_memberDecl(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_memberDecl__poss1(parentStates, nextStates, outputVar);
        }
    
        // memberDecl
        bool n_memberDecl__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_memberDecl__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_memberDecl__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_memberDecl>();
                a_memberDecl_1({state}, nextStates, state->node);
            }
        }
    
        // memberDecl = member:L_IDENTIFIER '=' _ <value:expression>
        void a_memberDecl_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["value"].emplace_back(nullptr)));
        }
    
        // memberDecl = member:L_IDENTIFIER _ '=' <value:expression>
        bool n_memberDecl_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_memberDecl_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_memberDecl_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // memberDecl = _ member:L_IDENTIFIER '=' <value:expression>
        bool n_memberDecl_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists["member"].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_memberDecl_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_memberDecl_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // statement
        void a_statement(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_statement__poss1(parentStates, nextStates, outputVar);
            a_statement__poss2(parentStates, nextStates, outputVar);
            a_statement__poss3(parentStates, nextStates, outputVar);
            a_statement__poss4(parentStates, nextStates, outputVar);
            a_statement__poss5(parentStates, nextStates, outputVar);
            a_statement__poss6(parentStates, nextStates, outputVar);
            a_statement__poss7(parentStates, nextStates, outputVar);
            a_statement__poss8(parentStates, nextStates, outputVar);
        }
    
        // statement
        bool n_statement__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_statement__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_statement>();
                a_statement_1({state}, nextStates, state->node);
            }
        }
    
        // statement 	= _ <expression>
        void a_statement_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // statement
        bool n_statement__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_statement__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_statement>();
                a_statement_2({state}, nextStates, state->node);
            }
        }
    
        // statement = _ <definition>
        void a_statement_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_definition(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // statement
        bool n_statement__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_statement__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_statement>();
                a_statement_3({state}, nextStates, state->node);
            }
        }
    
        // statement = _ <varDeclaration>
        void a_statement_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_varDeclaration(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // statement
        bool n_statement__poss4(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_statement__poss4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_statement>();
                a_statement_4({state}, nextStates, state->node);
            }
        }
    
        // statement = _ <assignmentEqual>
        void a_statement_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_assignmentEqual(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // statement
        bool n_statement__poss5(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_statement__poss5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_statement>();
                a_statement_5({state}, nextStates, state->node);
            }
        }
    
        // statement = _ <ifStat>
        void a_statement_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ifStat(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // statement
        bool n_statement__poss6(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement__poss6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_statement__poss6);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_statement>();
                a_statement_6({state}, nextStates, state->node);
            }
        }
    
        // statement = _ <loopStat>
        void a_statement_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_loopStat(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // statement
        bool n_statement__poss7(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement__poss7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_statement__poss7);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_statement>();
                a_statement_7({state}, nextStates, state->node);
            }
        }
    
        // statement = _ <jumpStat>
        void a_statement_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_jumpStat(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // statement
        bool n_statement__poss8(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_statement__poss8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_statement__poss8);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_statement>();
                a_statement_8({state}, nextStates, state->node);
            }
        }
    
        // statement = _ <withStat>
        void a_statement_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_withStat(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // definition
        void a_definition(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_definition__poss1(parentStates, nextStates, outputVar);
            a_definition__poss2(parentStates, nextStates, outputVar);
        }
    
        // definition
        bool n_definition__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_definition__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_definition__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_definition>();
                a_definition_1({state}, nextStates, state->node);
            }
        }
    
        // definition 	= 'def' <id:identifier> '='? <ONL> _ <val:expression>
        void a_definition_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // definition 	= 'def' <id:identifier> '='? _ <ONL> <val:expression>
        void a_definition_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // definition 	= 'def' <id:identifier> _ '='? <ONL> <val:expression>
        void a_definition_3__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_definition_3__skip(parentStates, nextStates, outputVar);
            a_definition_3__accept(parentStates, nextStates, outputVar);
        }
    
        // definition 	= 'def' <id:identifier> _ '='? <ONL> <val:expression>
        bool n_definition_3__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_definition_3__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_definition_3__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_definition>();
                a_definition_4({state}, nextStates, state->node);
            }
        }
    
        // definition 	= 'def' <id:identifier> _ '='? <ONL> <val:expression>
        bool n_definition_3__accept(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_definition_3__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_definition_3__accept);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_definition>();
                a_definition_3({state}, nextStates, state->node);
            }
        }
    
        // definition 	= 'def' <id:identifier> _ '='? <ONL> <val:expression>
        bool n_definition_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_definition_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_definition_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // definition 	= 'def' _ <id:identifier> '='? <ONL> <val:expression>
        void a_definition_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_identifier(parentStates, nextStates, &(curNode->nodeLists["id"].emplace_back(nullptr)));
        }
    
        // definition 	= _ 'def' <id:identifier> '='? <ONL> <val:expression>
        bool n_definition_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_definition_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_definition_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // definition
        bool n_definition__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_definition__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_definition__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_definition>();
                a_definition_6({state}, nextStates, state->node);
            }
        }
    
        // definition = 'def' <id:identifier> ':' '\n' _ <contextBodyClosedBlock>
        void a_definition_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextBodyClosedBlock(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // definition = 'def' <id:identifier> ':' _ '\n' <contextBodyClosedBlock>
        bool n_definition_9(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_definition_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_definition_9];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // definition = 'def' <id:identifier> _ ':' '\n' <contextBodyClosedBlock>
        bool n_definition_8(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_definition_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_definition_8];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // definition = 'def' _ <id:identifier> ':' '\n' <contextBodyClosedBlock>
        void a_definition_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_identifier(parentStates, nextStates, &(curNode->nodeLists["id"].emplace_back(nullptr)));
        }
    
        // definition = _ 'def' <id:identifier> ':' '\n' <contextBodyClosedBlock>
        bool n_definition_6(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_definition_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_definition_6];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // varDeclaration
        void a_varDeclaration(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_varDeclaration__poss1(parentStates, nextStates, outputVar);
        }
    
        // varDeclaration
        bool n_varDeclaration__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varDeclaration__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_varDeclaration__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varDeclaration>();
                a_varDeclaration_1({state}, nextStates, state->node);
            }
        }
    
        // varDeclaration 	= 'var' _ <body:varRefDeclBody>
        void a_varDeclaration_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_varRefDeclBody(parentStates, nextStates, &(curNode->nodeLists["body"].emplace_back(nullptr)));
        }
    
        // varDeclaration 	= _ 'var' <body:varRefDeclBody>
        bool n_varDeclaration_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varDeclaration_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_varDeclaration_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // refDeclaration
        void a_refDeclaration(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_refDeclaration__poss1(parentStates, nextStates, outputVar);
        }
    
        // refDeclaration
        bool n_refDeclaration__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_refDeclaration__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_refDeclaration__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_refDeclaration>();
                a_refDeclaration_1({state}, nextStates, state->node);
            }
        }
    
        // refDeclaration 	= 'ref' _ <body:varRefDeclBody>
        void a_refDeclaration_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_varRefDeclBody(parentStates, nextStates, &(curNode->nodeLists["body"].emplace_back(nullptr)));
        }
    
        // refDeclaration 	= _ 'ref' <body:varRefDeclBody>
        bool n_refDeclaration_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_refDeclaration_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_refDeclaration_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // varRefDeclBody
        void a_varRefDeclBody(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_varRefDeclBody__poss1(parentStates, nextStates, outputVar);
        }
    
        // varRefDeclBody
        bool n_varRefDeclBody__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclBody__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclBody__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varRefDeclBody>();
                a_varRefDeclBody_1({state}, nextStates, state->node);
            }
        }
    
        // varRefDeclBody = <items:varRefDeclEntry> _ (',' <ONL> <items:varRefDeclEntry>)*
        void a_varRefDeclBody_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_varRefDeclBody_2__skip(parentStates, nextStates, outputVar);
            a_varRefDeclBody_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // varRefDeclBody = <items:varRefDeclEntry> _ (',' <ONL> <items:varRefDeclEntry>)*
        bool n_varRefDeclBody_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclBody_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_varRefDeclBody_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varRefDeclBody>();
            }
        }
    
        // varRefDeclBody = <items:varRefDeclEntry> _ (',' <ONL> <items:varRefDeclEntry>)*
        bool n_varRefDeclBody_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclBody_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclBody_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varRefDeclBody>();
                a_varRefDeclBody_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // varRefDeclBody = <items:varRefDeclEntry> _ (',' <ONL> <items:varRefDeclEntry>)*
        void a_varRefDeclBody_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_varRefDeclBody_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // varRefDeclBody = <items:varRefDeclEntry> _ (',' <ONL> <items:varRefDeclEntry>)*
        bool n_varRefDeclBody_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclBody_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclBody_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varRefDeclBody>();
                a_varRefDeclBody_3({state}, nextStates, state->node);
            }
        }
    
        // varRefDeclBody = <items:varRefDeclEntry> (',' <ONL> _ <items:varRefDeclEntry>)*
        void a_varRefDeclBody_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_varRefDeclEntry(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // varRefDeclBody = <items:varRefDeclEntry> (',' _ <ONL> <items:varRefDeclEntry>)*
        void a_varRefDeclBody_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // varRefDeclBody = <items:varRefDeclEntry> (_ ',' <ONL> <items:varRefDeclEntry>)*
        bool n_varRefDeclBody_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclBody_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_varRefDeclBody_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // varRefDeclBody = _ <items:varRefDeclEntry> (',' <ONL> <items:varRefDeclEntry>)*
        void a_varRefDeclBody_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_varRefDeclEntry(parentStates, nextStates, &(curNode->nodeLists["items"].emplace_back(nullptr)));
        }
    
        // varRefDeclEntry
        void a_varRefDeclEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_varRefDeclEntry__poss1(parentStates, nextStates, outputVar);
            a_varRefDeclEntry__poss2(parentStates, nextStates, outputVar);
        }
    
        // varRefDeclEntry
        bool n_varRefDeclEntry__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclEntry__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntry__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varRefDeclEntry>();
                a_varRefDeclEntry_1({state}, nextStates, state->node);
            }
        }
    
        // varRefDeclEntry 	= _ <equal:varRefDeclEntryEqual>
        void a_varRefDeclEntry_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_varRefDeclEntryEqual(parentStates, nextStates, &(curNode->nodeLists["equal"].emplace_back(nullptr)));
        }
    
        // varRefDeclEntry
        bool n_varRefDeclEntry__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclEntry__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntry__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varRefDeclEntry>();
                a_varRefDeclEntry_2({state}, nextStates, state->node);
            }
        }
    
        // varRefDeclEntry = _ <assign:varRefDeclEntryAssign>
        void a_varRefDeclEntry_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_varRefDeclEntryAssign(parentStates, nextStates, &(curNode->nodeLists["assign"].emplace_back(nullptr)));
        }
    
        // varRefDeclEntryEqual
        void a_varRefDeclEntryEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_varRefDeclEntryEqual__poss1(parentStates, nextStates, outputVar);
        }
    
        // varRefDeclEntryEqual
        bool n_varRefDeclEntryEqual__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclEntryEqual__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntryEqual__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varRefDeclEntryEqual>();
                a_varRefDeclEntryEqual_1({state}, nextStates, state->node);
            }
        }
    
        // varRefDeclEntryEqual = <id:identifier> '=' <ONL> _ <val:expression>
        void a_varRefDeclEntryEqual_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // varRefDeclEntryEqual = <id:identifier> '=' _ <ONL> <val:expression>
        void a_varRefDeclEntryEqual_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // varRefDeclEntryEqual = <id:identifier> _ '=' <ONL> <val:expression>
        bool n_varRefDeclEntryEqual_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclEntryEqual_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_varRefDeclEntryEqual_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // varRefDeclEntryEqual = _ <id:identifier> '=' <ONL> <val:expression>
        void a_varRefDeclEntryEqual_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_identifier(parentStates, nextStates, &(curNode->nodeLists["id"].emplace_back(nullptr)));
        }
    
        // varRefDeclEntryAssign
        void a_varRefDeclEntryAssign(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_varRefDeclEntryAssign__poss1(parentStates, nextStates, outputVar);
        }
    
        // varRefDeclEntryAssign
        bool n_varRefDeclEntryAssign__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclEntryAssign__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_varRefDeclEntryAssign__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_varRefDeclEntryAssign>();
                a_varRefDeclEntryAssign_1({state}, nextStates, state->node);
            }
        }
    
        // varRefDeclEntryAssign = <id:identifier> '->' <ONL> _ <val:expression>
        void a_varRefDeclEntryAssign_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // varRefDeclEntryAssign = <id:identifier> '->' _ <ONL> <val:expression>
        void a_varRefDeclEntryAssign_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // varRefDeclEntryAssign = <id:identifier> _ '->' <ONL> <val:expression>
        bool n_varRefDeclEntryAssign_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_ASSIGN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_varRefDeclEntryAssign_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_varRefDeclEntryAssign_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // varRefDeclEntryAssign = _ <id:identifier> '->' <ONL> <val:expression>
        void a_varRefDeclEntryAssign_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_identifier(parentStates, nextStates, &(curNode->nodeLists["id"].emplace_back(nullptr)));
        }
    
        // ifStat
        void a_ifStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_ifStat__poss1(parentStates, nextStates, outputVar);
            a_ifStat__poss2(parentStates, nextStates, outputVar);
        }
    
        // ifStat
        bool n_ifStat__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_ifStat__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ifStat>();
                a_ifStat_1({state}, nextStates, state->node);
            }
        }
    
        // ifStat 	= 'if' <cond:expression> ':' <exec1:statement> _ [ <elseStatPart> ]
        void a_ifStat_5__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_ifStat_5__skip(parentStates, nextStates, outputVar);
            a_ifStat_5__accept(parentStates, nextStates, outputVar);
        }
    
        // ifStat 	= 'if' <cond:expression> ':' <exec1:statement> _ [ <elseStatPart> ]
        bool n_ifStat_5__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_5__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_ifStat_5__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ifStat>();
            }
        }
    
        // ifStat 	= 'if' <cond:expression> ':' <exec1:statement> _ [ <elseStatPart> ]
        bool n_ifStat_5__accept(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_5__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_ifStat_5__accept);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ifStat>();
                a_ifStat_5({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // ifStat 	= 'if' <cond:expression> ':' <exec1:statement> _ [ <elseStatPart> ]
        void a_ifStat_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_ifStat_5__poss1(parentStates, nextStates, outputVar);
        }
    
        // ifStat 	= 'if' <cond:expression> ':' <exec1:statement> _ [ <elseStatPart> ]
        bool n_ifStat_5__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_5__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_ifStat_5__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ifStat>();
                a_ifStat_6({state}, nextStates, state->node);
            }
        }
    
        // ifStat 	= 'if' <cond:expression> ':' <exec1:statement> [ _ <elseStatPart> ]
        void a_ifStat_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_elseStatPart(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // ifStat 	= 'if' <cond:expression> ':' _ <exec1:statement> [ <elseStatPart> ]
        void a_ifStat_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_statement(parentStates, nextStates, &(curNode->nodeLists["exec1"].emplace_back(nullptr)));
        }
    
        // ifStat 	= 'if' <cond:expression> _ ':' <exec1:statement> [ <elseStatPart> ]
        bool n_ifStat_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ifStat_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // ifStat 	= 'if' _ <cond:expression> ':' <exec1:statement> [ <elseStatPart> ]
        void a_ifStat_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["cond"].emplace_back(nullptr)));
        }
    
        // ifStat 	= _ 'if' <cond:expression> ':' <exec1:statement> [ <elseStatPart> ]
        bool n_ifStat_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ifStat_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // ifStat
        bool n_ifStat__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_ifStat__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ifStat>();
                a_ifStat_7({state}, nextStates, state->node);
            }
        }
    
        // ifStat = 'if' <cond:expression> ':' '\n' <exec1:contextBody> [ <elseStatPart> ] _ 'ok'
        bool n_ifStat_14(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ifStat_14];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // ifStat = 'if' <cond:expression> ':' '\n' <exec1:contextBody> _ [ <elseStatPart> ] 'ok'
        void a_ifStat_12__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_ifStat_12__skip(parentStates, nextStates, outputVar);
            a_ifStat_12__accept(parentStates, nextStates, outputVar);
        }
    
        // ifStat = 'if' <cond:expression> ':' '\n' <exec1:contextBody> _ [ <elseStatPart> ] 'ok'
        bool n_ifStat_12__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_12__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_ifStat_12__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ifStat>();
                a_ifStat_14({state}, nextStates, state->node);
            }
        }
    
        // ifStat = 'if' <cond:expression> ':' '\n' <exec1:contextBody> _ [ <elseStatPart> ] 'ok'
        bool n_ifStat_12__accept(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_12__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_ifStat_12__accept);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ifStat>();
                a_ifStat_12({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // ifStat = 'if' <cond:expression> ':' '\n' <exec1:contextBody> _ [ <elseStatPart> ] 'ok'
        void a_ifStat_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_ifStat_12__poss1(parentStates, nextStates, outputVar);
        }
    
        // ifStat = 'if' <cond:expression> ':' '\n' <exec1:contextBody> _ [ <elseStatPart> ] 'ok'
        bool n_ifStat_12__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_12__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_ifStat_12__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_ifStat>();
                a_ifStat_13({state}, nextStates, state->node);
            }
        }
    
        // ifStat = 'if' <cond:expression> ':' '\n' <exec1:contextBody> [ _ <elseStatPart> ] 'ok'
        void a_ifStat_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_elseStatPart(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // ifStat = 'if' <cond:expression> ':' '\n' _ <exec1:contextBody> [ <elseStatPart> ] 'ok'
        void a_ifStat_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextBody(parentStates, nextStates, &(curNode->nodeLists["exec1"].emplace_back(nullptr)));
        }
    
        // ifStat = 'if' <cond:expression> ':' _ '\n' <exec1:contextBody> [ <elseStatPart> ] 'ok'
        bool n_ifStat_10(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ifStat_10];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // ifStat = 'if' <cond:expression> _ ':' '\n' <exec1:contextBody> [ <elseStatPart> ] 'ok'
        bool n_ifStat_9(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ifStat_9];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // ifStat = 'if' _ <cond:expression> ':' '\n' <exec1:contextBody> [ <elseStatPart> ] 'ok'
        void a_ifStat_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["cond"].emplace_back(nullptr)));
        }
    
        // ifStat = _ 'if' <cond:expression> ':' '\n' <exec1:contextBody> [ <elseStatPart> ] 'ok'
        bool n_ifStat_7(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_ifStat_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_ifStat_7];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart
        void a_elseStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_elseStatPart__poss1(parentStates, nextStates, outputVar);
            a_elseStatPart__poss2(parentStates, nextStates, outputVar);
            a_elseStatPart__poss3(parentStates, nextStates, outputVar);
            a_elseStatPart__poss4(parentStates, nextStates, outputVar);
        }
    
        // elseStatPart
        bool n_elseStatPart__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_elseStatPart>();
                a_elseStatPart_1({state}, nextStates, state->node);
            }
        }
    
        // elseStatPart 	= 'else' ':' _ <statement>
        void a_elseStatPart_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_statement(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // elseStatPart 	= 'else' _ ':' <statement>
        bool n_elseStatPart_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart 	= _ 'else' ':' <statement>
        bool n_elseStatPart_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart
        bool n_elseStatPart__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_elseStatPart>();
                a_elseStatPart_4({state}, nextStates, state->node);
            }
        }
    
        // elseStatPart = 'else' ':' '\n' _ <contextBody>
        void a_elseStatPart_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextBody(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // elseStatPart = 'else' ':' _ '\n' <contextBody>
        bool n_elseStatPart_6(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_6];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = 'else' _ ':' '\n' <contextBody>
        bool n_elseStatPart_5(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_5];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = _ 'else' ':' '\n' <contextBody>
        bool n_elseStatPart_4(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_4];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart
        bool n_elseStatPart__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_elseStatPart>();
                a_elseStatPart_8({state}, nextStates, state->node);
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' <statement> _ [ <elseStatPart> ]
        void a_elseStatPart_12__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_elseStatPart_12__skip(parentStates, nextStates, outputVar);
            a_elseStatPart_12__accept(parentStates, nextStates, outputVar);
        }
    
        // elseStatPart = 'elif' <expression> ':' <statement> _ [ <elseStatPart> ]
        bool n_elseStatPart_12__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_12__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_12__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_elseStatPart>();
                a_elseStatPart_4({state}, nextStates, state->node);
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' <statement> _ [ <elseStatPart> ]
        bool n_elseStatPart_12__accept(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_12__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_12__accept);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_elseStatPart>();
                a_elseStatPart_12({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' <statement> _ [ <elseStatPart> ]
        void a_elseStatPart_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_elseStatPart_12__poss1(parentStates, nextStates, outputVar);
        }
    
        // elseStatPart = 'elif' <expression> ':' <statement> _ [ <elseStatPart> ]
        bool n_elseStatPart_12__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_12__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_12__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_elseStatPart>();
                a_elseStatPart_13({state}, nextStates, state->node);
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' <statement> [ _ <elseStatPart> ]
        void a_elseStatPart_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_elseStatPart(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // elseStatPart = 'elif' <expression> ':' _ <statement> [ <elseStatPart> ]
        void a_elseStatPart_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_statement(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // elseStatPart = 'elif' <expression> _ ':' <statement> [ <elseStatPart> ]
        bool n_elseStatPart_10(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_10];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = 'elif' _ <expression> ':' <statement> [ <elseStatPart> ]
        void a_elseStatPart_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // elseStatPart = _ 'elif' <expression> ':' <statement> [ <elseStatPart> ]
        bool n_elseStatPart_8(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_8];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart
        bool n_elseStatPart__poss4(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart__poss4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_elseStatPart>();
                a_elseStatPart_14({state}, nextStates, state->node);
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' '\n' <contextBody> [ <elseStatPart> ] _ 'ok'
        bool n_elseStatPart_21(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_21(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_21];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' '\n' <contextBody> _ [ <elseStatPart> ] 'ok'
        void a_elseStatPart_19__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_elseStatPart_19__skip(parentStates, nextStates, outputVar);
            a_elseStatPart_19__accept(parentStates, nextStates, outputVar);
        }
    
        // elseStatPart = 'elif' <expression> ':' '\n' <contextBody> _ [ <elseStatPart> ] 'ok'
        bool n_elseStatPart_19__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_19__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_19__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_elseStatPart>();
                a_elseStatPart_21({state}, nextStates, state->node);
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' '\n' <contextBody> _ [ <elseStatPart> ] 'ok'
        bool n_elseStatPart_19__accept(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_19__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_19__accept);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_elseStatPart>();
                a_elseStatPart_19({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' '\n' <contextBody> _ [ <elseStatPart> ] 'ok'
        void a_elseStatPart_19(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_elseStatPart_19__poss1(parentStates, nextStates, outputVar);
        }
    
        // elseStatPart = 'elif' <expression> ':' '\n' <contextBody> _ [ <elseStatPart> ] 'ok'
        bool n_elseStatPart_19__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_19__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_elseStatPart_19__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_elseStatPart>();
                a_elseStatPart_20({state}, nextStates, state->node);
            }
        }
    
        // elseStatPart = 'elif' <expression> ':' '\n' <contextBody> [ _ <elseStatPart> ] 'ok'
        void a_elseStatPart_20(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_elseStatPart(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // elseStatPart = 'elif' <expression> ':' '\n' _ <contextBody> [ <elseStatPart> ] 'ok'
        void a_elseStatPart_18(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextBody(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // elseStatPart = 'elif' <expression> ':' _ '\n' <contextBody> [ <elseStatPart> ] 'ok'
        bool n_elseStatPart_17(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_NEW_LN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_17(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_17];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = 'elif' <expression> _ ':' '\n' <contextBody> [ <elseStatPart> ] 'ok'
        bool n_elseStatPart_16(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_16(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_16];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // elseStatPart = 'elif' _ <expression> ':' '\n' <contextBody> [ <elseStatPart> ] 'ok'
        void a_elseStatPart_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // elseStatPart = _ 'elif' <expression> ':' '\n' <contextBody> [ <elseStatPart> ] 'ok'
        bool n_elseStatPart_14(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_elseStatPart_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_elseStatPart_14];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // loopStat
        void a_loopStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_loopStat__poss1(parentStates, nextStates, outputVar);
        }
    
        // loopStat
        bool n_loopStat__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_loopStat__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_loopStat>();
                a_loopStat_1({state}, nextStates, state->node);
            }
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> (';' <parts:loopStatPart>)* ':' _ <contextBodyClosedBlock>
        void a_loopStat_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextBodyClosedBlock(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> (';' <parts:loopStatPart>)* _ ':' <contextBodyClosedBlock>
        bool n_loopStat_6(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStat_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_loopStat_6];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> _ (';' <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        void a_loopStat_3__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_loopStat_3__skip(parentStates, nextStates, outputVar);
            a_loopStat_3__cycle(parentStates, nextStates, outputVar);
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> _ (';' <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        bool n_loopStat_3__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStat_3__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_loopStat_3__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_loopStat>();
                a_loopStat_6({state}, nextStates, state->node);
            }
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> _ (';' <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        bool n_loopStat_3__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStat_3__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_loopStat_3__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_loopStat>();
                a_loopStat_3({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> _ (';' <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        void a_loopStat_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_loopStat_3__poss1(parentStates, nextStates, outputVar);
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> _ (';' <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        bool n_loopStat_3__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStat_3__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_loopStat_3__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_loopStat>();
                a_loopStat_4({state}, nextStates, state->node);
            }
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> (';' _ <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        void a_loopStat_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_loopStatPart(parentStates, nextStates, &(curNode->nodeLists["parts"].emplace_back(nullptr)));
        }
    
        // loopStat = 'repeat' <parts:loopStatPart> (_ ';' <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        bool n_loopStat_4(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SEMICOLON)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStat_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_loopStat_4];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // loopStat = 'repeat' _ <parts:loopStatPart> (';' <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        void a_loopStat_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_loopStatPart(parentStates, nextStates, &(curNode->nodeLists["parts"].emplace_back(nullptr)));
        }
    
        // loopStat = _ 'repeat' <parts:loopStatPart> (';' <parts:loopStatPart>)* ':' <contextBodyClosedBlock>
        bool n_loopStat_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_loopStat_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // loopStatPart
        void a_loopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_loopStatPart__poss1(parentStates, nextStates, outputVar);
            a_loopStatPart__poss2(parentStates, nextStates, outputVar);
            a_loopStatPart__poss3(parentStates, nextStates, outputVar);
        }
    
        // loopStatPart
        bool n_loopStatPart__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStatPart__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_loopStatPart__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_loopStatPart>();
                a_loopStatPart_1({state}, nextStates, state->node);
            }
        }
    
        // loopStatPart 	= _ <timesLoopStatPart>
        void a_loopStatPart_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_timesLoopStatPart(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // loopStatPart
        bool n_loopStatPart__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStatPart__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_loopStatPart__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_loopStatPart>();
                a_loopStatPart_2({state}, nextStates, state->node);
            }
        }
    
        // loopStatPart = _ <forLoopStatPart>
        void a_loopStatPart_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_forLoopStatPart(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // loopStatPart
        bool n_loopStatPart__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_loopStatPart__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_loopStatPart__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_loopStatPart>();
                a_loopStatPart_3({state}, nextStates, state->node);
            }
        }
    
        // loopStatPart = _ <whileLoopStatPart>
        void a_loopStatPart_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_whileLoopStatPart(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // timesLoopStatPart
        void a_timesLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_timesLoopStatPart__poss1(parentStates, nextStates, outputVar);
        }
    
        // timesLoopStatPart
        bool n_timesLoopStatPart__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_timesLoopStatPart__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_timesLoopStatPart__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_timesLoopStatPart>();
                a_timesLoopStatPart_1({state}, nextStates, state->node);
            }
        }
    
        // timesLoopStatPart = 'times' _ <count:expression>
        void a_timesLoopStatPart_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["count"].emplace_back(nullptr)));
        }
    
        // timesLoopStatPart = _ 'times' <count:expression>
        bool n_timesLoopStatPart_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_timesLoopStatPart_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_timesLoopStatPart_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // forLoopStatPart
        void a_forLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_forLoopStatPart__poss1(parentStates, nextStates, outputVar);
        }
    
        // forLoopStatPart
        bool n_forLoopStatPart__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_forLoopStatPart__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_forLoopStatPart__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_forLoopStatPart>();
                a_forLoopStatPart_1({state}, nextStates, state->node);
            }
        }
    
        // forLoopStatPart = 'for' <id:identifier> 'in' _ <iterator:expression>
        void a_forLoopStatPart_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["iterator"].emplace_back(nullptr)));
        }
    
        // forLoopStatPart = 'for' <id:identifier> _ 'in' <iterator:expression>
        bool n_forLoopStatPart_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_forLoopStatPart_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_forLoopStatPart_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // forLoopStatPart = 'for' _ <id:identifier> 'in' <iterator:expression>
        void a_forLoopStatPart_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_identifier(parentStates, nextStates, &(curNode->nodeLists["id"].emplace_back(nullptr)));
        }
    
        // forLoopStatPart = _ 'for' <id:identifier> 'in' <iterator:expression>
        bool n_forLoopStatPart_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_forLoopStatPart_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_forLoopStatPart_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // whileLoopStatPart
        void a_whileLoopStatPart(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_whileLoopStatPart__poss1(parentStates, nextStates, outputVar);
        }
    
        // whileLoopStatPart
        bool n_whileLoopStatPart__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_whileLoopStatPart__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_whileLoopStatPart__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_whileLoopStatPart>();
                a_whileLoopStatPart_1({state}, nextStates, state->node);
            }
        }
    
        // whileLoopStatPart = 'while' _ <cond:expression>
        void a_whileLoopStatPart_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["cond"].emplace_back(nullptr)));
        }
    
        // whileLoopStatPart = _ 'while' <cond:expression>
        bool n_whileLoopStatPart_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_whileLoopStatPart_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_whileLoopStatPart_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // jumpStat
        void a_jumpStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_jumpStat__poss1(parentStates, nextStates, outputVar);
            a_jumpStat__poss2(parentStates, nextStates, outputVar);
            a_jumpStat__poss3(parentStates, nextStates, outputVar);
        }
    
        // jumpStat
        bool n_jumpStat__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_jumpStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_jumpStat__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_jumpStat>();
                a_jumpStat_1({state}, nextStates, state->node);
            }
        }
    
        // jumpStat 	= _ <breakStat>
        void a_jumpStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_breakStat(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // jumpStat
        bool n_jumpStat__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_jumpStat__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_jumpStat__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_jumpStat>();
                a_jumpStat_2({state}, nextStates, state->node);
            }
        }
    
        // jumpStat = _ <continueStat>
        void a_jumpStat_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_continueStat(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // jumpStat
        bool n_jumpStat__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_jumpStat__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_jumpStat__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_jumpStat>();
                a_jumpStat_3({state}, nextStates, state->node);
            }
        }
    
        // jumpStat = _ <returnStat>
        void a_jumpStat_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_returnStat(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // breakStat
        void a_breakStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_breakStat__poss1(parentStates, nextStates, outputVar);
        }
    
        // breakStat
        bool n_breakStat__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_breakStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_breakStat__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_breakStat>();
                a_breakStat_1({state}, nextStates, state->node);
            }
        }
    
        // breakStat = _ 'break'
        bool n_breakStat_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_breakStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_breakStat_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // continueStat
        void a_continueStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_continueStat__poss1(parentStates, nextStates, outputVar);
        }
    
        // continueStat
        bool n_continueStat__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_continueStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_continueStat__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_continueStat>();
                a_continueStat_1({state}, nextStates, state->node);
            }
        }
    
        // continueStat = _ 'continue'
        bool n_continueStat_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_continueStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_continueStat_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // returnStat
        void a_returnStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_returnStat__poss1(parentStates, nextStates, outputVar);
        }
    
        // returnStat
        bool n_returnStat__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_returnStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_returnStat__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_returnStat>();
                a_returnStat_1({state}, nextStates, state->node);
            }
        }
    
        // returnStat = 'return' _ [ <val:expression> ]
        void a_returnStat_2__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_returnStat_2__skip(parentStates, nextStates, outputVar);
            a_returnStat_2__accept(parentStates, nextStates, outputVar);
        }
    
        // returnStat = 'return' _ [ <val:expression> ]
        bool n_returnStat_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_returnStat_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_returnStat_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_returnStat>();
            }
        }
    
        // returnStat = 'return' _ [ <val:expression> ]
        bool n_returnStat_2__accept(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_returnStat_2__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_returnStat_2__accept);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_returnStat>();
                a_returnStat_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // returnStat = 'return' _ [ <val:expression> ]
        void a_returnStat_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_returnStat_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // returnStat = 'return' _ [ <val:expression> ]
        bool n_returnStat_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_returnStat_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_returnStat_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_returnStat>();
                a_returnStat_3({state}, nextStates, state->node);
            }
        }
    
        // returnStat = 'return' [ _ <val:expression> ]
        void a_returnStat_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // returnStat = _ 'return' [ <val:expression> ]
        bool n_returnStat_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_returnStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_returnStat_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // withStat
        void a_withStat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_withStat__poss1(parentStates, nextStates, outputVar);
        }
    
        // withStat
        bool n_withStat__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStat__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_withStat__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_withStat>();
                a_withStat_1({state}, nextStates, state->node);
            }
        }
    
        // withStat = 'with' <entries:withStatEntry> [ ',' <entries:withStatEntry> ] ':' _ <contextBodyClosedBlock>
        void a_withStat_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_contextBodyClosedBlock(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // withStat = 'with' <entries:withStatEntry> [ ',' <entries:withStatEntry> ] _ ':' <contextBodyClosedBlock>
        bool n_withStat_6(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COLON)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStat_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_withStat_6];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // withStat = 'with' <entries:withStatEntry> _ [ ',' <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        void a_withStat_3__select(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_withStat_3__skip(parentStates, nextStates, outputVar);
            a_withStat_3__accept(parentStates, nextStates, outputVar);
        }
    
        // withStat = 'with' <entries:withStatEntry> _ [ ',' <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        bool n_withStat_3__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStat_3__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_withStat_3__skip);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_withStat>();
                a_withStat_6({state}, nextStates, state->node);
            }
        }
    
        // withStat = 'with' <entries:withStatEntry> _ [ ',' <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        bool n_withStat_3__accept(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStat_3__accept(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_withStat_3__accept);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_withStat>();
                a_withStat_3({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // withStat = 'with' <entries:withStatEntry> _ [ ',' <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        void a_withStat_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_withStat_3__poss1(parentStates, nextStates, outputVar);
        }
    
        // withStat = 'with' <entries:withStatEntry> _ [ ',' <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        bool n_withStat_3__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStat_3__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_withStat_3__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_withStat>();
                a_withStat_4({state}, nextStates, state->node);
            }
        }
    
        // withStat = 'with' <entries:withStatEntry> [ ',' _ <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        void a_withStat_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_withStatEntry(parentStates, nextStates, &(curNode->nodeLists["entries"].emplace_back(nullptr)));
        }
    
        // withStat = 'with' <entries:withStatEntry> [ _ ',' <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        bool n_withStat_4(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_COMMA)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStat_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_withStat_4];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // withStat = 'with' _ <entries:withStatEntry> [ ',' <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        void a_withStat_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_withStatEntry(parentStates, nextStates, &(curNode->nodeLists["entries"].emplace_back(nullptr)));
        }
    
        // withStat = _ 'with' <entries:withStatEntry> [ ',' <entries:withStatEntry> ] ':' <contextBodyClosedBlock>
        bool n_withStat_1(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_IDENTIFIER)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStat_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_withStat_1];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // withStatEntry
        void a_withStatEntry(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_withStatEntry__poss1(parentStates, nextStates, outputVar);
            a_withStatEntry__poss2(parentStates, nextStates, outputVar);
        }
    
        // withStatEntry
        bool n_withStatEntry__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStatEntry__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_withStatEntry__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_withStatEntry>();
                a_withStatEntry_1({state}, nextStates, state->node);
            }
        }
    
        // withStatEntry 	= <id:identifier> '=' _ <val:expression>
        void a_withStatEntry_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // withStatEntry 	= <id:identifier> _ '=' <val:expression>
        bool n_withStatEntry_2(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStatEntry_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_withStatEntry_2];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // withStatEntry 	= _ <id:identifier> '=' <val:expression>
        void a_withStatEntry_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_identifier(parentStates, nextStates, &(curNode->nodeLists["id"].emplace_back(nullptr)));
        }
    
        // withStatEntry
        bool n_withStatEntry__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_withStatEntry__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_withStatEntry__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_withStatEntry>();
                a_withStatEntry_4({state}, nextStates, state->node);
            }
        }
    
        // withStatEntry = _ <val:expression>
        void a_withStatEntry_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["val"].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        void a_assignmentEqual(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_assignmentEqual__poss1(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss2(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss3(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss4(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss5(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss6(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss7(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss8(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss9(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss10(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss11(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss12(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss13(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss14(parentStates, nextStates, outputVar);
            a_assignmentEqual__poss15(parentStates, nextStates, outputVar);
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_1({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <assignRef>
        void a_assignmentEqual_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_assignRef(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss2(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss2);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_2({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <changeVal>
        void a_assignmentEqual_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_changeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss3(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss3);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_3({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <addChangeVal>
        void a_assignmentEqual_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_addChangeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss4(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss4);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_4({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <subChangeVal>
        void a_assignmentEqual_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_subChangeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss5(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss5);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_5({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <mulChangeVal>
        void a_assignmentEqual_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_mulChangeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss6(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss6);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_6({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <crossChangeVal>
        void a_assignmentEqual_6(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_crossChangeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss7(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss7);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_7({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <dotChangeVal>
        void a_assignmentEqual_7(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_dotChangeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss8(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss8);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_8({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <divChangeVal>
        void a_assignmentEqual_8(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_divChangeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss9(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss9);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_9({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <intDivChangeVal>
        void a_assignmentEqual_9(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_intDivChangeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss10(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss10);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_10({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <modChangeVal>
        void a_assignmentEqual_10(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_modChangeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss11(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss11);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_11({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <shiftRChangeVal>
        void a_assignmentEqual_11(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_shiftRChangeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss12(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss12);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_12({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <shiftLChangeVal>
        void a_assignmentEqual_12(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_shiftLChangeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss13(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss13);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_13({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <andChangeVal>
        void a_assignmentEqual_13(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_andChangeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss14(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss14);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_14({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <orChangeVal>
        void a_assignmentEqual_14(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_orChangeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignmentEqual
        bool n_assignmentEqual__poss15(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignmentEqual__poss15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignmentEqual__poss15);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignmentEqual>();
                a_assignmentEqual_15({state}, nextStates, state->node);
            }
        }
    
        // assignmentEqual = _ <xorChangeVal>
        void a_assignmentEqual_15(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_xorChangeVal(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignRef
        void a_assignRef(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_assignRef__poss1(parentStates, nextStates, outputVar);
        }
    
        // assignRef
        bool n_assignRef__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignRef__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignRef__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignRef>();
                a_assignRef_1({state}, nextStates, state->node);
            }
        }
    
        // assignRef = <left:expression> _ ( '->' <ONL> <rights:expression> )+
        void a_assignRef_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_assignRef_2__skip(parentStates, nextStates, outputVar);
            a_assignRef_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // assignRef = <left:expression> _ ( '->' <ONL> <rights:expression> )+
        bool n_assignRef_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignRef_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_assignRef_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignRef>();
            }
        }
    
        // assignRef = <left:expression> _ ( '->' <ONL> <rights:expression> )+
        bool n_assignRef_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignRef_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignRef_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignRef>();
                a_assignRef_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // assignRef = <left:expression> _ ( '->' <ONL> <rights:expression> )+
        void a_assignRef_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_assignRef_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // assignRef = <left:expression> _ ( '->' <ONL> <rights:expression> )+
        bool n_assignRef_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignRef_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_assignRef_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_assignRef>();
                a_assignRef_3({state}, nextStates, state->node);
            }
        }
    
        // assignRef = <left:expression> ( '->' <ONL> _ <rights:expression> )+
        void a_assignRef_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // assignRef = <left:expression> ( '->' _ <ONL> <rights:expression> )+
        void a_assignRef_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // assignRef = <left:expression> ( _ '->' <ONL> <rights:expression> )+
        bool n_assignRef_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_ASSIGN)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_assignRef_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_assignRef_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // assignRef = _ <left:expression> ( '->' <ONL> <rights:expression> )+
        void a_assignRef_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // changeVal
        void a_changeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_changeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // changeVal
        bool n_changeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_changeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_changeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_changeVal>();
                a_changeVal_1({state}, nextStates, state->node);
            }
        }
    
        // changeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        void a_changeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_changeVal_2__skip(parentStates, nextStates, outputVar);
            a_changeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // changeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        bool n_changeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_changeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_changeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_changeVal>();
            }
        }
    
        // changeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        bool n_changeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_changeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_changeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_changeVal>();
                a_changeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // changeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        void a_changeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_changeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // changeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        bool n_changeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_changeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_changeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_changeVal>();
                a_changeVal_3({state}, nextStates, state->node);
            }
        }
    
        // changeVal = <left:expression> ( '=' <ONL> _ <rights:expression> )+
        void a_changeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // changeVal = <left:expression> ( '=' _ <ONL> <rights:expression> )+
        void a_changeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // changeVal = <left:expression> ( _ '=' <ONL> <rights:expression> )+
        bool n_changeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_changeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_changeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // changeVal = _ <left:expression> ( '=' <ONL> <rights:expression> )+
        void a_changeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // addChangeVal
        void a_addChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_addChangeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // addChangeVal
        bool n_addChangeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_addChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_addChangeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_addChangeVal>();
                a_addChangeVal_1({state}, nextStates, state->node);
            }
        }
    
        // addChangeVal = <left:expression> _ ( '+=' <ONL> <rights:expression> )+
        void a_addChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_addChangeVal_2__skip(parentStates, nextStates, outputVar);
            a_addChangeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // addChangeVal = <left:expression> _ ( '+=' <ONL> <rights:expression> )+
        bool n_addChangeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_addChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_addChangeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_addChangeVal>();
            }
        }
    
        // addChangeVal = <left:expression> _ ( '+=' <ONL> <rights:expression> )+
        bool n_addChangeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_addChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_addChangeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_addChangeVal>();
                a_addChangeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // addChangeVal = <left:expression> _ ( '+=' <ONL> <rights:expression> )+
        void a_addChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_addChangeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // addChangeVal = <left:expression> _ ( '+=' <ONL> <rights:expression> )+
        bool n_addChangeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_addChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_addChangeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_addChangeVal>();
                a_addChangeVal_3({state}, nextStates, state->node);
            }
        }
    
        // addChangeVal = <left:expression> ( '+=' <ONL> _ <rights:expression> )+
        void a_addChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // addChangeVal = <left:expression> ( '+=' _ <ONL> <rights:expression> )+
        void a_addChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // addChangeVal = <left:expression> ( _ '+=' <ONL> <rights:expression> )+
        bool n_addChangeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_ADD_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_addChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_addChangeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // addChangeVal = _ <left:expression> ( '+=' <ONL> <rights:expression> )+
        void a_addChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // subChangeVal
        void a_subChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_subChangeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // subChangeVal
        bool n_subChangeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_subChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_subChangeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_subChangeVal>();
                a_subChangeVal_1({state}, nextStates, state->node);
            }
        }
    
        // subChangeVal = <left:expression> _ ( '-=' <ONL> <rights:expression> )+
        void a_subChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_subChangeVal_2__skip(parentStates, nextStates, outputVar);
            a_subChangeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // subChangeVal = <left:expression> _ ( '-=' <ONL> <rights:expression> )+
        bool n_subChangeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_subChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_subChangeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_subChangeVal>();
            }
        }
    
        // subChangeVal = <left:expression> _ ( '-=' <ONL> <rights:expression> )+
        bool n_subChangeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_subChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_subChangeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_subChangeVal>();
                a_subChangeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // subChangeVal = <left:expression> _ ( '-=' <ONL> <rights:expression> )+
        void a_subChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_subChangeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // subChangeVal = <left:expression> _ ( '-=' <ONL> <rights:expression> )+
        bool n_subChangeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_subChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_subChangeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_subChangeVal>();
                a_subChangeVal_3({state}, nextStates, state->node);
            }
        }
    
        // subChangeVal = <left:expression> ( '-=' <ONL> _ <rights:expression> )+
        void a_subChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // subChangeVal = <left:expression> ( '-=' _ <ONL> <rights:expression> )+
        void a_subChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // subChangeVal = <left:expression> ( _ '-=' <ONL> <rights:expression> )+
        bool n_subChangeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SUB_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_subChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_subChangeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // subChangeVal = _ <left:expression> ( '-=' <ONL> <rights:expression> )+
        void a_subChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // mulChangeVal
        void a_mulChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_mulChangeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // mulChangeVal
        bool n_mulChangeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_mulChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_mulChangeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_mulChangeVal>();
                a_mulChangeVal_1({state}, nextStates, state->node);
            }
        }
    
        // mulChangeVal = <left:expression> _ ( '*=' <ONL> <rights:expression> )+
        void a_mulChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_mulChangeVal_2__skip(parentStates, nextStates, outputVar);
            a_mulChangeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // mulChangeVal = <left:expression> _ ( '*=' <ONL> <rights:expression> )+
        bool n_mulChangeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_mulChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_mulChangeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_mulChangeVal>();
            }
        }
    
        // mulChangeVal = <left:expression> _ ( '*=' <ONL> <rights:expression> )+
        bool n_mulChangeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_mulChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_mulChangeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_mulChangeVal>();
                a_mulChangeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // mulChangeVal = <left:expression> _ ( '*=' <ONL> <rights:expression> )+
        void a_mulChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_mulChangeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // mulChangeVal = <left:expression> _ ( '*=' <ONL> <rights:expression> )+
        bool n_mulChangeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_mulChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_mulChangeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_mulChangeVal>();
                a_mulChangeVal_3({state}, nextStates, state->node);
            }
        }
    
        // mulChangeVal = <left:expression> ( '*=' <ONL> _ <rights:expression> )+
        void a_mulChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // mulChangeVal = <left:expression> ( '*=' _ <ONL> <rights:expression> )+
        void a_mulChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // mulChangeVal = <left:expression> ( _ '*=' <ONL> <rights:expression> )+
        bool n_mulChangeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_MUL_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_mulChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_mulChangeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // mulChangeVal = _ <left:expression> ( '*=' <ONL> <rights:expression> )+
        void a_mulChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // crossChangeVal
        void a_crossChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_crossChangeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // crossChangeVal
        bool n_crossChangeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_crossChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_crossChangeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_crossChangeVal>();
                a_crossChangeVal_1({state}, nextStates, state->node);
            }
        }
    
        // crossChangeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        void a_crossChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_crossChangeVal_2__skip(parentStates, nextStates, outputVar);
            a_crossChangeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // crossChangeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        bool n_crossChangeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_crossChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_crossChangeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_crossChangeVal>();
            }
        }
    
        // crossChangeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        bool n_crossChangeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_crossChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_crossChangeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_crossChangeVal>();
                a_crossChangeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // crossChangeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        void a_crossChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_crossChangeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // crossChangeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        bool n_crossChangeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_crossChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_crossChangeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_crossChangeVal>();
                a_crossChangeVal_3({state}, nextStates, state->node);
            }
        }
    
        // crossChangeVal = <left:expression> ( '=' <ONL> _ <rights:expression> )+
        void a_crossChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // crossChangeVal = <left:expression> ( '=' _ <ONL> <rights:expression> )+
        void a_crossChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // crossChangeVal = <left:expression> ( _ '=' <ONL> <rights:expression> )+
        bool n_crossChangeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_CROSS)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_crossChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_crossChangeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // crossChangeVal = _ <left:expression> ( '=' <ONL> <rights:expression> )+
        void a_crossChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // dotChangeVal
        void a_dotChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_dotChangeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // dotChangeVal
        bool n_dotChangeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dotChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_dotChangeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dotChangeVal>();
                a_dotChangeVal_1({state}, nextStates, state->node);
            }
        }
    
        // dotChangeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        void a_dotChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_dotChangeVal_2__skip(parentStates, nextStates, outputVar);
            a_dotChangeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // dotChangeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        bool n_dotChangeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dotChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_dotChangeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dotChangeVal>();
            }
        }
    
        // dotChangeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        bool n_dotChangeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dotChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_dotChangeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dotChangeVal>();
                a_dotChangeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // dotChangeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        void a_dotChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_dotChangeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // dotChangeVal = <left:expression> _ ( '=' <ONL> <rights:expression> )+
        bool n_dotChangeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dotChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_dotChangeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_dotChangeVal>();
                a_dotChangeVal_3({state}, nextStates, state->node);
            }
        }
    
        // dotChangeVal = <left:expression> ( '=' <ONL> _ <rights:expression> )+
        void a_dotChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // dotChangeVal = <left:expression> ( '=' _ <ONL> <rights:expression> )+
        void a_dotChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // dotChangeVal = <left:expression> ( _ '=' <ONL> <rights:expression> )+
        bool n_dotChangeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_DOT)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_dotChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_dotChangeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // dotChangeVal = _ <left:expression> ( '=' <ONL> <rights:expression> )+
        void a_dotChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // divChangeVal
        void a_divChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_divChangeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // divChangeVal
        bool n_divChangeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_divChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_divChangeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_divChangeVal>();
                a_divChangeVal_1({state}, nextStates, state->node);
            }
        }
    
        // divChangeVal = <left:expression> _ ( '/=' <ONL> <rights:expression> )+
        void a_divChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_divChangeVal_2__skip(parentStates, nextStates, outputVar);
            a_divChangeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // divChangeVal = <left:expression> _ ( '/=' <ONL> <rights:expression> )+
        bool n_divChangeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_divChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_divChangeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_divChangeVal>();
            }
        }
    
        // divChangeVal = <left:expression> _ ( '/=' <ONL> <rights:expression> )+
        bool n_divChangeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_divChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_divChangeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_divChangeVal>();
                a_divChangeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // divChangeVal = <left:expression> _ ( '/=' <ONL> <rights:expression> )+
        void a_divChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_divChangeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // divChangeVal = <left:expression> _ ( '/=' <ONL> <rights:expression> )+
        bool n_divChangeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_divChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_divChangeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_divChangeVal>();
                a_divChangeVal_3({state}, nextStates, state->node);
            }
        }
    
        // divChangeVal = <left:expression> ( '/=' <ONL> _ <rights:expression> )+
        void a_divChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // divChangeVal = <left:expression> ( '/=' _ <ONL> <rights:expression> )+
        void a_divChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // divChangeVal = <left:expression> ( _ '/=' <ONL> <rights:expression> )+
        bool n_divChangeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_DIV_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_divChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_divChangeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // divChangeVal = _ <left:expression> ( '/=' <ONL> <rights:expression> )+
        void a_divChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // intDivChangeVal
        void a_intDivChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_intDivChangeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // intDivChangeVal
        bool n_intDivChangeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_intDivChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_intDivChangeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_intDivChangeVal>();
                a_intDivChangeVal_1({state}, nextStates, state->node);
            }
        }
    
        // intDivChangeVal = <left:expression> _ ( '/%=' <ONL> <rights:expression> )+
        void a_intDivChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_intDivChangeVal_2__skip(parentStates, nextStates, outputVar);
            a_intDivChangeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // intDivChangeVal = <left:expression> _ ( '/%=' <ONL> <rights:expression> )+
        bool n_intDivChangeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_intDivChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_intDivChangeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_intDivChangeVal>();
            }
        }
    
        // intDivChangeVal = <left:expression> _ ( '/%=' <ONL> <rights:expression> )+
        bool n_intDivChangeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_intDivChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_intDivChangeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_intDivChangeVal>();
                a_intDivChangeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // intDivChangeVal = <left:expression> _ ( '/%=' <ONL> <rights:expression> )+
        void a_intDivChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_intDivChangeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // intDivChangeVal = <left:expression> _ ( '/%=' <ONL> <rights:expression> )+
        bool n_intDivChangeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_intDivChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_intDivChangeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_intDivChangeVal>();
                a_intDivChangeVal_3({state}, nextStates, state->node);
            }
        }
    
        // intDivChangeVal = <left:expression> ( '/%=' <ONL> _ <rights:expression> )+
        void a_intDivChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // intDivChangeVal = <left:expression> ( '/%=' _ <ONL> <rights:expression> )+
        void a_intDivChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // intDivChangeVal = <left:expression> ( _ '/%=' <ONL> <rights:expression> )+
        bool n_intDivChangeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_INT_DIV_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_intDivChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_intDivChangeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // intDivChangeVal = _ <left:expression> ( '/%=' <ONL> <rights:expression> )+
        void a_intDivChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // modChangeVal
        void a_modChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_modChangeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // modChangeVal
        bool n_modChangeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_modChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_modChangeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_modChangeVal>();
                a_modChangeVal_1({state}, nextStates, state->node);
            }
        }
    
        // modChangeVal = <left:expression> _ ( '%=' <ONL> <rights:expression> )+
        void a_modChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_modChangeVal_2__skip(parentStates, nextStates, outputVar);
            a_modChangeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // modChangeVal = <left:expression> _ ( '%=' <ONL> <rights:expression> )+
        bool n_modChangeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_modChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_modChangeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_modChangeVal>();
            }
        }
    
        // modChangeVal = <left:expression> _ ( '%=' <ONL> <rights:expression> )+
        bool n_modChangeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_modChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_modChangeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_modChangeVal>();
                a_modChangeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // modChangeVal = <left:expression> _ ( '%=' <ONL> <rights:expression> )+
        void a_modChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_modChangeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // modChangeVal = <left:expression> _ ( '%=' <ONL> <rights:expression> )+
        bool n_modChangeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_modChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_modChangeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_modChangeVal>();
                a_modChangeVal_3({state}, nextStates, state->node);
            }
        }
    
        // modChangeVal = <left:expression> ( '%=' <ONL> _ <rights:expression> )+
        void a_modChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // modChangeVal = <left:expression> ( '%=' _ <ONL> <rights:expression> )+
        void a_modChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // modChangeVal = <left:expression> ( _ '%=' <ONL> <rights:expression> )+
        bool n_modChangeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_MOD_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_modChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_modChangeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // modChangeVal = _ <left:expression> ( '%=' <ONL> <rights:expression> )+
        void a_modChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // shiftRChangeVal
        void a_shiftRChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_shiftRChangeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // shiftRChangeVal
        bool n_shiftRChangeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftRChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_shiftRChangeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftRChangeVal>();
                a_shiftRChangeVal_1({state}, nextStates, state->node);
            }
        }
    
        // shiftRChangeVal = <left:expression> _ ( '>>=' <ONL> <rights:expression> )+
        void a_shiftRChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_shiftRChangeVal_2__skip(parentStates, nextStates, outputVar);
            a_shiftRChangeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // shiftRChangeVal = <left:expression> _ ( '>>=' <ONL> <rights:expression> )+
        bool n_shiftRChangeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftRChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_shiftRChangeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftRChangeVal>();
            }
        }
    
        // shiftRChangeVal = <left:expression> _ ( '>>=' <ONL> <rights:expression> )+
        bool n_shiftRChangeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftRChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_shiftRChangeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftRChangeVal>();
                a_shiftRChangeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // shiftRChangeVal = <left:expression> _ ( '>>=' <ONL> <rights:expression> )+
        void a_shiftRChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_shiftRChangeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // shiftRChangeVal = <left:expression> _ ( '>>=' <ONL> <rights:expression> )+
        bool n_shiftRChangeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftRChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_shiftRChangeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftRChangeVal>();
                a_shiftRChangeVal_3({state}, nextStates, state->node);
            }
        }
    
        // shiftRChangeVal = <left:expression> ( '>>=' <ONL> _ <rights:expression> )+
        void a_shiftRChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // shiftRChangeVal = <left:expression> ( '>>=' _ <ONL> <rights:expression> )+
        void a_shiftRChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // shiftRChangeVal = <left:expression> ( _ '>>=' <ONL> <rights:expression> )+
        bool n_shiftRChangeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SHIFT_RIGHT_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftRChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_shiftRChangeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // shiftRChangeVal = _ <left:expression> ( '>>=' <ONL> <rights:expression> )+
        void a_shiftRChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // shiftLChangeVal
        void a_shiftLChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_shiftLChangeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // shiftLChangeVal
        bool n_shiftLChangeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftLChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_shiftLChangeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftLChangeVal>();
                a_shiftLChangeVal_1({state}, nextStates, state->node);
            }
        }
    
        // shiftLChangeVal = <left:expression> _ ( '<<=' <ONL> <rights:expression> )+
        void a_shiftLChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_shiftLChangeVal_2__skip(parentStates, nextStates, outputVar);
            a_shiftLChangeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // shiftLChangeVal = <left:expression> _ ( '<<=' <ONL> <rights:expression> )+
        bool n_shiftLChangeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftLChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_shiftLChangeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftLChangeVal>();
            }
        }
    
        // shiftLChangeVal = <left:expression> _ ( '<<=' <ONL> <rights:expression> )+
        bool n_shiftLChangeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftLChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_shiftLChangeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftLChangeVal>();
                a_shiftLChangeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // shiftLChangeVal = <left:expression> _ ( '<<=' <ONL> <rights:expression> )+
        void a_shiftLChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_shiftLChangeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // shiftLChangeVal = <left:expression> _ ( '<<=' <ONL> <rights:expression> )+
        bool n_shiftLChangeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftLChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_shiftLChangeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_shiftLChangeVal>();
                a_shiftLChangeVal_3({state}, nextStates, state->node);
            }
        }
    
        // shiftLChangeVal = <left:expression> ( '<<=' <ONL> _ <rights:expression> )+
        void a_shiftLChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // shiftLChangeVal = <left:expression> ( '<<=' _ <ONL> <rights:expression> )+
        void a_shiftLChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // shiftLChangeVal = <left:expression> ( _ '<<=' <ONL> <rights:expression> )+
        bool n_shiftLChangeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_SHIFT_LEFT_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_shiftLChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_shiftLChangeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // shiftLChangeVal = _ <left:expression> ( '<<=' <ONL> <rights:expression> )+
        void a_shiftLChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // andChangeVal
        void a_andChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_andChangeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // andChangeVal
        bool n_andChangeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_andChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_andChangeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_andChangeVal>();
                a_andChangeVal_1({state}, nextStates, state->node);
            }
        }
    
        // andChangeVal = <left:expression> _ ( '&=' <ONL> <rights:expression> )+
        void a_andChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_andChangeVal_2__skip(parentStates, nextStates, outputVar);
            a_andChangeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // andChangeVal = <left:expression> _ ( '&=' <ONL> <rights:expression> )+
        bool n_andChangeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_andChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_andChangeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_andChangeVal>();
            }
        }
    
        // andChangeVal = <left:expression> _ ( '&=' <ONL> <rights:expression> )+
        bool n_andChangeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_andChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_andChangeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_andChangeVal>();
                a_andChangeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // andChangeVal = <left:expression> _ ( '&=' <ONL> <rights:expression> )+
        void a_andChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_andChangeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // andChangeVal = <left:expression> _ ( '&=' <ONL> <rights:expression> )+
        bool n_andChangeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_andChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_andChangeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_andChangeVal>();
                a_andChangeVal_3({state}, nextStates, state->node);
            }
        }
    
        // andChangeVal = <left:expression> ( '&=' <ONL> _ <rights:expression> )+
        void a_andChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // andChangeVal = <left:expression> ( '&=' _ <ONL> <rights:expression> )+
        void a_andChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // andChangeVal = <left:expression> ( _ '&=' <ONL> <rights:expression> )+
        bool n_andChangeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_AND_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_andChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_andChangeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // andChangeVal = _ <left:expression> ( '&=' <ONL> <rights:expression> )+
        void a_andChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // orChangeVal
        void a_orChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_orChangeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // orChangeVal
        bool n_orChangeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_orChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_orChangeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_orChangeVal>();
                a_orChangeVal_1({state}, nextStates, state->node);
            }
        }
    
        // orChangeVal = <left:expression> _ ( '|=' <ONL> <rights:expression> )+
        void a_orChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_orChangeVal_2__skip(parentStates, nextStates, outputVar);
            a_orChangeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // orChangeVal = <left:expression> _ ( '|=' <ONL> <rights:expression> )+
        bool n_orChangeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_orChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_orChangeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_orChangeVal>();
            }
        }
    
        // orChangeVal = <left:expression> _ ( '|=' <ONL> <rights:expression> )+
        bool n_orChangeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_orChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_orChangeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_orChangeVal>();
                a_orChangeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // orChangeVal = <left:expression> _ ( '|=' <ONL> <rights:expression> )+
        void a_orChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_orChangeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // orChangeVal = <left:expression> _ ( '|=' <ONL> <rights:expression> )+
        bool n_orChangeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_orChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_orChangeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_orChangeVal>();
                a_orChangeVal_3({state}, nextStates, state->node);
            }
        }
    
        // orChangeVal = <left:expression> ( '|=' <ONL> _ <rights:expression> )+
        void a_orChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // orChangeVal = <left:expression> ( '|=' _ <ONL> <rights:expression> )+
        void a_orChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // orChangeVal = <left:expression> ( _ '|=' <ONL> <rights:expression> )+
        bool n_orChangeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_OR_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_orChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_orChangeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // orChangeVal = _ <left:expression> ( '|=' <ONL> <rights:expression> )+
        void a_orChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    
        // xorChangeVal
        void a_xorChangeVal(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_xorChangeVal__poss1(parentStates, nextStates, outputVar);
        }
    
        // xorChangeVal
        bool n_xorChangeVal__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_xorChangeVal__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_xorChangeVal__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_xorChangeVal>();
                a_xorChangeVal_1({state}, nextStates, state->node);
            }
        }
    
        // xorChangeVal = <left:expression> _ ( '^=' <ONL> <rights:expression> )+
        void a_xorChangeVal_2__repeat(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_xorChangeVal_2__skip(parentStates, nextStates, outputVar);
            a_xorChangeVal_2__cycle(parentStates, nextStates, outputVar);
        }
    
        // xorChangeVal = <left:expression> _ ( '^=' <ONL> <rights:expression> )+
        bool n_xorChangeVal_2__skip(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_xorChangeVal_2__skip(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates[&n_xorChangeVal_2__skip];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_xorChangeVal>();
            }
        }
    
        // xorChangeVal = <left:expression> _ ( '^=' <ONL> <rights:expression> )+
        bool n_xorChangeVal_2__cycle(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_xorChangeVal_2__cycle(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_xorChangeVal_2__cycle);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_xorChangeVal>();
                a_xorChangeVal_2({state}, nextStates, &(state->node->continuationNode));
            }
        }
    
        // xorChangeVal = <left:expression> _ ( '^=' <ONL> <rights:expression> )+
        void a_xorChangeVal_2(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            a_xorChangeVal_2__poss1(parentStates, nextStates, outputVar);
        }
    
        // xorChangeVal = <left:expression> _ ( '^=' <ONL> <rights:expression> )+
        bool n_xorChangeVal_2__poss1(StatePtr curState, StateSet& nextStates, const Token& token) {
            for (auto var : curState->outputVars) *var = curState->node;
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_xorChangeVal_2__poss1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr* outputVar) {
            StatePtr state = nextStates.getHidden(&n_xorChangeVal_2__poss1);
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            state->outputVars.push_back(outputVar);
            if (state->node == nullptr) {// The state is newly added
                state->node = std::make_shared<ParseNode_xorChangeVal>();
                a_xorChangeVal_3({state}, nextStates, state->node);
            }
        }
    
        // xorChangeVal = <left:expression> ( '^=' <ONL> _ <rights:expression> )+
        void a_xorChangeVal_5(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["rights"].emplace_back(nullptr)));
        }
    
        // xorChangeVal = <left:expression> ( '^=' _ <ONL> <rights:expression> )+
        void a_xorChangeVal_4(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_ONL(parentStates, nextStates, &(curNode->nodeLists[""].emplace_back(nullptr)));
        }
    
        // xorChangeVal = <left:expression> ( _ '^=' <ONL> <rights:expression> )+
        bool n_xorChangeVal_3(StatePtr curState, StateSet& nextStates, const Token& token) {
            if (token.type != TokenType::L_XOR_CHANGE)
                return false;
            curState->node->tokenLists[""].push_back(token);
            for (auto par : curState->parentStates) par->nextFunc(par, nextStates, token);
            return true;
        }
        void a_xorChangeVal_3(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            StatePtr state = nextStates[&n_xorChangeVal_3];
            state->parentStates.insert(parentStates.begin(), parentStates.end());
            if (state->node == nullptr) {// The state is newly added
                state->node = curNode;
            }
        }
    
        // xorChangeVal = _ <left:expression> ( '^=' <ONL> <rights:expression> )+
        void a_xorChangeVal_1(const std::set<StatePtr>& parentStates, StateSet& nextStates, ParseNodePtr curNode) {
            a_expression(parentStates, nextStates, &(curNode->nodeLists["left"].emplace_back(nullptr)));
        }
    }
    
    ParseNode::~ParseNode() {
    };
    void ParseNode::process() {
    };
    
    void ParseNode::pullFrom(ParseNode& other) {
        for (auto& varNodesPair : other.nodeLists) {
            const std::string &varName = varNodesPair.first;
            auto &otherList = varNodesPair.second;
            auto &myList = nodeLists[varName];
            myList.splice(otherList.begin(), otherList);
        }
        for (auto& varTokensPair : other.tokenLists) {
            const std::string &varName = varTokensPair.first;
            auto &otherList = varTokensPair.second;
            auto &myList = tokenLists[varName];
            otherList.splice(myList.begin(), myList);
        }
    };
    
    ParseNode_file::~ParseNode_file() {}
    ParseNode_ONL::~ParseNode_ONL() {}
    ParseNode_contextBody::~ParseNode_contextBody() {}
    ParseNode_contextBodyClosedBlock::~ParseNode_contextBodyClosedBlock() {}
    ParseNode_contextDescriptionEntry::~ParseNode_contextDescriptionEntry() {}
    ParseNode_traitAssertion::~ParseNode_traitAssertion() {}
    ParseNode_expression::~ParseNode_expression() {}
    ParseNode_expr0::~ParseNode_expr0() {}
    ParseNode_identifier::~ParseNode_identifier() {}
    ParseNode_suffixFunction::~ParseNode_suffixFunction() {}
    ParseNode_expr1::~ParseNode_expr1() {}
    ParseNode_suffixInc::~ParseNode_suffixInc() {}
    ParseNode_suffixDec::~ParseNode_suffixDec() {}
    ParseNode_copy::~ParseNode_copy() {}
    ParseNode_prefixFunction::~ParseNode_prefixFunction() {}
    ParseNode_expr2::~ParseNode_expr2() {}
    ParseNode_prefixInc::~ParseNode_prefixInc() {}
    ParseNode_prefixDec::~ParseNode_prefixDec() {}
    ParseNode_plus::~ParseNode_plus() {}
    ParseNode_minus::~ParseNode_minus() {}
    ParseNode_logNot::~ParseNode_logNot() {}
    ParseNode_expr3::~ParseNode_expr3() {}
    ParseNode_multiplication::~ParseNode_multiplication() {}
    ParseNode_crossProduct::~ParseNode_crossProduct() {}
    ParseNode_dotProduct::~ParseNode_dotProduct() {}
    ParseNode_division::~ParseNode_division() {}
    ParseNode_divisionInt::~ParseNode_divisionInt() {}
    ParseNode_modulo::~ParseNode_modulo() {}
    ParseNode_expr4::~ParseNode_expr4() {}
    ParseNode_addition::~ParseNode_addition() {}
    ParseNode_subtraction::~ParseNode_subtraction() {}
    ParseNode_expr5::~ParseNode_expr5() {}
    ParseNode_shiftL::~ParseNode_shiftL() {}
    ParseNode_shiftR::~ParseNode_shiftR() {}
    ParseNode_expr6::~ParseNode_expr6() {}
    ParseNode_compLess::~ParseNode_compLess() {}
    ParseNode_compGreat::~ParseNode_compGreat() {}
    ParseNode_compLeEq::~ParseNode_compLeEq() {}
    ParseNode_compGrEq::~ParseNode_compGrEq() {}
    ParseNode_expr7::~ParseNode_expr7() {}
    ParseNode_compEqual::~ParseNode_compEqual() {}
    ParseNode_compNotEq::~ParseNode_compNotEq() {}
    ParseNode_compAssigned::~ParseNode_compAssigned() {}
    ParseNode_compNotAss::~ParseNode_compNotAss() {}
    ParseNode_expr8::~ParseNode_expr8() {}
    ParseNode_logAnd::~ParseNode_logAnd() {}
    ParseNode_expr9::~ParseNode_expr9() {}
    ParseNode_logXOr::~ParseNode_logXOr() {}
    ParseNode_expr10::~ParseNode_expr10() {}
    ParseNode_logOr::~ParseNode_logOr() {}
    ParseNode_exprLeast::~ParseNode_exprLeast() {}
    ParseNode_literal::~ParseNode_literal() {}
    ParseNode_valueLiteral::~ParseNode_valueLiteral() {}
    ParseNode_listLiteral::~ParseNode_listLiteral() {}
    ParseNode_setLiteral::~ParseNode_setLiteral() {}
    ParseNode_dictLiteral::~ParseNode_dictLiteral() {}
    ParseNode_dictEntry::~ParseNode_dictEntry() {}
    ParseNode_contextLiteral::~ParseNode_contextLiteral() {}
    ParseNode_memberDecl::~ParseNode_memberDecl() {}
    ParseNode_statement::~ParseNode_statement() {}
    ParseNode_definition::~ParseNode_definition() {}
    ParseNode_varDeclaration::~ParseNode_varDeclaration() {}
    ParseNode_refDeclaration::~ParseNode_refDeclaration() {}
    ParseNode_varRefDeclBody::~ParseNode_varRefDeclBody() {}
    ParseNode_varRefDeclEntry::~ParseNode_varRefDeclEntry() {}
    ParseNode_varRefDeclEntryEqual::~ParseNode_varRefDeclEntryEqual() {}
    ParseNode_varRefDeclEntryAssign::~ParseNode_varRefDeclEntryAssign() {}
    ParseNode_ifStat::~ParseNode_ifStat() {}
    ParseNode_elseStatPart::~ParseNode_elseStatPart() {}
    ParseNode_loopStat::~ParseNode_loopStat() {}
    ParseNode_loopStatPart::~ParseNode_loopStatPart() {}
    ParseNode_timesLoopStatPart::~ParseNode_timesLoopStatPart() {}
    ParseNode_forLoopStatPart::~ParseNode_forLoopStatPart() {}
    ParseNode_whileLoopStatPart::~ParseNode_whileLoopStatPart() {}
    ParseNode_jumpStat::~ParseNode_jumpStat() {}
    ParseNode_breakStat::~ParseNode_breakStat() {}
    ParseNode_continueStat::~ParseNode_continueStat() {}
    ParseNode_returnStat::~ParseNode_returnStat() {}
    ParseNode_withStat::~ParseNode_withStat() {}
    ParseNode_withStatEntry::~ParseNode_withStatEntry() {}
    ParseNode_assignmentEqual::~ParseNode_assignmentEqual() {}
    ParseNode_assignRef::~ParseNode_assignRef() {}
    ParseNode_changeVal::~ParseNode_changeVal() {}
    ParseNode_addChangeVal::~ParseNode_addChangeVal() {}
    ParseNode_subChangeVal::~ParseNode_subChangeVal() {}
    ParseNode_mulChangeVal::~ParseNode_mulChangeVal() {}
    ParseNode_crossChangeVal::~ParseNode_crossChangeVal() {}
    ParseNode_dotChangeVal::~ParseNode_dotChangeVal() {}
    ParseNode_divChangeVal::~ParseNode_divChangeVal() {}
    ParseNode_intDivChangeVal::~ParseNode_intDivChangeVal() {}
    ParseNode_modChangeVal::~ParseNode_modChangeVal() {}
    ParseNode_shiftRChangeVal::~ParseNode_shiftRChangeVal() {}
    ParseNode_shiftLChangeVal::~ParseNode_shiftLChangeVal() {}
    ParseNode_andChangeVal::~ParseNode_andChangeVal() {}
    ParseNode_orChangeVal::~ParseNode_orChangeVal() {}
    ParseNode_xorChangeVal::~ParseNode_xorChangeVal() {}

    ParseNodePtr parse(const std::list<Token> &input, std::list<ParserError>& outErrors)
    {
        ParseNodePtr res = std::make_shared<ParseNode_file>();;
        StateSet curStates, nextStates;
        
        a_file({}, nextStates, &(res->continuationNode));
        
        auto tokenIt = input.begin();
        while (nextStates.size() > 0) {
            curStates.stdSet = nextStates.stdSet;
            nextStates.stdSetHidden.clear();
            nextStates.stdSet.clear();
            for (auto& state : curStates) {
                state->nextFunc(state, nextStates, *tokenIt);
            }
            std::wcout << "Parsed " << tokenIt->line << L", position " << tokenIt->character << L", token " << tokenIt->str << std::endl;
            tokenIt++;
            if (tokenIt == input.end()) {outErrors.emplace_back(Token(), L"Parser reached the end of token list."); break;}
        }
        return res;
    }

}
