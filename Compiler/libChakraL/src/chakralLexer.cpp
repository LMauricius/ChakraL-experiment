// This file is autogenerated. Do not edit!

#include "ctre-unicode.hpp"
#include "chakralLexer.h"
#include <vector>
#include <string_view>
#include <sstream>
#include <iostream>

namespace
{
}
namespace ChakraL
{
    const std::array<std::string, 93> TokenNames {
        "L_IDENTIFIER",
        "L_NUM_LIT",
        "L_NUM_B_LIT",
        "L_NUM_O_LIT",
        "L_NUM_X_LIT",
        "L_STR_LIT",
        "L_CHAR_LIT",
        "L_NEW_LN",
        "L_COMMA",
        "L_SEMICOLON",
        "L_COLON",
        "L_OK",
        "L_IN",
        "L_ADD",
        "L_SUB",
        "L_MUL",
        "L_DIV",
        "L_INT_DIV",
        "L_MOD",
        "L_SHIFT_RIGHT",
        "L_SHIFT_LEFT",
        "L_AND",
        "L_OR",
        "L_XOR",
        "L_CROSS",
        "L_DOT",
        "L_CHANGE",
        "L_ASSIGN",
        "L_ADD_CHANGE",
        "L_INCREMENT",
        "L_DECREMENT",
        "L_SUB_CHANGE",
        "L_MUL_CHANGE",
        "L_DIV_CHANGE",
        "L_INT_DIV_CHANGE",
        "L_MOD_CHANGE",
        "L_SHIFT_RIGHT_CHANGE",
        "L_SHIFT_LEFT_CHANGE",
        "L_AND_CHANGE",
        "L_OR_CHANGE",
        "L_XOR_CHANGE",
        "L_CROSS_CHANGE",
        "L_DOT_CHANGE",
        "L_NOT",
        "L_EQUAL",
        "L_NOTEQ",
        "L_ASSIGNED",
        "L_NOTASS",
        "L_LESS",
        "L_GREAT",
        "L_LEEQ",
        "L_GREQ",
        "L_TRAIT_AND",
        "L_TRAIT_OR",
        "L_TRAIT_AND_COND",
        "L_TRAIT_COND",
        "L_QUEST",
        "L_LEFT_PAR",
        "L_RIGHT_PAR",
        "L_LEFT_BRACK",
        "L_RIGHT_BRACK",
        "L_LEFT_BRACE",
        "L_RIGHT_BRACE",
        "L_MEMBER",
        "L_FUNCTION",
        "L_COROUTINE",
        "L_IF",
        "L_ELSE",
        "L_ELIF",
        "L_SWITCH",
        "L_CASE",
        "L_TIMES",
        "L_FOR",
        "L_WHILE",
        "L_REPEAT",
        "L_BREAK",
        "L_CONTINUE",
        "L_RETURN",
        "L_YIELD",
        "L_WITH",
        "L_DEF",
        "L_CONST",
        "L_VAR",
        "L_REF",
        "L_NEW",
        "L_FINAL",
        "L_MUTABLE",
        "L_VOLATILE",
        "L_STATIC",
        "L_USING",
        "L_INCLUDE",
        "L_AS",
        "L_LIT_SUFFIX",
    };

    std::list<Token> tokenize(const std::wstring &input, std::list<LexerError>& outErrors)
    {
        int line = 1, character = 1;
        int start = 0, maxEnd = -1;
        std::vector<LexerState> states = {{LexerState::S_START}};
        std::list<Token> ret;
        
        while (start < input.size())
        {
            int choosenRuleInd = -1;
            bool movePtr = true;
            std::wstring_view matchStr;
            
            switch (states.back())
            {
            case LexerState::S_START:
                
                // *** choose rule ***
                if (auto res = ctre::starts_with<
                        L"([a-zA-Z][a-zA-Z0-9_]*)"
                        L"|([0-9]+(_[0-9]|[0-9])*(\\.[0-9]+)?)"
                        L"|(0b[01]([_01]|[01])*(\\.[_01]+)?)"
                        L"|(0o[0-7]([_0-7]|[0-7])*(\\.[_0-7]+)?)"
                        L"|(0x[A-Fa-f0-9]([_A-Fa-f0-9]|[A-Fa-f0-9])*(\\.[_A-Fa-f0-9]+)?)"
                        L"|(\"([^\\\\\"]|\\\\.)*\")"
                        L"|(\'([^\\\\\']|\\\\.)\')"
                        L"|(\\n)"
                        L"|([ \\t])"
                        L"|(//)"
                        L"|(/\\*)"
                        L"|(,)"
                        L"|(;)"
                        L"|(:)"
                        L"|(ok)"
                        L"|(in)"
                        L"|(\\+)"
                        L"|(\\-)"
                        L"|(\\*)"
                        L"|(/)"
                        L"|(/%)"
                        L"|(%)"
                        L"|(>>)"
                        L"|(<<)"
                        L"|(&)"
                        L"|(\\|)"
                        L"|(\\^)"
                        L"|(×|\\\\cross)"
                        L"|(⋅|\\\\dot)"
                        L"|([=])"
                        L"|(\\->)"
                        L"|(\\+[=])"
                        L"|(\\+\\+)"
                        L"|(--)"
                        L"|(\\-[=])"
                        L"|(\\*[=])"
                        L"|(/[=])"
                        L"|(/%[=])"
                        L"|(%[=])"
                        L"|(>>[=])"
                        L"|(<<[=])"
                        L"|(&[=])"
                        L"|(\\|[=])"
                        L"|(\\^[=])"
                        L"|(×|\\\\cross)"
                        L"|(⋅|\\\\dot)"
                        L"|(!)"
                        L"|(\\?[=])"
                        L"|(![=])"
                        L"|(\\?\\->)"
                        L"|(!\\->)"
                        L"|(<)"
                        L"|(>)"
                        L"|(<[=])"
                        L"|(>[=])"
                        L"|(\\+&)"
                        L"|(\\+\\|)"
                        L"|(\\+\\?)"
                        L"|(\\?\\?)"
                        L"|(\\?)"
                        L"|(\\()"
                        L"|(\\))"
                        L"|(\\[)"
                        L"|(\\])"
                        L"|(\\{)"
                        L"|(\\})"
                        L"|(\\.)"
                        L"|([=]>)"
                        L"|(<[=]>)"
                        L"|(if)"
                        L"|(else)"
                        L"|(elif)"
                        L"|(switch)"
                        L"|(case)"
                        L"|(times)"
                        L"|(for)"
                        L"|(while)"
                        L"|(repeat)"
                        L"|(break)"
                        L"|(continue)"
                        L"|(return)"
                        L"|(yield)"
                        L"|(with)"
                        L"|(def)"
                        L"|(const)"
                        L"|(var)"
                        L"|(ref)"
                        L"|(new)"
                        L"|(final)"
                        L"|(mutable)"
                        L"|(volatile)"
                        L"|(static)"
                        L"|(using)"
                        L"|(include)"
                        L"|(as)"
                    >(std::wstring_view(input.begin()+start, input.end())); res)
                {
                    if (const auto& subRes = res.get<1>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 1;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<2>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 2;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<3>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 3;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<4>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 4;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<5>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 5;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<6>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 6;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<7>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 7;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<8>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 8;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<9>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 9;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<10>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 10;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<11>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 11;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<12>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 12;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<13>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 13;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<14>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 14;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<15>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 15;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<16>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 16;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<17>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 17;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<18>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 18;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<19>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 19;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<20>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 20;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<21>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 21;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<22>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 22;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<23>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 23;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<24>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 24;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<25>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 25;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<26>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 26;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<27>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 27;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<28>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 28;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<29>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 29;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<30>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 30;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<31>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 31;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<32>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 32;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<33>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 33;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<34>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 34;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<35>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 35;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<36>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 36;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<37>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 37;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<38>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 38;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<39>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 39;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<40>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 40;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<41>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 41;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<42>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 42;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<43>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 43;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<44>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 44;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<45>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 45;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<46>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 46;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<47>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 47;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<48>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 48;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<49>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 49;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<50>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 50;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<51>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 51;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<52>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 52;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<53>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 53;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<54>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 54;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<55>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 55;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<56>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 56;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<57>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 57;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<58>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 58;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<59>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 59;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<60>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 60;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<61>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 61;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<62>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 62;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<63>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 63;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<64>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 64;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<65>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 65;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<66>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 66;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<67>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 67;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<68>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 68;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<69>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 69;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<70>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 70;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<71>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 71;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<72>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 72;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<73>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 73;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<74>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 74;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<75>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 75;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<76>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 76;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<77>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 77;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<78>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 78;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<79>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 79;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<80>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 80;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<81>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 81;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<82>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 82;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<83>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 83;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<84>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 84;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<85>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 85;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<86>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 86;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<87>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 87;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<88>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 88;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<89>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 89;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<90>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 90;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<91>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 91;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<92>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 92;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<93>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 93;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<94>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 94;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<95>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 95;
                        maxEnd = start + res.size();
                    }
                }
                
                // *** execute rule commands ***
                switch (choosenRuleInd)
                {
                case 1:// [a-zA-Z][a-zA-Z0-9_]*
                    ret.push_back(Token{TokenType::L_IDENTIFIER, input.substr(start, maxEnd-start), line, character});
                    break;
                case 2:// [0-9]+(_[0-9]|[0-9])*(\.[0-9]+)?
                    ret.push_back(Token{TokenType::L_NUM_LIT, input.substr(start, maxEnd-start), line, character});
                    states.push_back(LexerState::S_LITERAL);
                    break;
                case 3:// 0b[01]([_01]|[01])*(\.[_01]+)?
                    ret.push_back(Token{TokenType::L_NUM_B_LIT, input.substr(start, maxEnd-start), line, character});
                    states.push_back(LexerState::S_LITERAL);
                    break;
                case 4:// 0o[0-7]([_0-7]|[0-7])*(\.[_0-7]+)?
                    ret.push_back(Token{TokenType::L_NUM_O_LIT, input.substr(start, maxEnd-start), line, character});
                    states.push_back(LexerState::S_LITERAL);
                    break;
                case 5:// 0x[A-Fa-f0-9]([_A-Fa-f0-9]|[A-Fa-f0-9])*(\.[_A-Fa-f0-9]+)?
                    ret.push_back(Token{TokenType::L_NUM_X_LIT, input.substr(start, maxEnd-start), line, character});
                    states.push_back(LexerState::S_LITERAL);
                    break;
                case 6:// "([^\\"]|\\.)*"
                    ret.push_back(Token{TokenType::L_STR_LIT, input.substr(start, maxEnd-start), line, character});
                    states.push_back(LexerState::S_LITERAL);
                    break;
                case 7:// '([^\\']|\\.)'
                    ret.push_back(Token{TokenType::L_CHAR_LIT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 8:// \n
                    ret.push_back(Token{TokenType::L_NEW_LN, input.substr(start, maxEnd-start), line, character});
                    break;
                case 9:// [ \t]
                    break;
                case 10:// //
                    states.push_back(LexerState::S_SINGLELINE_COMMENT);
                    break;
                case 11:// /\*
                    states.push_back(LexerState::S_MULTILINE_COMMENT);
                    break;
                case 12:// ,
                    ret.push_back(Token{TokenType::L_COMMA, input.substr(start, maxEnd-start), line, character});
                    break;
                case 13:// ;
                    ret.push_back(Token{TokenType::L_SEMICOLON, input.substr(start, maxEnd-start), line, character});
                    break;
                case 14:// :
                    ret.push_back(Token{TokenType::L_COLON, input.substr(start, maxEnd-start), line, character});
                    break;
                case 15:// ok
                    ret.push_back(Token{TokenType::L_OK, input.substr(start, maxEnd-start), line, character});
                    break;
                case 16:// in
                    ret.push_back(Token{TokenType::L_IN, input.substr(start, maxEnd-start), line, character});
                    break;
                case 17:// \+
                    ret.push_back(Token{TokenType::L_ADD, input.substr(start, maxEnd-start), line, character});
                    break;
                case 18:// \-
                    ret.push_back(Token{TokenType::L_SUB, input.substr(start, maxEnd-start), line, character});
                    break;
                case 19:// \*
                    ret.push_back(Token{TokenType::L_MUL, input.substr(start, maxEnd-start), line, character});
                    break;
                case 20:// /
                    ret.push_back(Token{TokenType::L_DIV, input.substr(start, maxEnd-start), line, character});
                    break;
                case 21:// /%
                    ret.push_back(Token{TokenType::L_INT_DIV, input.substr(start, maxEnd-start), line, character});
                    break;
                case 22:// %
                    ret.push_back(Token{TokenType::L_MOD, input.substr(start, maxEnd-start), line, character});
                    break;
                case 23:// >>
                    ret.push_back(Token{TokenType::L_SHIFT_RIGHT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 24:// <<
                    ret.push_back(Token{TokenType::L_SHIFT_LEFT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 25:// &
                    ret.push_back(Token{TokenType::L_AND, input.substr(start, maxEnd-start), line, character});
                    break;
                case 26:// \|
                    ret.push_back(Token{TokenType::L_OR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 27:// \^
                    ret.push_back(Token{TokenType::L_XOR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 28:// ×|\\cross
                    ret.push_back(Token{TokenType::L_CROSS, input.substr(start, maxEnd-start), line, character});
                    break;
                case 29:// ⋅|\\dot
                    ret.push_back(Token{TokenType::L_DOT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 30:// [=]
                    ret.push_back(Token{TokenType::L_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 31:// \->
                    ret.push_back(Token{TokenType::L_ASSIGN, input.substr(start, maxEnd-start), line, character});
                    break;
                case 32:// \+[=]
                    ret.push_back(Token{TokenType::L_ADD_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 33:// \+\+
                    ret.push_back(Token{TokenType::L_INCREMENT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 34:// --
                    ret.push_back(Token{TokenType::L_DECREMENT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 35:// \-[=]
                    ret.push_back(Token{TokenType::L_SUB_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 36:// \*[=]
                    ret.push_back(Token{TokenType::L_MUL_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 37:// /[=]
                    ret.push_back(Token{TokenType::L_DIV_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 38:// /%[=]
                    ret.push_back(Token{TokenType::L_INT_DIV_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 39:// %[=]
                    ret.push_back(Token{TokenType::L_MOD_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 40:// >>[=]
                    ret.push_back(Token{TokenType::L_SHIFT_RIGHT_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 41:// <<[=]
                    ret.push_back(Token{TokenType::L_SHIFT_LEFT_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 42:// &[=]
                    ret.push_back(Token{TokenType::L_AND_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 43:// \|[=]
                    ret.push_back(Token{TokenType::L_OR_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 44:// \^[=]
                    ret.push_back(Token{TokenType::L_XOR_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 45:// ×|\\cross
                    ret.push_back(Token{TokenType::L_CROSS_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 46:// ⋅|\\dot
                    ret.push_back(Token{TokenType::L_DOT_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 47:// !
                    ret.push_back(Token{TokenType::L_NOT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 48:// \?[=]
                    ret.push_back(Token{TokenType::L_EQUAL, input.substr(start, maxEnd-start), line, character});
                    break;
                case 49:// ![=]
                    ret.push_back(Token{TokenType::L_NOTEQ, input.substr(start, maxEnd-start), line, character});
                    break;
                case 50:// \?\->
                    ret.push_back(Token{TokenType::L_ASSIGNED, input.substr(start, maxEnd-start), line, character});
                    break;
                case 51:// !\->
                    ret.push_back(Token{TokenType::L_NOTASS, input.substr(start, maxEnd-start), line, character});
                    break;
                case 52:// <
                    ret.push_back(Token{TokenType::L_LESS, input.substr(start, maxEnd-start), line, character});
                    break;
                case 53:// >
                    ret.push_back(Token{TokenType::L_GREAT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 54:// <[=]
                    ret.push_back(Token{TokenType::L_LEEQ, input.substr(start, maxEnd-start), line, character});
                    break;
                case 55:// >[=]
                    ret.push_back(Token{TokenType::L_GREQ, input.substr(start, maxEnd-start), line, character});
                    break;
                case 56:// \+&
                    ret.push_back(Token{TokenType::L_TRAIT_AND, input.substr(start, maxEnd-start), line, character});
                    break;
                case 57:// \+\|
                    ret.push_back(Token{TokenType::L_TRAIT_OR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 58:// \+\?
                    ret.push_back(Token{TokenType::L_TRAIT_AND_COND, input.substr(start, maxEnd-start), line, character});
                    break;
                case 59:// \?\?
                    ret.push_back(Token{TokenType::L_TRAIT_COND, input.substr(start, maxEnd-start), line, character});
                    break;
                case 60:// \?
                    ret.push_back(Token{TokenType::L_QUEST, input.substr(start, maxEnd-start), line, character});
                    break;
                case 61:// \(
                    ret.push_back(Token{TokenType::L_LEFT_PAR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 62:// \)
                    ret.push_back(Token{TokenType::L_RIGHT_PAR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 63:// \[
                    ret.push_back(Token{TokenType::L_LEFT_BRACK, input.substr(start, maxEnd-start), line, character});
                    break;
                case 64:// \]
                    ret.push_back(Token{TokenType::L_RIGHT_BRACK, input.substr(start, maxEnd-start), line, character});
                    break;
                case 65:// \{
                    ret.push_back(Token{TokenType::L_LEFT_BRACE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 66:// \}
                    ret.push_back(Token{TokenType::L_RIGHT_BRACE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 67:// \.
                    ret.push_back(Token{TokenType::L_MEMBER, input.substr(start, maxEnd-start), line, character});
                    break;
                case 68:// [=]>
                    ret.push_back(Token{TokenType::L_FUNCTION, input.substr(start, maxEnd-start), line, character});
                    break;
                case 69:// <[=]>
                    ret.push_back(Token{TokenType::L_COROUTINE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 70:// if
                    ret.push_back(Token{TokenType::L_IF, input.substr(start, maxEnd-start), line, character});
                    break;
                case 71:// else
                    ret.push_back(Token{TokenType::L_ELSE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 72:// elif
                    ret.push_back(Token{TokenType::L_ELIF, input.substr(start, maxEnd-start), line, character});
                    break;
                case 73:// switch
                    ret.push_back(Token{TokenType::L_SWITCH, input.substr(start, maxEnd-start), line, character});
                    break;
                case 74:// case
                    ret.push_back(Token{TokenType::L_CASE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 75:// times
                    ret.push_back(Token{TokenType::L_TIMES, input.substr(start, maxEnd-start), line, character});
                    break;
                case 76:// for
                    ret.push_back(Token{TokenType::L_FOR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 77:// while
                    ret.push_back(Token{TokenType::L_WHILE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 78:// repeat
                    ret.push_back(Token{TokenType::L_REPEAT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 79:// break
                    ret.push_back(Token{TokenType::L_BREAK, input.substr(start, maxEnd-start), line, character});
                    break;
                case 80:// continue
                    ret.push_back(Token{TokenType::L_CONTINUE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 81:// return
                    ret.push_back(Token{TokenType::L_RETURN, input.substr(start, maxEnd-start), line, character});
                    break;
                case 82:// yield
                    ret.push_back(Token{TokenType::L_YIELD, input.substr(start, maxEnd-start), line, character});
                    break;
                case 83:// with
                    ret.push_back(Token{TokenType::L_WITH, input.substr(start, maxEnd-start), line, character});
                    break;
                case 84:// def
                    ret.push_back(Token{TokenType::L_DEF, input.substr(start, maxEnd-start), line, character});
                    break;
                case 85:// const
                    ret.push_back(Token{TokenType::L_CONST, input.substr(start, maxEnd-start), line, character});
                    break;
                case 86:// var
                    ret.push_back(Token{TokenType::L_VAR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 87:// ref
                    ret.push_back(Token{TokenType::L_REF, input.substr(start, maxEnd-start), line, character});
                    break;
                case 88:// new
                    ret.push_back(Token{TokenType::L_NEW, input.substr(start, maxEnd-start), line, character});
                    break;
                case 89:// final
                    ret.push_back(Token{TokenType::L_FINAL, input.substr(start, maxEnd-start), line, character});
                    break;
                case 90:// mutable
                    ret.push_back(Token{TokenType::L_MUTABLE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 91:// volatile
                    ret.push_back(Token{TokenType::L_VOLATILE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 92:// static
                    ret.push_back(Token{TokenType::L_STATIC, input.substr(start, maxEnd-start), line, character});
                    break;
                case 93:// using
                    ret.push_back(Token{TokenType::L_USING, input.substr(start, maxEnd-start), line, character});
                    break;
                case 94:// include
                    ret.push_back(Token{TokenType::L_INCLUDE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 95:// as
                    ret.push_back(Token{TokenType::L_AS, input.substr(start, maxEnd-start), line, character});
                    break;
                default:
                {
                    maxEnd = start+1;
                    movePtr = true;
                    std::wstringstream ss;
                    ss << "Unexpected character '" << input[start] << "'";
                    outErrors.emplace_back(line, character, ss.str());
                }
                }
                break;
            case LexerState::S_LITERAL:
                
                // *** choose rule ***
                if (auto res = ctre::starts_with<
                        L"([a-zA-Z_][a-zA-Z0-9_]*)"
                        L"|()"
                    >(std::wstring_view(input.begin()+start, input.end())); res)
                {
                    if (const auto& subRes = res.get<1>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 1;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<2>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 2;
                        maxEnd = start + res.size();
                    }
                }
                
                // *** execute rule commands ***
                switch (choosenRuleInd)
                {
                case 1:// [a-zA-Z_][a-zA-Z0-9_]*
                    ret.push_back(Token{TokenType::L_LIT_SUFFIX, input.substr(start, maxEnd-start), line, character});
                    states.pop_back();
                    break;
                case 2:// 
                    states.pop_back();
                    break;
                default:
                {
                    maxEnd = start+1;
                    movePtr = true;
                    std::wstringstream ss;
                    ss << "Unexpected character '" << input[start] << "'";
                    outErrors.emplace_back(line, character, ss.str());
                }
                }
                break;
            case LexerState::S_SINGLELINE_COMMENT:
                
                // *** choose rule ***
                if (auto res = ctre::starts_with<
                        L"([^\\n]*)"
                        L"|(\\n)"
                    >(std::wstring_view(input.begin()+start, input.end())); res)
                {
                    if (const auto& subRes = res.get<1>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 1;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<2>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 2;
                        maxEnd = start + res.size();
                    }
                }
                
                // *** execute rule commands ***
                switch (choosenRuleInd)
                {
                case 1:// [^\n]*
                    break;
                case 2:// \n
                    states.pop_back();
                    break;
                default:
                {
                    maxEnd = start+1;
                    movePtr = true;
                    std::wstringstream ss;
                    ss << "Unexpected character '" << input[start] << "'";
                    outErrors.emplace_back(line, character, ss.str());
                }
                }
                break;
            case LexerState::S_MULTILINE_COMMENT:
                
                // *** choose rule ***
                if (auto res = ctre::starts_with<
                        L"(([^*/]|\\*[^/]|/[^\\*])*)"
                        L"|(/\\*)"
                        L"|(\\*/)"
                    >(std::wstring_view(input.begin()+start, input.end())); res)
                {
                    if (const auto& subRes = res.get<1>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 1;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<2>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 2;
                        maxEnd = start + res.size();
                    }
                    if (const auto& subRes = res.get<3>(); subRes && (int)subRes.size() > (maxEnd-start)) {
                        choosenRuleInd = 3;
                        maxEnd = start + res.size();
                    }
                }
                
                // *** execute rule commands ***
                switch (choosenRuleInd)
                {
                case 1:// ([^*/]|\*[^/]|/[^\*])*
                    break;
                case 2:// /\*
                    states.push_back(LexerState::S_MULTILINE_COMMENT);
                    break;
                case 3:// \*/
                    states.pop_back();
                    break;
                default:
                {
                    maxEnd = start+1;
                    movePtr = true;
                    std::wstringstream ss;
                    ss << "Unexpected character '" << input[start] << "'";
                    outErrors.emplace_back(line, character, ss.str());
                }
                }
                break;
            }
            
            // *** count lines/positions ***
            for (int i=start; i<maxEnd; i++)
            {
                if (input[i] == '\n')
                {
                    line++;
                    character = 0;
                }
                character++;
            }
            
            // *** move pointer ***
            if (movePtr) {
                start = maxEnd;
                maxEnd = -1;
            }
        }
        
        return ret;
    }

}
