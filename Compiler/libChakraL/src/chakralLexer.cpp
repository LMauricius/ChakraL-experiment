// This file is autogenerated. Do not edit!

#include "ctre-unicode.hpp"
#include "chakralLexer.h"
#include <vector>
#include <string_view>
#include <sstream>
#include <iostream>

namespace
{
}
namespace ChakraL
{
    const std::array<std::string, 93> TokenNames {
        "L_IDENTIFIER",
        "L_NUM_LIT",
        "L_NUM_B_LIT",
        "L_NUM_O_LIT",
        "L_NUM_X_LIT",
        "L_STR_LIT",
        "L_CHAR_LIT",
        "L_NEW_LN",
        "L_COMMA",
        "L_SEMICOLON",
        "L_COLON",
        "L_OK",
        "L_IN",
        "L_ADD",
        "L_SUB",
        "L_MUL",
        "L_DIV",
        "L_INT_DIV",
        "L_MOD",
        "L_SHIFT_RIGHT",
        "L_SHIFT_LEFT",
        "L_AND",
        "L_OR",
        "L_XOR",
        "L_CROSS",
        "L_DOT",
        "L_CHANGE",
        "L_ASSIGN",
        "L_ADD_CHANGE",
        "L_INCREMENT",
        "L_DECREMENT",
        "L_SUB_CHANGE",
        "L_MUL_CHANGE",
        "L_DIV_CHANGE",
        "L_INT_DIV_CHANGE",
        "L_MOD_CHANGE",
        "L_SHIFT_RIGHT_CHANGE",
        "L_SHIFT_LEFT_CHANGE",
        "L_AND_CHANGE",
        "L_OR_CHANGE",
        "L_XOR_CHANGE",
        "L_CROSS_CHANGE",
        "L_DOT_CHANGE",
        "L_NOT",
        "L_EQUAL",
        "L_NOTEQ",
        "L_ASSIGNED",
        "L_NOTASS",
        "L_LESS",
        "L_GREAT",
        "L_LEEQ",
        "L_GREQ",
        "L_TRAIT_AND",
        "L_TRAIT_OR",
        "L_TRAIT_AND_COND",
        "L_TRAIT_COND",
        "L_QUEST",
        "L_LEFT_PAR",
        "L_RIGHT_PAR",
        "L_LEFT_BRACK",
        "L_RIGHT_BRACK",
        "L_LEFT_BRACE",
        "L_RIGHT_BRACE",
        "L_MEMBER",
        "L_FUNCTION",
        "L_COROUTINE",
        "L_IF",
        "L_ELSE",
        "L_ELIF",
        "L_SWITCH",
        "L_CASE",
        "L_TIMES",
        "L_FOR",
        "L_WHILE",
        "L_REPEAT",
        "L_BREAK",
        "L_CONTINUE",
        "L_RETURN",
        "L_YIELD",
        "L_WITH",
        "L_DEF",
        "L_CONST",
        "L_VAR",
        "L_REF",
        "L_NEW",
        "L_FINAL",
        "L_MUTABLE",
        "L_VOLATILE",
        "L_STATIC",
        "L_USING",
        "L_INCLUDE",
        "L_AS",
        "L_LIT_SUFFIX",
    };

    std::list<Token> tokenize(std::wstring &input, std::list<LexerError>& outErrors)
    {
        int line = 1, character = 1;
        int start = 0, maxEnd = -1;
        std::vector<LexerState> states = {{LexerState::S_START}};
        std::list<Token> ret;
        
        while (start < input.size())
        {
            int choosenRuleInd = -1;
            bool movePtr = true;
            std::wstring_view matchStr;
            
            switch (states.back())
            {
            case LexerState::S_START:
                
                // *** choose rule ***
                if (auto res = ctre::starts_with<L"([a-zA-Z][a-zA-Z0-9_]*)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 1;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"([0-9]+(_[0-9]|[0-9])*(\\.[0-9]+)?)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 2;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(0b[01]([_01]|[01])*(\\.[_01]+)?)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 3;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(0o[0-7]([_0-7]|[0-7])*(\\.[_0-7]+)?)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 4;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(0x[A-Fa-f0-9]([_A-Fa-f0-9]|[A-Fa-f0-9])*(\\.[_A-Fa-f0-9]+)?)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 5;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\"([^\\\\\"]|\\\\.)*\")">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 6;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\'([^\\\\\']|\\\\.)\')">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 7;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\n)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 8;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"([ \\t])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 9;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(//)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 10;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(/\\*)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 11;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(,)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 12;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(;)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 13;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(:)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 14;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(ok)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 15;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(in)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 16;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\+)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 17;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\-)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 18;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\*)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 19;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(/)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 20;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(/%)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 21;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(%)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 22;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(>>)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 23;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(<<)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 24;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(&)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 25;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\|)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 26;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\^)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 27;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(×|\\\\cross)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 28;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(⋅|\\\\dot)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 29;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"([=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 30;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\->)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 31;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\+[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 32;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\+\\+)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 33;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(--)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 34;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\-[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 35;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\*[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 36;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(/[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 37;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(/%[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 38;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(%[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 39;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(>>[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 40;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(<<[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 41;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(&[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 42;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\|[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 43;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\^[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 44;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(×|\\\\cross)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 45;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(⋅|\\\\dot)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 46;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(!)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 47;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\?[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 48;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(![=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 49;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\?\\->)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 50;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(!\\->)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 51;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(<)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 52;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(>)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 53;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(<[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 54;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(>[=])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 55;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\+&)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 56;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\+\\|)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 57;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\+\\?)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 58;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\?\\?)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 59;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\?)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 60;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\()">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 61;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\))">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 62;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\[)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 63;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\])">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 64;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\{)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 65;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\})">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 66;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\.)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 67;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"([=]>)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 68;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(<[=]>)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 69;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(if)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 70;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(else)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 71;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(elif)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 72;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(switch)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 73;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(case)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 74;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(times)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 75;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(for)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 76;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(while)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 77;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(repeat)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 78;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(break)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 79;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(continue)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 80;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(return)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 81;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(yield)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 82;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(with)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 83;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(def)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 84;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(const)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 85;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(var)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 86;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(ref)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 87;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(new)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 88;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(final)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 89;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(mutable)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 90;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(volatile)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 91;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(static)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 92;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(using)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 93;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(include)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 94;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(as)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 95;
                    maxEnd = start + res.size();
                }
                
                // *** execute rule commands ***
                switch (choosenRuleInd)
                {
                case 1:// [a-zA-Z][a-zA-Z0-9_]*
                    ret.push_back(Token{TokenType::L_IDENTIFIER, input.substr(start, maxEnd-start), line, character});
                    break;
                case 2:// [0-9]+(_[0-9]|[0-9])*(\.[0-9]+)?
                    ret.push_back(Token{TokenType::L_NUM_LIT, input.substr(start, maxEnd-start), line, character});
                    states.push_back(LexerState::S_LITERAL);
                    break;
                case 3:// 0b[01]([_01]|[01])*(\.[_01]+)?
                    ret.push_back(Token{TokenType::L_NUM_B_LIT, input.substr(start, maxEnd-start), line, character});
                    states.push_back(LexerState::S_LITERAL);
                    break;
                case 4:// 0o[0-7]([_0-7]|[0-7])*(\.[_0-7]+)?
                    ret.push_back(Token{TokenType::L_NUM_O_LIT, input.substr(start, maxEnd-start), line, character});
                    states.push_back(LexerState::S_LITERAL);
                    break;
                case 5:// 0x[A-Fa-f0-9]([_A-Fa-f0-9]|[A-Fa-f0-9])*(\.[_A-Fa-f0-9]+)?
                    ret.push_back(Token{TokenType::L_NUM_X_LIT, input.substr(start, maxEnd-start), line, character});
                    states.push_back(LexerState::S_LITERAL);
                    break;
                case 6:// "([^\\"]|\\.)*"
                    ret.push_back(Token{TokenType::L_STR_LIT, input.substr(start, maxEnd-start), line, character});
                    states.push_back(LexerState::S_LITERAL);
                    break;
                case 7:// '([^\\']|\\.)'
                    ret.push_back(Token{TokenType::L_CHAR_LIT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 8:// \n
                    ret.push_back(Token{TokenType::L_NEW_LN, input.substr(start, maxEnd-start), line, character});
                    break;
                case 9:// [ \t]
                    break;
                case 10:// //
                    states.push_back(LexerState::S_SINGLELINE_COMMENT);
                    break;
                case 11:// /\*
                    states.push_back(LexerState::S_MULTILINE_COMMENT);
                    break;
                case 12:// ,
                    ret.push_back(Token{TokenType::L_COMMA, input.substr(start, maxEnd-start), line, character});
                    break;
                case 13:// ;
                    ret.push_back(Token{TokenType::L_SEMICOLON, input.substr(start, maxEnd-start), line, character});
                    break;
                case 14:// :
                    ret.push_back(Token{TokenType::L_COLON, input.substr(start, maxEnd-start), line, character});
                    break;
                case 15:// ok
                    ret.push_back(Token{TokenType::L_OK, input.substr(start, maxEnd-start), line, character});
                    break;
                case 16:// in
                    ret.push_back(Token{TokenType::L_IN, input.substr(start, maxEnd-start), line, character});
                    break;
                case 17:// \+
                    ret.push_back(Token{TokenType::L_ADD, input.substr(start, maxEnd-start), line, character});
                    break;
                case 18:// \-
                    ret.push_back(Token{TokenType::L_SUB, input.substr(start, maxEnd-start), line, character});
                    break;
                case 19:// \*
                    ret.push_back(Token{TokenType::L_MUL, input.substr(start, maxEnd-start), line, character});
                    break;
                case 20:// /
                    ret.push_back(Token{TokenType::L_DIV, input.substr(start, maxEnd-start), line, character});
                    break;
                case 21:// /%
                    ret.push_back(Token{TokenType::L_INT_DIV, input.substr(start, maxEnd-start), line, character});
                    break;
                case 22:// %
                    ret.push_back(Token{TokenType::L_MOD, input.substr(start, maxEnd-start), line, character});
                    break;
                case 23:// >>
                    ret.push_back(Token{TokenType::L_SHIFT_RIGHT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 24:// <<
                    ret.push_back(Token{TokenType::L_SHIFT_LEFT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 25:// &
                    ret.push_back(Token{TokenType::L_AND, input.substr(start, maxEnd-start), line, character});
                    break;
                case 26:// \|
                    ret.push_back(Token{TokenType::L_OR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 27:// \^
                    ret.push_back(Token{TokenType::L_XOR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 28:// ×|\\cross
                    ret.push_back(Token{TokenType::L_CROSS, input.substr(start, maxEnd-start), line, character});
                    break;
                case 29:// ⋅|\\dot
                    ret.push_back(Token{TokenType::L_DOT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 30:// [=]
                    ret.push_back(Token{TokenType::L_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 31:// \->
                    ret.push_back(Token{TokenType::L_ASSIGN, input.substr(start, maxEnd-start), line, character});
                    break;
                case 32:// \+[=]
                    ret.push_back(Token{TokenType::L_ADD_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 33:// \+\+
                    ret.push_back(Token{TokenType::L_INCREMENT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 34:// --
                    ret.push_back(Token{TokenType::L_DECREMENT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 35:// \-[=]
                    ret.push_back(Token{TokenType::L_SUB_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 36:// \*[=]
                    ret.push_back(Token{TokenType::L_MUL_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 37:// /[=]
                    ret.push_back(Token{TokenType::L_DIV_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 38:// /%[=]
                    ret.push_back(Token{TokenType::L_INT_DIV_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 39:// %[=]
                    ret.push_back(Token{TokenType::L_MOD_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 40:// >>[=]
                    ret.push_back(Token{TokenType::L_SHIFT_RIGHT_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 41:// <<[=]
                    ret.push_back(Token{TokenType::L_SHIFT_LEFT_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 42:// &[=]
                    ret.push_back(Token{TokenType::L_AND_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 43:// \|[=]
                    ret.push_back(Token{TokenType::L_OR_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 44:// \^[=]
                    ret.push_back(Token{TokenType::L_XOR_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 45:// ×|\\cross
                    ret.push_back(Token{TokenType::L_CROSS_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 46:// ⋅|\\dot
                    ret.push_back(Token{TokenType::L_DOT_CHANGE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 47:// !
                    ret.push_back(Token{TokenType::L_NOT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 48:// \?[=]
                    ret.push_back(Token{TokenType::L_EQUAL, input.substr(start, maxEnd-start), line, character});
                    break;
                case 49:// ![=]
                    ret.push_back(Token{TokenType::L_NOTEQ, input.substr(start, maxEnd-start), line, character});
                    break;
                case 50:// \?\->
                    ret.push_back(Token{TokenType::L_ASSIGNED, input.substr(start, maxEnd-start), line, character});
                    break;
                case 51:// !\->
                    ret.push_back(Token{TokenType::L_NOTASS, input.substr(start, maxEnd-start), line, character});
                    break;
                case 52:// <
                    ret.push_back(Token{TokenType::L_LESS, input.substr(start, maxEnd-start), line, character});
                    break;
                case 53:// >
                    ret.push_back(Token{TokenType::L_GREAT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 54:// <[=]
                    ret.push_back(Token{TokenType::L_LEEQ, input.substr(start, maxEnd-start), line, character});
                    break;
                case 55:// >[=]
                    ret.push_back(Token{TokenType::L_GREQ, input.substr(start, maxEnd-start), line, character});
                    break;
                case 56:// \+&
                    ret.push_back(Token{TokenType::L_TRAIT_AND, input.substr(start, maxEnd-start), line, character});
                    break;
                case 57:// \+\|
                    ret.push_back(Token{TokenType::L_TRAIT_OR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 58:// \+\?
                    ret.push_back(Token{TokenType::L_TRAIT_AND_COND, input.substr(start, maxEnd-start), line, character});
                    break;
                case 59:// \?\?
                    ret.push_back(Token{TokenType::L_TRAIT_COND, input.substr(start, maxEnd-start), line, character});
                    break;
                case 60:// \?
                    ret.push_back(Token{TokenType::L_QUEST, input.substr(start, maxEnd-start), line, character});
                    break;
                case 61:// \(
                    ret.push_back(Token{TokenType::L_LEFT_PAR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 62:// \)
                    ret.push_back(Token{TokenType::L_RIGHT_PAR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 63:// \[
                    ret.push_back(Token{TokenType::L_LEFT_BRACK, input.substr(start, maxEnd-start), line, character});
                    break;
                case 64:// \]
                    ret.push_back(Token{TokenType::L_RIGHT_BRACK, input.substr(start, maxEnd-start), line, character});
                    break;
                case 65:// \{
                    ret.push_back(Token{TokenType::L_LEFT_BRACE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 66:// \}
                    ret.push_back(Token{TokenType::L_RIGHT_BRACE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 67:// \.
                    ret.push_back(Token{TokenType::L_MEMBER, input.substr(start, maxEnd-start), line, character});
                    break;
                case 68:// [=]>
                    ret.push_back(Token{TokenType::L_FUNCTION, input.substr(start, maxEnd-start), line, character});
                    break;
                case 69:// <[=]>
                    ret.push_back(Token{TokenType::L_COROUTINE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 70:// if
                    ret.push_back(Token{TokenType::L_IF, input.substr(start, maxEnd-start), line, character});
                    break;
                case 71:// else
                    ret.push_back(Token{TokenType::L_ELSE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 72:// elif
                    ret.push_back(Token{TokenType::L_ELIF, input.substr(start, maxEnd-start), line, character});
                    break;
                case 73:// switch
                    ret.push_back(Token{TokenType::L_SWITCH, input.substr(start, maxEnd-start), line, character});
                    break;
                case 74:// case
                    ret.push_back(Token{TokenType::L_CASE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 75:// times
                    ret.push_back(Token{TokenType::L_TIMES, input.substr(start, maxEnd-start), line, character});
                    break;
                case 76:// for
                    ret.push_back(Token{TokenType::L_FOR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 77:// while
                    ret.push_back(Token{TokenType::L_WHILE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 78:// repeat
                    ret.push_back(Token{TokenType::L_REPEAT, input.substr(start, maxEnd-start), line, character});
                    break;
                case 79:// break
                    ret.push_back(Token{TokenType::L_BREAK, input.substr(start, maxEnd-start), line, character});
                    break;
                case 80:// continue
                    ret.push_back(Token{TokenType::L_CONTINUE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 81:// return
                    ret.push_back(Token{TokenType::L_RETURN, input.substr(start, maxEnd-start), line, character});
                    break;
                case 82:// yield
                    ret.push_back(Token{TokenType::L_YIELD, input.substr(start, maxEnd-start), line, character});
                    break;
                case 83:// with
                    ret.push_back(Token{TokenType::L_WITH, input.substr(start, maxEnd-start), line, character});
                    break;
                case 84:// def
                    ret.push_back(Token{TokenType::L_DEF, input.substr(start, maxEnd-start), line, character});
                    break;
                case 85:// const
                    ret.push_back(Token{TokenType::L_CONST, input.substr(start, maxEnd-start), line, character});
                    break;
                case 86:// var
                    ret.push_back(Token{TokenType::L_VAR, input.substr(start, maxEnd-start), line, character});
                    break;
                case 87:// ref
                    ret.push_back(Token{TokenType::L_REF, input.substr(start, maxEnd-start), line, character});
                    break;
                case 88:// new
                    ret.push_back(Token{TokenType::L_NEW, input.substr(start, maxEnd-start), line, character});
                    break;
                case 89:// final
                    ret.push_back(Token{TokenType::L_FINAL, input.substr(start, maxEnd-start), line, character});
                    break;
                case 90:// mutable
                    ret.push_back(Token{TokenType::L_MUTABLE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 91:// volatile
                    ret.push_back(Token{TokenType::L_VOLATILE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 92:// static
                    ret.push_back(Token{TokenType::L_STATIC, input.substr(start, maxEnd-start), line, character});
                    break;
                case 93:// using
                    ret.push_back(Token{TokenType::L_USING, input.substr(start, maxEnd-start), line, character});
                    break;
                case 94:// include
                    ret.push_back(Token{TokenType::L_INCLUDE, input.substr(start, maxEnd-start), line, character});
                    break;
                case 95:// as
                    ret.push_back(Token{TokenType::L_AS, input.substr(start, maxEnd-start), line, character});
                    break;
                default:
                {
                    maxEnd = start+1;
                    movePtr = true;
                    std::wstringstream ss;
                    ss << "Unexpected character '" << input[start] << "'";
                    outErrors.emplace_back(line, character, ss.str());
                }
                }
                break;
            case LexerState::S_LITERAL:
                
                // *** choose rule ***
                if (auto res = ctre::starts_with<L"([a-zA-Z_][a-zA-Z0-9_]*)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 1;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"()">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 2;
                    maxEnd = start + res.size();
                }
                
                // *** execute rule commands ***
                switch (choosenRuleInd)
                {
                case 1:// [a-zA-Z_][a-zA-Z0-9_]*
                    ret.push_back(Token{TokenType::L_LIT_SUFFIX, input.substr(start, maxEnd-start), line, character});
                    states.pop_back();
                    break;
                case 2:// 
                    states.pop_back();
                    break;
                default:
                {
                    maxEnd = start+1;
                    movePtr = true;
                    std::wstringstream ss;
                    ss << "Unexpected character '" << input[start] << "'";
                    outErrors.emplace_back(line, character, ss.str());
                }
                }
                break;
            case LexerState::S_SINGLELINE_COMMENT:
                
                // *** choose rule ***
                if (auto res = ctre::starts_with<L"([^\\n]*)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 1;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\n)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 2;
                    maxEnd = start + res.size();
                }
                
                // *** execute rule commands ***
                switch (choosenRuleInd)
                {
                case 1:// [^\n]*
                    break;
                case 2:// \n
                    states.pop_back();
                    break;
                default:
                {
                    maxEnd = start+1;
                    movePtr = true;
                    std::wstringstream ss;
                    ss << "Unexpected character '" << input[start] << "'";
                    outErrors.emplace_back(line, character, ss.str());
                }
                }
                break;
            case LexerState::S_MULTILINE_COMMENT:
                
                // *** choose rule ***
                if (auto res = ctre::starts_with<L"(([^*/]|\\*[^/]|/[^\\*])*)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 1;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(/\\*)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 2;
                    maxEnd = start + res.size();
                }
                if (auto res = ctre::starts_with<L"(\\*/)">(
std::wstring_view(input).substr(start, input.size()-start)
);
 res && 
(int)res.size() > 
(maxEnd-start)
) {
                    choosenRuleInd = 3;
                    maxEnd = start + res.size();
                }
                
                // *** execute rule commands ***
                switch (choosenRuleInd)
                {
                case 1:// ([^*/]|\*[^/]|/[^\*])*
                    break;
                case 2:// /\*
                    states.push_back(LexerState::S_MULTILINE_COMMENT);
                    break;
                case 3:// \*/
                    states.pop_back();
                    break;
                default:
                {
                    maxEnd = start+1;
                    movePtr = true;
                    std::wstringstream ss;
                    ss << "Unexpected character '" << input[start] << "'";
                    outErrors.emplace_back(line, character, ss.str());
                }
                }
                break;
            }
            
            // *** count lines/positions ***
            for (int i=start; i<maxEnd; i++)
            {
                if (input[i] == '\n')
                {
                    line++;
                    character = 0;
                }
                character++;
            }
            
            // *** move pointer ***
            if (movePtr) {
                start = maxEnd;
                maxEnd = -1;
            }
        }
        
        return ret;
    }

}
