// This file is autogenerated. Do not edit!

#include <list>
#include <string>
#include <map>
#include <memory>
#include "chakralLexer.h"

namespace ChakraL {

    class ParseNode {
    public:
        virtual void process();
        void appendMove(ParseNode& other);
        
        std::map<std::string, std::list<std::unique_ptr<ParseNode>>> nodeLists;
        std::map<std::string, std::list<Token>> tokenLists;
    };

    class ParseNode_file : public ParseNode {
    public:
        void process();
    };

    class ParseNode_ONL : public ParseNode {
    public:
        void process();
    };

    class ParseNode_contextBody : public ParseNode {
    public:
        void process();
    };

    class ParseNode_contextBodyClosedBlock : public ParseNode {
    public:
        void process();
    };

    class ParseNode_contextDescriptionEntry : public ParseNode {
    public:
        void process();
    };

    class ParseNode_traitAssertion : public ParseNode {
    public:
        void process();
    };

    class ParseNode_expression : public ParseNode {
    public:
        void process();
    };

    class ParseNode_expr0 : public ParseNode {
    public:
        void process();
    };

    class ParseNode_identifier : public ParseNode {
    public:
        void process();
    };

    class ParseNode_suffixFunction : public ParseNode {
    public:
        void process();
    };

    class ParseNode_expr1 : public ParseNode {
    public:
        void process();
    };

    class ParseNode_suffixInc : public ParseNode {
    public:
        void process();
    };

    class ParseNode_suffixDec : public ParseNode {
    public:
        void process();
    };

    class ParseNode_copy : public ParseNode {
    public:
        void process();
    };

    class ParseNode_prefixFunction : public ParseNode {
    public:
        void process();
    };

    class ParseNode_expr2 : public ParseNode {
    public:
        void process();
    };

    class ParseNode_prefixInc : public ParseNode {
    public:
        void process();
    };

    class ParseNode_prefixDec : public ParseNode {
    public:
        void process();
    };

    class ParseNode_plus : public ParseNode {
    public:
        void process();
    };

    class ParseNode_minus : public ParseNode {
    public:
        void process();
    };

    class ParseNode_logNot : public ParseNode {
    public:
        void process();
    };

    class ParseNode_expr3 : public ParseNode {
    public:
        void process();
    };

    class ParseNode_multiplication : public ParseNode {
    public:
        void process();
    };

    class ParseNode_crossProduct : public ParseNode {
    public:
        void process();
    };

    class ParseNode_dotProduct : public ParseNode {
    public:
        void process();
    };

    class ParseNode_division : public ParseNode {
    public:
        void process();
    };

    class ParseNode_divisionInt : public ParseNode {
    public:
        void process();
    };

    class ParseNode_modulo : public ParseNode {
    public:
        void process();
    };

    class ParseNode_expr4 : public ParseNode {
    public:
        void process();
    };

    class ParseNode_addition : public ParseNode {
    public:
        void process();
    };

    class ParseNode_subtraction : public ParseNode {
    public:
        void process();
    };

    class ParseNode_expr5 : public ParseNode {
    public:
        void process();
    };

    class ParseNode_shiftL : public ParseNode {
    public:
        void process();
    };

    class ParseNode_shiftR : public ParseNode {
    public:
        void process();
    };

    class ParseNode_expr6 : public ParseNode {
    public:
        void process();
    };

    class ParseNode_compLess : public ParseNode {
    public:
        void process();
    };

    class ParseNode_compGreat : public ParseNode {
    public:
        void process();
    };

    class ParseNode_compLeEq : public ParseNode {
    public:
        void process();
    };

    class ParseNode_compGrEq : public ParseNode {
    public:
        void process();
    };

    class ParseNode_expr7 : public ParseNode {
    public:
        void process();
    };

    class ParseNode_compEqual : public ParseNode {
    public:
        void process();
    };

    class ParseNode_compNotEq : public ParseNode {
    public:
        void process();
    };

    class ParseNode_compAssigned : public ParseNode {
    public:
        void process();
    };

    class ParseNode_compNotAss : public ParseNode {
    public:
        void process();
    };

    class ParseNode_expr8 : public ParseNode {
    public:
        void process();
    };

    class ParseNode_logAnd : public ParseNode {
    public:
        void process();
    };

    class ParseNode_expr9 : public ParseNode {
    public:
        void process();
    };

    class ParseNode_logXOr : public ParseNode {
    public:
        void process();
    };

    class ParseNode_expr10 : public ParseNode {
    public:
        void process();
    };

    class ParseNode_logOr : public ParseNode {
    public:
        void process();
    };

    class ParseNode_exprLeast : public ParseNode {
    public:
        void process();
    };

    class ParseNode_literal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_valueLiteral : public ParseNode {
    public:
        void process();
    };

    class ParseNode_listLiteral : public ParseNode {
    public:
        void process();
    };

    class ParseNode_setLiteral : public ParseNode {
    public:
        void process();
    };

    class ParseNode_dictLiteral : public ParseNode {
    public:
        void process();
    };

    class ParseNode_dictEntry : public ParseNode {
    public:
        void process();
    };

    class ParseNode_contextLiteral : public ParseNode {
    public:
        void process();
    };

    class ParseNode_memberDecl : public ParseNode {
    public:
        void process();
    };

    class ParseNode_statement : public ParseNode {
    public:
        void process();
    };

    class ParseNode_definition : public ParseNode {
    public:
        void process();
    };

    class ParseNode_varDeclaration : public ParseNode {
    public:
        void process();
    };

    class ParseNode_refDeclaration : public ParseNode {
    public:
        void process();
    };

    class ParseNode_varRefDeclBody : public ParseNode {
    public:
        void process();
    };

    class ParseNode_varRefDeclEntry : public ParseNode {
    public:
        void process();
    };

    class ParseNode_varRefDeclEntryEqual : public ParseNode {
    public:
        void process();
    };

    class ParseNode_varRefDeclEntryAssign : public ParseNode {
    public:
        void process();
    };

    class ParseNode_ifStat : public ParseNode {
    public:
        void process();
    };

    class ParseNode_elseStatPart : public ParseNode {
    public:
        void process();
    };

    class ParseNode_loopStat : public ParseNode {
    public:
        void process();
    };

    class ParseNode_loopStatPart : public ParseNode {
    public:
        void process();
    };

    class ParseNode_timesLoopStatPart : public ParseNode {
    public:
        void process();
    };

    class ParseNode_forLoopStatPart : public ParseNode {
    public:
        void process();
    };

    class ParseNode_whileLoopStatPart : public ParseNode {
    public:
        void process();
    };

    class ParseNode_jumpStat : public ParseNode {
    public:
        void process();
    };

    class ParseNode_breakStat : public ParseNode {
    public:
        void process();
    };

    class ParseNode_continueStat : public ParseNode {
    public:
        void process();
    };

    class ParseNode_returnStat : public ParseNode {
    public:
        void process();
    };

    class ParseNode_withStat : public ParseNode {
    public:
        void process();
    };

    class ParseNode_withStatEntry : public ParseNode {
    public:
        void process();
    };

    class ParseNode_assignmentEqual : public ParseNode {
    public:
        void process();
    };

    class ParseNode_assignRef : public ParseNode {
    public:
        void process();
    };

    class ParseNode_changeVal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_addChangeVal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_subChangeVal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_mulChangeVal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_crossChangeVal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_dotChangeVal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_divChangeVal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_intDivChangeVal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_modChangeVal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_shiftRChangeVal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_shiftLChangeVal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_andChangeVal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_orChangeVal : public ParseNode {
    public:
        void process();
    };

    class ParseNode_xorChangeVal : public ParseNode {
    public:
        void process();
    };


    // State utils
    struct StateData;
    struct State;
    struct ParserBranch;
    struct ParserData;
    
    struct StateData {
        ParseNode* node;
    };
    
    struct State {
        // returns whether the state branches
        bool (*stateHandler)(ParserData& parserData, ParserBranch& branch);
        
        StateData data;
    };
    
    struct ParserBranch {
        std::vector<State> stack;
        ParserBranch* parent;
        size_t branchCount=0;
    };
    
    struct ParserData {
        std::list<ParserBranch> activeBranches;
        std::list<ParserBranch> ambiguousBranches;
    };

}
