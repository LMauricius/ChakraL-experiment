// This file is autogenerated. Do not edit!

#pragma once

#include <list>
#include <string>
#include <map>
#include <set>
#include <memory>
#include "chakralLexer.h"

namespace ChakraL {

    class ParseNode;
    using ParseNodePtr = std::shared_ptr<ParseNode>;

    class ParseNode {
    public:
        virtual ~ParseNode();
        virtual void process();
        void pullFrom(ParseNode& other);
        
        std::map<std::string, std::list<ParseNodePtr>> nodeLists;
        std::map<std::string, std::list<Token>> tokenLists;
        ParseNodePtr continuationNode = nullptr;
    };
    class ParseNode_file : public ParseNode { public: ~ParseNode_file(); void process(); };
    class ParseNode_ONL : public ParseNode { public: ~ParseNode_ONL(); void process(); };
    class ParseNode_contextBody : public ParseNode { public: ~ParseNode_contextBody(); void process(); };
    class ParseNode_contextBodyClosedBlock : public ParseNode { public: ~ParseNode_contextBodyClosedBlock(); void process(); };
    class ParseNode_contextDescriptionEntry : public ParseNode { public: ~ParseNode_contextDescriptionEntry(); void process(); };
    class ParseNode_traitAssertion : public ParseNode { public: ~ParseNode_traitAssertion(); void process(); };
    class ParseNode_expression : public ParseNode { public: ~ParseNode_expression(); void process(); };
    class ParseNode_expr0 : public ParseNode { public: ~ParseNode_expr0(); void process(); };
    class ParseNode_identifier : public ParseNode { public: ~ParseNode_identifier(); void process(); };
    class ParseNode_suffixFunction : public ParseNode { public: ~ParseNode_suffixFunction(); void process(); };
    class ParseNode_expr1 : public ParseNode { public: ~ParseNode_expr1(); void process(); };
    class ParseNode_suffixInc : public ParseNode { public: ~ParseNode_suffixInc(); void process(); };
    class ParseNode_suffixDec : public ParseNode { public: ~ParseNode_suffixDec(); void process(); };
    class ParseNode_copy : public ParseNode { public: ~ParseNode_copy(); void process(); };
    class ParseNode_prefixFunction : public ParseNode { public: ~ParseNode_prefixFunction(); void process(); };
    class ParseNode_expr2 : public ParseNode { public: ~ParseNode_expr2(); void process(); };
    class ParseNode_prefixInc : public ParseNode { public: ~ParseNode_prefixInc(); void process(); };
    class ParseNode_prefixDec : public ParseNode { public: ~ParseNode_prefixDec(); void process(); };
    class ParseNode_plus : public ParseNode { public: ~ParseNode_plus(); void process(); };
    class ParseNode_minus : public ParseNode { public: ~ParseNode_minus(); void process(); };
    class ParseNode_logNot : public ParseNode { public: ~ParseNode_logNot(); void process(); };
    class ParseNode_expr3 : public ParseNode { public: ~ParseNode_expr3(); void process(); };
    class ParseNode_multiplication : public ParseNode { public: ~ParseNode_multiplication(); void process(); };
    class ParseNode_crossProduct : public ParseNode { public: ~ParseNode_crossProduct(); void process(); };
    class ParseNode_dotProduct : public ParseNode { public: ~ParseNode_dotProduct(); void process(); };
    class ParseNode_division : public ParseNode { public: ~ParseNode_division(); void process(); };
    class ParseNode_divisionInt : public ParseNode { public: ~ParseNode_divisionInt(); void process(); };
    class ParseNode_modulo : public ParseNode { public: ~ParseNode_modulo(); void process(); };
    class ParseNode_expr4 : public ParseNode { public: ~ParseNode_expr4(); void process(); };
    class ParseNode_addition : public ParseNode { public: ~ParseNode_addition(); void process(); };
    class ParseNode_subtraction : public ParseNode { public: ~ParseNode_subtraction(); void process(); };
    class ParseNode_expr5 : public ParseNode { public: ~ParseNode_expr5(); void process(); };
    class ParseNode_shiftL : public ParseNode { public: ~ParseNode_shiftL(); void process(); };
    class ParseNode_shiftR : public ParseNode { public: ~ParseNode_shiftR(); void process(); };
    class ParseNode_expr6 : public ParseNode { public: ~ParseNode_expr6(); void process(); };
    class ParseNode_compLess : public ParseNode { public: ~ParseNode_compLess(); void process(); };
    class ParseNode_compGreat : public ParseNode { public: ~ParseNode_compGreat(); void process(); };
    class ParseNode_compLeEq : public ParseNode { public: ~ParseNode_compLeEq(); void process(); };
    class ParseNode_compGrEq : public ParseNode { public: ~ParseNode_compGrEq(); void process(); };
    class ParseNode_expr7 : public ParseNode { public: ~ParseNode_expr7(); void process(); };
    class ParseNode_compEqual : public ParseNode { public: ~ParseNode_compEqual(); void process(); };
    class ParseNode_compNotEq : public ParseNode { public: ~ParseNode_compNotEq(); void process(); };
    class ParseNode_compAssigned : public ParseNode { public: ~ParseNode_compAssigned(); void process(); };
    class ParseNode_compNotAss : public ParseNode { public: ~ParseNode_compNotAss(); void process(); };
    class ParseNode_expr8 : public ParseNode { public: ~ParseNode_expr8(); void process(); };
    class ParseNode_logAnd : public ParseNode { public: ~ParseNode_logAnd(); void process(); };
    class ParseNode_expr9 : public ParseNode { public: ~ParseNode_expr9(); void process(); };
    class ParseNode_logXOr : public ParseNode { public: ~ParseNode_logXOr(); void process(); };
    class ParseNode_expr10 : public ParseNode { public: ~ParseNode_expr10(); void process(); };
    class ParseNode_logOr : public ParseNode { public: ~ParseNode_logOr(); void process(); };
    class ParseNode_exprLeast : public ParseNode { public: ~ParseNode_exprLeast(); void process(); };
    class ParseNode_literal : public ParseNode { public: ~ParseNode_literal(); void process(); };
    class ParseNode_valueLiteral : public ParseNode { public: ~ParseNode_valueLiteral(); void process(); };
    class ParseNode_listLiteral : public ParseNode { public: ~ParseNode_listLiteral(); void process(); };
    class ParseNode_setLiteral : public ParseNode { public: ~ParseNode_setLiteral(); void process(); };
    class ParseNode_dictLiteral : public ParseNode { public: ~ParseNode_dictLiteral(); void process(); };
    class ParseNode_dictEntry : public ParseNode { public: ~ParseNode_dictEntry(); void process(); };
    class ParseNode_contextLiteral : public ParseNode { public: ~ParseNode_contextLiteral(); void process(); };
    class ParseNode_memberDecl : public ParseNode { public: ~ParseNode_memberDecl(); void process(); };
    class ParseNode_statement : public ParseNode { public: ~ParseNode_statement(); void process(); };
    class ParseNode_definition : public ParseNode { public: ~ParseNode_definition(); void process(); };
    class ParseNode_varDeclaration : public ParseNode { public: ~ParseNode_varDeclaration(); void process(); };
    class ParseNode_refDeclaration : public ParseNode { public: ~ParseNode_refDeclaration(); void process(); };
    class ParseNode_varRefDeclBody : public ParseNode { public: ~ParseNode_varRefDeclBody(); void process(); };
    class ParseNode_varRefDeclEntry : public ParseNode { public: ~ParseNode_varRefDeclEntry(); void process(); };
    class ParseNode_varRefDeclEntryEqual : public ParseNode { public: ~ParseNode_varRefDeclEntryEqual(); void process(); };
    class ParseNode_varRefDeclEntryAssign : public ParseNode { public: ~ParseNode_varRefDeclEntryAssign(); void process(); };
    class ParseNode_ifStat : public ParseNode { public: ~ParseNode_ifStat(); void process(); };
    class ParseNode_elseStatPart : public ParseNode { public: ~ParseNode_elseStatPart(); void process(); };
    class ParseNode_loopStat : public ParseNode { public: ~ParseNode_loopStat(); void process(); };
    class ParseNode_loopStatPart : public ParseNode { public: ~ParseNode_loopStatPart(); void process(); };
    class ParseNode_timesLoopStatPart : public ParseNode { public: ~ParseNode_timesLoopStatPart(); void process(); };
    class ParseNode_forLoopStatPart : public ParseNode { public: ~ParseNode_forLoopStatPart(); void process(); };
    class ParseNode_whileLoopStatPart : public ParseNode { public: ~ParseNode_whileLoopStatPart(); void process(); };
    class ParseNode_jumpStat : public ParseNode { public: ~ParseNode_jumpStat(); void process(); };
    class ParseNode_breakStat : public ParseNode { public: ~ParseNode_breakStat(); void process(); };
    class ParseNode_continueStat : public ParseNode { public: ~ParseNode_continueStat(); void process(); };
    class ParseNode_returnStat : public ParseNode { public: ~ParseNode_returnStat(); void process(); };
    class ParseNode_withStat : public ParseNode { public: ~ParseNode_withStat(); void process(); };
    class ParseNode_withStatEntry : public ParseNode { public: ~ParseNode_withStatEntry(); void process(); };
    class ParseNode_assignmentEqual : public ParseNode { public: ~ParseNode_assignmentEqual(); void process(); };
    class ParseNode_assignRef : public ParseNode { public: ~ParseNode_assignRef(); void process(); };
    class ParseNode_changeVal : public ParseNode { public: ~ParseNode_changeVal(); void process(); };
    class ParseNode_addChangeVal : public ParseNode { public: ~ParseNode_addChangeVal(); void process(); };
    class ParseNode_subChangeVal : public ParseNode { public: ~ParseNode_subChangeVal(); void process(); };
    class ParseNode_mulChangeVal : public ParseNode { public: ~ParseNode_mulChangeVal(); void process(); };
    class ParseNode_crossChangeVal : public ParseNode { public: ~ParseNode_crossChangeVal(); void process(); };
    class ParseNode_dotChangeVal : public ParseNode { public: ~ParseNode_dotChangeVal(); void process(); };
    class ParseNode_divChangeVal : public ParseNode { public: ~ParseNode_divChangeVal(); void process(); };
    class ParseNode_intDivChangeVal : public ParseNode { public: ~ParseNode_intDivChangeVal(); void process(); };
    class ParseNode_modChangeVal : public ParseNode { public: ~ParseNode_modChangeVal(); void process(); };
    class ParseNode_shiftRChangeVal : public ParseNode { public: ~ParseNode_shiftRChangeVal(); void process(); };
    class ParseNode_shiftLChangeVal : public ParseNode { public: ~ParseNode_shiftLChangeVal(); void process(); };
    class ParseNode_andChangeVal : public ParseNode { public: ~ParseNode_andChangeVal(); void process(); };
    class ParseNode_orChangeVal : public ParseNode { public: ~ParseNode_orChangeVal(); void process(); };
    class ParseNode_xorChangeVal : public ParseNode { public: ~ParseNode_xorChangeVal(); void process(); };


    // State utils
    struct StateSet;
    struct State;
    using StatePtr = std::shared_ptr<State>;
    using NextFuncT = bool (*)(StatePtr curState, StateSet& nextStates, const Token& token);// returns whether the token matches
    
    struct State {
        NextFuncT nextFunc;
        std::set<StatePtr> parentStates;
        // This points to the current node, where we store the variables
        ParseNodePtr node = nullptr;
        std::list<ParseNodePtr*> outputVars;// save to vars on confirm
        size_t childStateCtr = 0;
        
        inline State(NextFuncT nextFunc): nextFunc(nextFunc) {}
        State() = default;
        State(const State&) = default;
        State(State&&) = default;
        State& operator=(const State&) = default;
        State& operator=(State&&) = default;
        
    };
    
    struct StateComparatorLess {
        using is_transparent = std::true_type;
        
        inline bool operator()(const StatePtr& left, const StatePtr& right) const {
            return (left->nextFunc < right->nextFunc);
        }
        inline bool operator()(const NextFuncT& left, const StatePtr& right) const {
            return (left < right->nextFunc);
        }
        inline bool operator()(const StatePtr& left, const NextFuncT& right) const {
            return (left->nextFunc < right);
        }
    };
    
    class StateSet {
    public:
        std::set<StatePtr, StateComparatorLess> stdSet;
        std::set<StatePtr, StateComparatorLess> stdSetHidden;
        
        inline StatePtr operator[](NextFuncT nextFunc) {
            auto it = stdSet.find(nextFunc);
            if (it == stdSet.end()) {
                it = stdSetHidden.find(nextFunc);
                if (it == stdSetHidden.end()) {
                    it = stdSet.insert(std::make_shared<State>(nextFunc)).first;
                } else {
                    StatePtr statePtr = *it;
                    stdSetHidden.erase(it);
                    it = stdSet.insert(statePtr).first;
                }
            }
            return *it;
        }
        inline StatePtr getHidden(NextFuncT nextFunc) {
            auto it = stdSet.find(nextFunc);
            if (it == stdSet.end()) {
                it = stdSetHidden.find(nextFunc);
                if (it == stdSetHidden.end()) {
                    it = stdSetHidden.insert(std::make_shared<State>(nextFunc)).first;
                }
            }
            return *it;
        }
        
        inline size_t size() const {return stdSet.size();}
        inline std::set<StatePtr, StateComparatorLess>::iterator begin() {return stdSet.begin();}
        inline std::set<StatePtr, StateComparatorLess>::iterator end() {return stdSet.end();}
        
    };

    class ParserError {
    public:
        inline ParserError(Token token, std::wstring msg): token(token), msg(msg) {{}}
        std::wstring msg;
        Token token;
    };

    ParseNodePtr parse(const std::list<Token> &input, std::list<ParserError>& outErrors);

}
