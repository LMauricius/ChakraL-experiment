// This file is autogenerated. Do not edit!

#include <list>
#include <string>
#include <vector>
#include <array>

namespace ChakraL {

    enum class TokenType {
        L_IDENTIFIER,
        L_NUM_LIT,
        L_NUM_B_LIT,
        L_NUM_O_LIT,
        L_NUM_X_LIT,
        L_STR_LIT,
        L_CHAR_LIT,
        L_NEW_LN,
        L_COMMA,
        L_SEMICOLON,
        L_COLON,
        L_OK,
        L_IN,
        L_ADD,
        L_SUB,
        L_MUL,
        L_DIV,
        L_INT_DIV,
        L_MOD,
        L_SHIFT_RIGHT,
        L_SHIFT_LEFT,
        L_AND,
        L_OR,
        L_XOR,
        L_CROSS,
        L_DOT,
        L_CHANGE,
        L_ASSIGN,
        L_ADD_CHANGE,
        L_INCREMENT,
        L_DECREMENT,
        L_SUB_CHANGE,
        L_MUL_CHANGE,
        L_DIV_CHANGE,
        L_INT_DIV_CHANGE,
        L_MOD_CHANGE,
        L_SHIFT_RIGHT_CHANGE,
        L_SHIFT_LEFT_CHANGE,
        L_AND_CHANGE,
        L_OR_CHANGE,
        L_XOR_CHANGE,
        L_CROSS_CHANGE,
        L_DOT_CHANGE,
        L_NOT,
        L_EQUAL,
        L_NOTEQ,
        L_ASSIGNED,
        L_NOTASS,
        L_LESS,
        L_GREAT,
        L_LEEQ,
        L_GREQ,
        L_TRAIT_AND,
        L_TRAIT_OR,
        L_TRAIT_AND_COND,
        L_TRAIT_COND,
        L_QUEST,
        L_LEFT_PAR,
        L_RIGHT_PAR,
        L_LEFT_BRACK,
        L_RIGHT_BRACK,
        L_LEFT_BRACE,
        L_RIGHT_BRACE,
        L_MEMBER,
        L_FUNCTION,
        L_COROUTINE,
        L_IF,
        L_ELSE,
        L_ELIF,
        L_SWITCH,
        L_CASE,
        L_TIMES,
        L_FOR,
        L_WHILE,
        L_REPEAT,
        L_BREAK,
        L_CONTINUE,
        L_RETURN,
        L_YIELD,
        L_WITH,
        L_DEF,
        L_CONST,
        L_VAR,
        L_REF,
        L_NEW,
        L_FINAL,
        L_MUTABLE,
        L_VOLATILE,
        L_STATIC,
        L_USING,
        L_INCLUDE,
        L_AS,
        L_LIT_SUFFIX,
    };

    extern const std::array<std::string, 93> TokenNames;

    enum class LexerState {
        S_START,
        S_LITERAL,
        S_SINGLELINE_COMMENT,
        S_MULTILINE_COMMENT,
    };

    class Token {
    public:
        TokenType type;
        std::wstring str;
        int line;
        int character;
    };

    class LexerError {
    public:
        inline LexerError(int line, int character, std::wstring msg): line(line), character(character), msg(msg) {{}}
        std::wstring msg;
        int line;
        int character;
    };

    std::list<Token> tokenize(std::wstring &input, std::list<LexerError>& outErrors);

}
