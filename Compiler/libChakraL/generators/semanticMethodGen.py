from __future__ import annotations
import os
from typing import OrderedDict
from genUtil import *
from parserGenShared import *

class Member:

    def __init__(self, name:str, type:str, val:str = "") -> None:
        self.name = name
        self.type = type
        self.val = val

    @classmethod
    def fromDefinition(self, line:str, lineInd:int) -> Member:
        typeMarkInd = line.find("->")
        if typeMarkInd == -1:
            raise FormatError("'->' type mark not found but required", lineInd)

        name = line[0:typeMarkInd].strip()
        
        defaultValMarkInd = line.find("=", typeMarkInd+2)
        if defaultValMarkInd == -1:
            type = line[typeMarkInd+2:].strip()
            val = ""
        else:
            type = line[typeMarkInd+2:defaultValMarkInd].strip()
            val = line[defaultValMarkInd+1:].strip()
        
        return Member(name, type, val)


class SemanticNode:
    def __init__(self) -> None:
        self.privateMembers : OrderedDict[str, Member] = OrderedDict()
        self.protectedMembers : OrderedDict[str, Member] = OrderedDict()
        self.publicMembers : OrderedDict[str, Member] = OrderedDict()
        self.methods : OrderedDict[str, Member] = OrderedDict()

def loadSemanticNodes(filename: str):
    print("Loading semantic nodes ", filename)

    lines = meaningfulLines(filename)
    semNodes : OrderedDict[str, SemanticNode] = OrderedDict()
    curNodeName = ""
    curNode = None

    try:
        lineInd = 0
        l, lineInd = next(lines, ("",-1))


        while len(l):
            if l[0] == "@":
                curNodeName = l[1:]
                curNode = semNodes.setdefault(curNodeName, SemanticNode())
            else:
                spaceInd = l.find(" ")
                mark = l[0:spaceInd].strip()
                memberDef = l[spaceInd:].strip()
                if mark == "fpub":
                    newM = Member.fromDefinition(memberDef, lineInd)
                    curNode.publicMembers.setdefault(newM.name, newM)
                    curNode.methods.setdefault(newM.name, newM)
                elif mark == "fprot":
                    newM = Member.fromDefinition(memberDef, lineInd)
                    curNode.protectedMembers.setdefault(newM.name, newM)
                    curNode.methods.setdefault(newM.name, newM)
                elif mark == "fpriv":
                    newM = Member.fromDefinition(memberDef, lineInd)
                    curNode.privateMembers.setdefault(newM.name, newM)
                    curNode.methods.setdefault(newM.name, newM)
                elif mark == "vpub":
                    newM = Member.fromDefinition(memberDef, lineInd)
                    curNode.publicMembers.setdefault(newM.name, newM)
                elif mark == "vprot":
                    newM = Member.fromDefinition(memberDef, lineInd)
                    curNode.protectedMembers.setdefault(newM.name, newM)
                elif mark == "vpriv":
                    newM = Member.fromDefinition(memberDef, lineInd)
                    curNode.privateMembers.setdefault(newM.name, newM)
                else:
                    raise FormatError(f"Unknown node mark '{mark}'", lineInd)

            l, lineInd = next(lines, ("",-1))

    except FormatError as e:
        print("At line " + str(e.lineInd) + ": " + e.message)
        sys.exit(1)
    except StopIteration:
        pass

    return semNodes

def writeSemanticNodesMethodsH(semNodes: OrderedDict[str, SemanticNode], filename: str, headerfile: str, extraheaderfiles: list[str]):

    print("Writing new parser nodes process definitions ", filename)
    with open(filename, "wt") as f:

        def TB():
            f.write('    ')
        def LN(s: str):
            f.write(s)
            f.write('\n')

        LN("// This file is autogenerated. Do not edit!")
        LN("")
        for hf in extraheaderfiles+[headerfile]:
            LN(f'#include "{os.path.relpath(hf, start=os.path.dirname(filename))}"')
        
        #LN('#include <vector>')
        #LN('#include <string_view>')
        #LN('#include <regex>')
        LN("")
        LN("namespace ChakraL")
        LN("{")
        TB();LN("")
        
        for name, semNode in semNodes.items():
            TB();LN(f"class SemanticNode_{name};")
        TB();LN("")

        for name, semNode in semNodes.items():
            TB();LN(f"class SemanticNode_{name}")
            TB();LN(f"{{")

            for visMark, members in [
                ("public", semNode.publicMembers.values()),
                ("protected", semNode.protectedMembers.values()),
                ("private", semNode.privateMembers.values())
            ]:
                if len(members) > 0:
                    TB();LN(f"{visMark}:")
                    for mem in members:
                        if len(mem.val) > 0:
                            TB();TB();LN(f"{mem.type} {mem.name} = {mem.val};")
                        else:
                            TB();TB();LN(f"{mem.type} {mem.name};")

            TB();LN(f"}};")
            TB();LN("")
        LN("}")

def writeSemanticNodesMethodsCPP(semNodes: OrderedDict[str, SemanticNode], filename: str, headerfile: str, extraheaderfiles: list[str]):
    definitions: dict[str, str] = {}
    for className, semNode in semNodes.items():
        #declarations[name] = "    SemanticNode_" + name + "::process("
        for methName, meth in semNode.methods.items():
            definitions[f"{meth.type} {className}::{methName}"] = ""

    print("Reading old parser nodes process definitions ", filename)
    try:
        with open(filename, "rt") as f:
            curDef = ""
            for line in f:
                if "SemanticNode_" in line:
                    curDef = line[0:line.find("{")].strip()
                elif line.startswith("    }"):
                    curDef = ""
                elif len(curDef) > 0:
                    definitions[curDef] += line
    except FileNotFoundError:
        print("No old parser nodes process definitions found")

    print("Writing new parser nodes process definitions ", filename)
    with open(filename, "wt") as f:

        def TB():
            f.write('    ')
        def LN(s: str):
            f.write(s)
            f.write('\n')

        LN("// This file is autogenerated. Edit only function bodies!")
        LN("")
        for hf in extraheaderfiles+[headerfile]:
            LN(f'#include "{os.path.relpath(hf, start=os.path.dirname(filename))}"')
        
        #LN('#include <vector>')
        #LN('#include <string_view>')
        #LN('#include <regex>')
        LN("")
        LN("namespace ChakraL")
        LN("{")
        TB();LN("")
        for name, definition in definitions.items():
            LN("    " + name + " {")
            f.write(definition)
            LN("    }")
            TB();LN("")
        LN("}")