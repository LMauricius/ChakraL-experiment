from __future__ import annotations
import os
from typing import OrderedDict
from genUtil import *
from parserGenShared import *

class Member:
    def __init__(self, line:str, lineInd:int) -> None:
        typeMarkInd = line.find("->")
        if typeMarkInd == -1:
            raise FormatError("'->' type mark not found but required", lineInd)

        self.name = line[0:typeMarkInd].strip()
        
        defaultValMarkInd = line.find("=", typeMarkInd+2)
        if defaultValMarkInd == -1:
            self.type = line[typeMarkInd+2:].strip()
            self.val = ""
        else:
            self.type = line[typeMarkInd+2:defaultValMarkInd].strip()
            self.val = line[defaultValMarkInd+1:].strip()


class SemanticNode:
    def __init__(self) -> None:
        self.privateMembers : list[Member] = []
        self.protectedMembers : list[Member] = []
        self.publicMembers : list[Member] = []
        self.methods : list[Member] = []

def loadSemanticNodes(filename: str):
    print("Loading semantic nodes ", filename)

    lines = meaningfulLines(filename)
    semNodes : OrderedDict[str, SemanticNode] = OrderedDict()
    curNodeName = ""
    curNode = None

    try:
        lineInd = 0
        l, lineInd = next(lines, ("",-1))


        while len(l):
            if l[0] == "@":
                curNodeName = l[1:]
                curNode = semNodes.get(curNodeName, SemanticNode())
            else:
                spaceInd = l.find(" ")
                mark = l[0:spaceInd].strip()
                memberDef = l[spaceInd:].strip()
                if mark == "fpub":
                    newM = Member(memberDef, lineInd)
                    curNode.publicMembers.append(newM)
                    curNode.methods.append(newM)
                elif mark == "fprot":
                    newM = Member(memberDef, lineInd)
                    curNode.protectedMembers.append(newM)
                    curNode.methods.append(newM)
                elif mark == "fpriv":
                    newM = Member(memberDef, lineInd)
                    curNode.privateMembers.append(newM)
                    curNode.methods.append(newM)
                elif mark == "vpub":
                    newM = Member(memberDef, lineInd)
                    curNode.publicMembers.append(newM)
                elif mark == "vprot":
                    newM = Member(memberDef, lineInd)
                    curNode.protectedMembers.append(newM)
                elif mark == "vpriv":
                    newM = Member(memberDef, lineInd)
                    curNode.privateMembers.append(newM)
                else:
                    raise FormatError(f"Unknown node mark '{mark}'", lineInd)

    except FormatError as e:
        print("At line " + str(e.lineInd) + ": " + e.message)
        sys.exit(1)
    except StopIteration:
        pass

    return semNodes

def writeSemanticNodesMethodsH(semNodes: OrderedDict[str, SemanticNode], filename: str, headerfile: str, extraheaderfiles: list[str]):

    print("Writing new parser nodes process definitions ", filename)
    with open(filename, "wt") as f:

        def TB():
            f.write('    ')
        def LN(s: str):
            f.write(s)
            f.write('\n')

        LN("// This file is autogenerated. Do not edit!")
        LN("")
        for hf in extraheaderfiles+[headerfile]:
            LN(f'#include "{os.path.relpath(hf, start=os.path.dirname(filename))}"')
        
        #LN('#include <vector>')
        #LN('#include <string_view>')
        #LN('#include <regex>')
        LN("")
        LN("namespace ChakraL")
        LN("{")
        TB();LN("")
        for name, semNode in semNodes.items():
            TB();LN(f"class SemanticNode_{name} {{")

            for visMark, members in [
                ("public", semNode.publicMembers),
                ("protected", semNode.protectedMembers),
                ("private", semNode.privateMembers)
            ]:
                if len(members) > 0:
                    TB();LN(f"{visMark}:")
                    for mem in members:
                        if len(mem.val) > 0:
                            TB();TB();LN(f"{mem.type} {mem.name} = {mem.val};")
                        else:
                            TB();TB();LN(f"{mem.type} {mem.name};")

            TB();LN(f"}}")
            TB();LN("")
        LN("}")

def writeSemanticNodesMethodsCPP(semNodes: OrderedDict[str, SemanticNode], filename: str, headerfile: str, extraheaderfiles: list[str]):
    definitions: dict[str, str] = {}
    for name, semNode in semNodes.items():
        #declarations[name] = "    SemanticNode_" + name + "::process("
        definitions[name] = ""

    print("Reading old parser nodes process definitions ", filename)
    try:
        with open(filename, "rt") as f:
            curDef = ""
            for line in f:
                if line.startswith("    void SemanticNode_"):
                    curDef = line[len("    void SemanticNode_"):line.find("::")]
                elif line.startswith("    }"):
                    curDef = ""
                elif len(curDef) > 0:
                    definitions[curDef] += line
    except FileNotFoundError:
        print("No old parser nodes process definitions found")

    print("Writing new parser nodes process definitions ", filename)
    with open(filename, "wt") as f:

        def TB():
            f.write('    ')
        def LN(s: str):
            f.write(s)
            f.write('\n')

        LN("// This file is autogenerated. Edit only function bodies!")
        LN("")
        for hf in extraheaderfiles+[headerfile]:
            LN(f'#include "{os.path.relpath(hf, start=os.path.dirname(filename))}"')
        
        #LN('#include <vector>')
        #LN('#include <string_view>')
        #LN('#include <regex>')
        LN("")
        LN("namespace ChakraL")
        LN("{")
        TB();LN("")
        for name, definition in definitions.items():
            LN("    void SemanticNode_" + name + "::process() {")
            f.write(definition)
            LN("    }")
            TB();LN("")
        LN("}")