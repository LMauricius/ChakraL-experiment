from __future__ import annotations
import os
from typing import OrderedDict
from genUtil import *
from parserGenShared import *

class Member:

    def __init__(self, name:str, type:str, val:str = "") -> None:
        self.name = name
        self.type = type
        self.val = val

    @classmethod
    def fromDefinition(self, line:str, lineInd:int) -> Member:
        typeMarkInd = line.find("->")
        if typeMarkInd == -1:
            raise FormatError("'->' type mark not found but required", lineInd)

        name = line[0:typeMarkInd].strip()
        
        defaultValMarkInd = line.find("=", typeMarkInd+2)
        if defaultValMarkInd == -1:
            type = line[typeMarkInd+2:].strip()
            val = ""
        else:
            type = line[typeMarkInd+2:defaultValMarkInd].strip()
            val = line[defaultValMarkInd+1:].strip()
        
        return Member(name, type, val)

NAME_METHOD_DECL = "className() const"
PRINT_METHOD_DECL = "print(std::ostream& out, size_t tabs) const"

class SemanticNode:
    def __init__(self) -> None:
        self.parent : str = "SemanticNode"
        self.privateMembers : OrderedDict[str, Member] = OrderedDict()
        self.protectedMembers : OrderedDict[str, Member] = OrderedDict()
        self.publicMembers : OrderedDict[str, Member] = OrderedDict()
        self.methods : OrderedDict[str, Member] = OrderedDict()

        mem = Member(NAME_METHOD_DECL, "std::string_view")
        self.publicMembers[mem.name] = mem
        self.methods[mem.name] = mem
        mem = Member(PRINT_METHOD_DECL, "void")
        self.publicMembers[mem.name] = mem
        self.methods[mem.name] = mem

def loadSemanticNodes(filename: str):
    print("Loading semantic nodes ", filename)

    lines = meaningfulLines(filename)
    semNodes : OrderedDict[str, SemanticNode] = OrderedDict()
    curNodeName = ""
    curNode = None

    try:
        lineInd = 0
        l, lineInd = next(lines, ("",-1))


        while len(l):
            if l[0] == "@":
                curNodeName = l[1:]
                curNode = semNodes.setdefault(curNodeName, SemanticNode())
            else:
                spaceInd = l.find(" ")
                mark = l[0:spaceInd].strip()
                memberDef = l[spaceInd:].strip()
                
                if mark == "parent":
                    curNode.parent = "SemanticNode_" + memberDef
                elif mark == "fpub":
                    newM = Member.fromDefinition(memberDef, lineInd)
                    curNode.publicMembers.setdefault(newM.name, newM)
                    curNode.methods.setdefault(newM.name, newM)
                elif mark == "fprot":
                    newM = Member.fromDefinition(memberDef, lineInd)
                    curNode.protectedMembers.setdefault(newM.name, newM)
                    curNode.methods.setdefault(newM.name, newM)
                elif mark == "fpriv":
                    newM = Member.fromDefinition(memberDef, lineInd)
                    curNode.privateMembers.setdefault(newM.name, newM)
                    curNode.methods.setdefault(newM.name, newM)
                elif mark == "vpub":
                    newM = Member.fromDefinition(memberDef, lineInd)
                    curNode.publicMembers.setdefault(newM.name, newM)
                elif mark == "vprot":
                    newM = Member.fromDefinition(memberDef, lineInd)
                    curNode.protectedMembers.setdefault(newM.name, newM)
                elif mark == "vpriv":
                    newM = Member.fromDefinition(memberDef, lineInd)
                    curNode.privateMembers.setdefault(newM.name, newM)
                else:
                    raise FormatError(f"Unknown node mark '{mark}'", lineInd)

            l, lineInd = next(lines, ("",-1))

    except FormatError as e:
        print("At line " + str(e.lineInd) + ": " + e.message)
        sys.exit(1)
    except StopIteration:
        pass

    return semNodes

def writeSemanticNodesMethodsH(semNodes: OrderedDict[str, SemanticNode], filename: str, lexerHeaderfile: str, extraheaderfiles: list[str]):

    print("Writing new parser nodes process definitions ", filename)
    with open(filename, "wt") as f:

        def TB():
            f.write('    ')
        def LN(s: str):
            f.write(s)
            f.write('\n')

        LN("// This file is autogenerated. Do not edit!")
        LN("")
        for hf in extraheaderfiles+[lexerHeaderfile]:
            LN(f'#include "{os.path.relpath(hf, start=os.path.dirname(filename))}"')
        
        #LN('#include <vector>')
        #LN('#include <string_view>')
        #LN('#include <regex>')
        LN("")
        LN("namespace ChakraL")
        LN("{")
        TB();LN("")
        
        for name, semNode in semNodes.items():
            TB();LN(f"class SemanticNode_{name};")
        TB();LN("")

        for name, semNode in semNodes.items():
            TB();LN(f"class SemanticNode_{name} : public {semNode.parent}")
            TB();LN(f"{{")
            TB();LN(f"public:")
            TB();TB();LN(f"SemanticNode_{name}() = default;")
            TB();TB();LN(f"~SemanticNode_{name}() = default;")

            for visMark, members in [
                ("public", semNode.publicMembers.values()),
                ("protected", semNode.protectedMembers.values()),
                ("private", semNode.privateMembers.values())
            ]:
                if len(members) > 0:
                    TB();LN(f"{visMark}:")
                    for mem in members:
                        if len(mem.val) > 0:
                            TB();TB();LN(f"{mem.type} {mem.name} = {mem.val};")
                        else:
                            TB();TB();LN(f"{mem.type} {mem.name};")

            TB();LN(f"}};")
            TB();LN("")
        LN("}")

def writeSemanticNodesMethodsCPP(semNodes: OrderedDict[str, SemanticNode], filename: str, headerfile: str, extraheaderfiles: list[str]):
    definitions: dict[str, str] = {}
    for className, semNode in semNodes.items():
        #declarations[name] = "    SemanticNode_" + name + "::process("
        for methName, meth in semNode.methods.items():
            definitions[f"{meth.type} SemanticNode_{className}::{methName}"] = ""

    print("Reading old parser nodes process definitions ", filename)
    try:
        with open(filename, "rt") as f:
            curDef = ""
            for line in f:
                if "SemanticNode_" in line:
                    curDef = line[0:line.find("{")].strip()
                elif line.startswith("    }"):
                    curDef = ""
                elif len(curDef) > 0:
                    definitions[curDef] += line
    except FileNotFoundError:
        print("No old parser nodes process definitions found")

    for className, semNode in semNodes.items():
        
        meth = semNode.methods[NAME_METHOD_DECL]
        definitions[f"{meth.type} SemanticNode_{className}::{meth.name}"] = f"\t\treturn \"{className}\";\n"
        
        meth = semNode.methods[PRINT_METHOD_DECL]
        curdef = ""
        for memName, mem in semNode.publicMembers.items():
            if mem.type.startswith("Ptr<SemanticNode_"):
                curdef += "\t\t" + fr'{{for (size_t i = 0; i<tabs; i++) out << "\t";}} out << "{mem.name}: {{" << std::endl; {mem.name}->print(out, tabs+1); {{for (size_t i = 0; i<tabs; i++) out << "\t";}} out << "}}" << std::endl; ' + "\n"
            elif mem.type.startswith("std::list<Ptr<SemanticNode_"):
                curdef += "\t\t" + fr'{{for (size_t i = 0; i<tabs; i++) out << "\t";}} out << "{mem.name}: [" << std::endl;' + "\n"
                curdef += "\t\t" + fr'for (auto& ptr : {mem.name}) {{{{for (size_t i = 0; i<tabs+1; i++) out << "\t";}}; out << "{{" << std::endl; ptr->print(out, tabs+2); {{for (size_t i = 0; i<tabs+1; i++) out << "\t";}}; out << "}}," << std::endl; }}' + "\n"
                curdef += "\t\t" + fr'{{for (size_t i = 0; i<tabs; i++) out << "\t";}} out << "]" << std::endl;' + "\n"
        definitions[f"{meth.type} SemanticNode_{className}::{meth.name}"] = curdef


    print("Writing new parser nodes process definitions ", filename)
    with open(filename, "wt") as f:

        def TB():
            f.write('    ')
        def LN(s: str):
            f.write(s)
            f.write('\n')

        LN("// This file is autogenerated. Edit only function bodies!")
        LN("")
        for hf in extraheaderfiles+[headerfile]:
            LN(f'#include "{os.path.relpath(hf, start=os.path.dirname(filename))}"')
        LN(f'#include <ostream>')
        
        #LN('#include <vector>')
        #LN('#include <string_view>')
        #LN('#include <regex>')
        LN("")
        LN("namespace ChakraL")
        LN("{")
        TB();LN("")
        for name, definition in definitions.items():
            LN("    " + name + " {")
            f.write(definition)
            LN("    }")
            TB();LN("")
        LN("}")

def semNodeExtends(child:str, parent:str, semNodes: OrderedDict[str, SemanticNode]) -> bool:
    cur = child
    while cur in semNodes:
        if cur == parent:
            return True
        cur = semNodes[cur].parent
    return False