from __future__ import annotations
from genUtil import *

'''
This file contains the function for converting the 'operator table' file
to a parser production list file
'''

def outputOperatorProductions(filenameIn: str, filenameOut: str):
	print("Writing operator productions ", filenameOut)
	f = open(filenameOut, "wt")
	
	def LN(s: str):
		f.write(s)
		f.write('\n')

	try:
		prevNodeName : str = None
		nodeName : str = None
		template = None
		operators: list[str] = []
		semNodeName: str = None
		semNodenames: dict[str, str] = {}

		def checkNotEmpty(s: str)->bool:
			return (len(s) > 0)
		def op2VarOp(op: str)->str:
			if len(op) and op != "''":
				return "operators::"+op
			else:
				return ""
		def ops2RegexSelect(ops: list[str])->str:
			varOpList = list(filter(checkNotEmpty, map(op2VarOp, ops)))
			if len(varOpList):
				return "(" + " | ".join(varOpList) + ")"
			else:
				return ""

		def writeProductions():
			productions: list[str] = []

			# Add operators
			if template is not None and len(operators)>0:
				productions.append(template.format(cur = nodeName, prev = prevNodeName, op = ops2RegexSelect(operators)))
			operators.clear()

			# Allow lower priority exprs
			if prevNodeName is not None:
				if semNodenames[nodeName] == semNodenames[prevNodeName] or True:
					productions.append(".:"+prevNodeName+"")
				else:
					productions.append(".:"+prevNodeName+"")

			# Add productions to expression
			first = True
			for prod in productions:
				if first:
					LN(nodeName + " = " + prod)
				else:
					LN("\t= " + prod)
				first = False

			if semNodeName is not None:
				LN("\t-> Expression " + semNodeName)


		LN("# This file is autogenerated. Do not edit!")

		for l, lineInd in meaningfulLines(filenameIn):
			if l[0] == '@':
				prevNodeName = None
				nodeName = l[1:]
				semNodenames[nodeName] = nodeName
				template = None
			elif l[0] == ':':
				if nodeName is not None:
					writeProductions()
					prevNodeName = None
					semNodeName = None
				LN(l[1:].strip())
			elif l[0] == '<' or l[0] == '>':

				if nodeName is not None:
					writeProductions()
					prevNodeName = None
					semNodeName = None
				prevNodeName = nodeName

				defParts = l.split()
				assoc = defParts[0]
				optype = defParts[1]
				nodeName = defParts[2]
				if len(defParts) >= 4:
					semNodeName = defParts[3]
					semNodenames[nodeName] = semNodeName
				else:
					semNodeName = None
					semNodenames[nodeName] = nodeName

				if assoc == '<' or assoc == '>':
					pass
				else:
					raise FormatError("Expected < or >", lineInd)
				
				if optype == 'BINARY':
					if assoc == '>':
						template = "operands::{prev} ( {op} operands::{prev} )+"
					else:
						template = "operands::{prev} ( {op} operands::{prev} )+"
				elif optype == 'RUNARY':
					if assoc != '>':
						raise FormatError("RUNARY can't be <", lineInd)
					template = "operands::{prev} {op}+"
				elif optype == 'LUNARY':
					if assoc != '<':
						raise FormatError("LUNARY can't be >", lineInd)
					template = "{op}+ operands::{prev}"
				else:
					raise FormatError("Expected BINARY or RUNARY or LUNARY", lineInd)
			else:
				operators.append(l.strip())

		writeProductions()
		prevNodeName = None
		semNodeName = None

	except FormatError as e:
		print("ERROR in \"" + filenameIn + "\", line " + str(e.lineInd) + ": " + e.message)
		sys.exit(1)

	f.close()