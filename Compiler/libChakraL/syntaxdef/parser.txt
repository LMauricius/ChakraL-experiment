# Newlines and leading whitespace chars are skipped in this file
# Lines starting with a '#' are comments
# Each line is a production definition, formatted as PARSE_NODE_TYPE = DEFINITION.
# The first definition specifies the starting (root) node.
# The definition works similar to a regex.
#	Instead of characters we use either parse node names or lexeme names.
#		Parse node names are enclosed with chevrons ('<' and '>')
#		Lexemes are referenced by their names or corresponding single-quoted strings.
#		Both are called 'symbols' in the rest of this comment
#	'*' is used for 0 or more repeating sequences
#	'+' is used for 1 or more repeating sequences
#	'|' is used for selecting a single sequence out of several separated by '|'
#	parentheses ( '(' and ')' ) can be used for grouping the sub sequence
#	'?' makes the sequence optional. Alternatively the sequence can be surrounded with brackets ('[' and ']')
#	The symbols can be stored as named arguments by prefixing them with the argument name
#		followed by a semicolon ( NAME:SYMBOL ), without any spaces.
#		For parse node symbols, the argument name must be put inside the chevrons ('<' and '>')
#		For lexeme names the arg name is put immediately before the symbol ( NAME:LEXEME )
#		For lexeme strings the arg name is put immediately before the opening quote ( NAME:'QUOTE' )
#		If no argument name is specified (no prefix), it is assumed to be "" (empty string)
#		If a parse node symbol prefixed only by a ':', the node isn't stored and
#			all its arguments are stored in its parent node instead (the applied definition's node)
#
# Lines starting with a '=' (without a parse node type symbol)
# 	are alternate definitions for the last specified symbol.
#	This is a cleaner way than using '|'
# Instead of lexeme names, strings corresponding to a specific lexer rule's regex can be used,
# 	enclosed with double quotes. The first regex that the string fits is used and
# 	the string is replaced with the lexeme that the rule outputs.
#	The string allows c-like escape characters

# For each 

file = <:contextBody>

###
### *** utils *** ###
###
ONL = "\n"*


###
### *** Context definitions *** ###
###

contextBody = ( <descs:contextDescriptionEntry> | "\n")*
contextBodyClosedBlock 	= <descs:contextDescriptionEntry>
						= "\n" <:contextBody> "ok"

contextDescriptionEntry = <:statement> "\n"
						= <:traitAssertion> "\n"

traitAssertion = "??" <cond:expression>


###
### *** Expressions and values *** ###
###

expression = <:exprLeast>

# 0th priority expression
exprHighest = <:identifier>
			= "(" <ONL> <:expression> ")" <ONL>
			= <:literal>

identifier = name:L_IDENTIFIER

# expressions are auto generated from the table in expressionOrder.txt
>> autogeneratedParserExpressions.txt

literal 	= <:contextLiteral>
			= <:valueLiteral>
			= <:listLiteral>
			= <:setLiteral>
			= <:dictLiteral>

valueLiteral 	= val:L_NUM_LIT [ suf:L_LIT_SUFFIX ]
				= val:L_NUM_B_LIT [ suf:L_LIT_SUFFIX ]
				= val:L_NUM_O_LIT [ suf:L_LIT_SUFFIX ]
				= val:L_NUM_X_LIT [ suf:L_LIT_SUFFIX ]
				= val:L_STR_LIT [ suf:L_LIT_SUFFIX ]

listLiteral = "[" <items:expression> ("," <items:expression>)* "]"
			= "[" <ONL> <items:expression> "," (<ONL> <items:expression> ",")* <ONL> "]"
setLiteral 	= "{" <items:expression> ("," <items:expression>)* "}"
			= "{" <ONL> <items:expression> "," (<ONL> <items:expression> ",")* <ONL> "}"
dictLiteral = "{" ":" <items:dictEntry> ("," <items:dictEntry>)* "}"
			= "{" ":" <ONL> <items:dictEntry> "," (<ONL> <items:dictEntry> ",")* <ONL> "}"
dictEntry = <key:expression> ":" <ONL> <value:expression>

contextLiteral 	= "(" <items:memberDecl> ("," <items:memberDecl>)* ")"
				= "(" <ONL> <items:memberDecl> ("," <ONL> <items:memberDecl>)* "," <ONL> ")"
memberDecl 	= member:L_IDENTIFIER "=" <value:expression>
			= <value:expression>


###
### *** Statements *** ###
###

statement 	= <:expression>
			= <:definition>
			= <:varDeclaration>
			= <:assignmentEqual>
			= <:ifStat>
			= <:loopStat>
			= <:jumpStat>
			= <:withStat>

definition 	= "def" <id:identifier> "="? <ONL> <val:expression>
			= "def" <id:identifier> ":" <block:contextBodyClosedBlock>

varDeclaration 	= "var" <body:varRefDeclBody>
refDeclaration 	= "ref" <body:varRefDeclBody>
varRefDeclBody = <items:varRefDeclEntry> ("," <ONL> <items:varRefDeclEntry>)*
varRefDeclEntry 	= <equal:varRefDeclEntryEqual>
				= <assign:varRefDeclEntryAssign>
varRefDeclEntryEqual = <id:identifier> "=" <ONL> <val:expression>
varRefDeclEntryAssign = <id:identifier> "->" <ONL> <val:expression>

ifStat 	= "if" <cond:expression> ":" <exec:statement> [ <elseStatPart> ]
		= "if" <cond:expression> ":" "\n" <exec:contextBody> [ <elseStatPart> ] "ok"
elseStatPart 	= "else" ":" <exec:statement>
				= "else" ":" "\n" <exec:contextBody>
				= "elif" <expression> ":" <exec:statement> [ <elseStatPart> ]
				= "elif" <expression> ":" "\n" <exec:contextBody> [ <elseStatPart> ] "ok"

loopStat = "repeat" <parts:loopStatPart> (";" <parts:loopStatPart>)* ":" <exec:contextBodyClosedBlock>
loopStatPart 	= <:timesLoopStatPart>
				= <:forLoopStatPart>
				= <:whileLoopStatPart>
timesLoopStatPart = "times" <count:expression>
forLoopStatPart = "for" <id:identifier> "in" <iterator:expression>
whileLoopStatPart = "while" <cond:expression>

jumpStat 	= <:breakStat>
			= <:continueStat>
			= <:returnStat>
breakStat = "break"
continueStat = "continue"
returnStat = "return" [ <val:expression> ]

withStat = "with" <entries:withStatEntry> ( "," <entries:withStatEntry> )* ":" <exec:contextBodyClosedBlock>
withStatEntry 	= <id:identifier> "=" <val:expression>
				= <val:expression>


###
### *** Assignments *** ###
###

assignmentEqual = <:assignRef>
				= <:changeVal>
				= <:addChangeVal>
				= <:subChangeVal>
				= <:mulChangeVal>
				= <:crossChangeVal>
				= <:dotChangeVal>
				= <:divChangeVal>
				= <:intDivChangeVal>
				= <:modChangeVal>
				= <:shiftRChangeVal>
				= <:shiftLChangeVal>
				= <:andChangeVal>
				= <:orChangeVal>
				= <:xorChangeVal>

assignRef = <left:expression> ( "->" <ONL> <rights:expression> )+
changeVal = <left:expression> ( "=" <ONL> <rights:expression> )+
addChangeVal = <left:expression> ( "+=" <ONL> <rights:expression> )+
subChangeVal = <left:expression> ( "-=" <ONL> <rights:expression> )+
mulChangeVal = <left:expression> ( "*=" <ONL> <rights:expression> )+
crossChangeVal = <left:expression> ( "×=" <ONL> <rights:expression> )+
dotChangeVal = <left:expression> ( "⋅=" <ONL> <rights:expression> )+
divChangeVal = <left:expression> ( "/=" <ONL> <rights:expression> )+
intDivChangeVal = <left:expression> ( "/%=" <ONL> <rights:expression> )+
modChangeVal = <left:expression> ( "%=" <ONL> <rights:expression> )+
expChangeVal = <left:expression> ( "^=" <ONL> <rights:expression> )+
shiftRChangeVal = <left:expression> ( ">>=" <ONL> <rights:expression> )+
shiftLChangeVal = <left:expression> ( "<<=" <ONL> <rights:expression> )+
andChangeVal = <left:expression> ( "&=" <ONL> <rights:expression> )+
orChangeVal = <left:expression> ( "|=" <ONL> <rights:expression> )+
xorChangeVal = <left:expression> ( "<>=" <ONL> <rights:expression> )+




#	To be considered:
#		If no argument name is specified (no prefix), the symbol won't be stored
#		If a instead of a single semicolon, double semicolon ('::') is placed between the name and the symbol,
#			the argument will be a list in which the symbol will be inserted.