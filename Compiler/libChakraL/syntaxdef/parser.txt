# Newlines and leading whitespace chars are skipped in this file
# Lines starting with a '#' are comments
# Each line is a production definition, formatted as PARSE_NODE_TYPE = DEFINITION.
# The first definition specifies the starting (root) production.
# The definition works similar to a regex.
#	Instead of characters we use either production names or lexeme names.
#		Lexemes are referenced by their names or corresponding single-quoted strings.
#		Both are called 'symbols' in the rest of this comment
#	'*' is used for 0 or more repeating sequences
#	'+' is used for 1 or more repeating sequences
#	'|' is used for selecting a single option out of several sequences separated by '|'
#	parentheses ( '(' and ')' ) can be used for grouping the sub sequence
#	'?' makes the sequence optional. Alternatively the sequence can be surrounded with brackets ('[' and ']')
#	The symbols can be stored as named arguments by prefixing them with the argument name
#		followed by a semicolon ( NAME:SYMBOL ), without any spaces.
#		For lexeme strings the arg name is put immediately before the opening quote ( NAME:'QUOTE' )
#		If no argument name is specified (no prefix), it is assumed to be '' (empty string)
#		If the argument name is a dot ('.'), the symbol's semantic node will be forwarded,
#			and output instead of the production's own node.
#			If any symbol within a production's option is a forwarding symbol,
#				no other symbol can be assigned to a variable within that option
#			The semantic node output from the forwarding symbol must be of the same type as the production's node
#		#############################If a parse node symbol prefixed Only by a ':', the node isn't stored and
#			#########################all its arguments are stored in its parent node instead (the applied definition's node)
#
# Lines starting with a '=' (without a production symbol)
# 	are alternate definitions for the last specified symbol.
#	This is a cleaner way than using '|'
# Lines starting with a '->' define the semantic node that will be output when the current production is parsed
#	'-' is a special string specifying that no semantic node will be output from the production
#	#########################'::' is a special string that specifies a 'fallthrough', i.e. that the semantic node of the first symbol (that outputs a sem. node) will be passed as the output of the current production
# Instead of lexeme names, strings corresponding to a specific lexer rule's regex can be used,
# 	enclosed with double quotes. The first regex that the string fits is used and
# 	the string is replaced with the lexeme that the rule outputs.
#	The string allows c-like escape characters



File = <!> .:Context END_OF_STR
	-> ::


###
### *** Context definitions *** ###
###

Context = ( NL | descs::DescriptionEntry <!> <$> NL)*
ContextLine = descs::DescriptionEntry
			-> Context
#ContextBlock 	= NL <!> (<$> NL | descs::DescriptionEntry <!> NL )* <$> BLOCK_END
#				= descs::DescriptionEntry
#				-> Context

DescriptionEntry 	= .:Statement
					= .:TraitAssertion
					-> ::

TraitAssertion = ASSERT_MARK cond:Expression


###
### *** Expressions and values *** ###
###

Identifier = name:IDENTIFIER

#Expression 	= .:ExprLeast

# 0th priority Expression
ExprHighest = .:Identifier
			= '(' NL* .:Expression NL* ')' 
			= .:Literal

# expressions are auto generated from the table in operatorTable.txt
>> ../autosyntaxdef/operatorProductionsAutogen.txt

Literal 	= .:FunctionLiteral
			= .:CoroutineLiteral
			= .:ContextLiteral
			= .:ValueLiteral
			= .:ListLiteral
			= .:DictLiteral
			= .:SetLiteral
			-> ::

ValueLiteral 	= val:NUM_LIT [ suf:LIT_SUFFIX ]
				= val:NUM_B_LIT [ suf:LIT_SUFFIX ]
				= val:NUM_O_LIT [ suf:LIT_SUFFIX ]
				= val:NUM_X_LIT [ suf:LIT_SUFFIX ]
				= val:STR_LIT [ suf:LIT_SUFFIX ]

ListLiteral = '[' <!> items::Expression (<$> ',' items::Expression)* <$> ']'
			= '[' <!> NL* items::Expression <$> ',' (NL* items::Expression <$> ',')* NL* <$> ']'
SetLiteral 	= '{' <!> items::Expression (<$> ',' items::Expression)* <$> '}'
			= '{' <!> NL* items::Expression <$> ',' (NL* items::Expression <$> ',')* NL* <$> '}'
DictLiteral = '{' ':' <!> items::DictEntry (<$> ',' items::DictEntry)* <$> '}'
			= '{' ':' <!> NL* items::DictEntry <$> ',' (NL* items::DictEntry <$> ',')* NL* <$> '}'
DictEntry = key:Expression ':' <!> NL* value:Expression

ContextLiteral 	= '(' items::MemberDecl (<$> ',' <!> items::MemberDecl)* <$> ')'
				= '(' NL* items::MemberDecl (<$> ',' <!> NL* items::MemberDecl)* <$> ',' NL* <$> ')'
MemberDecl 	= member:IDENTIFIER ( ':' <!> trait:Expression [ '=' <!> value:Expression ] | '=' <!> value:Expression )
			= value:Expression

FunctionLiteral = param:ContextLiteral FUNCTION_EXPR (block:ContextLine | NL <!> block:Context <$> BLOCK_END)
CoroutineLiteral = param:ContextLiteral COROUTINE_EXPR (block:ContextLine | NL <!> block:Context <$> BLOCK_END)


###
### *** Statements *** ###
###

Statement 	= .:Definition
			= .:AssignmentEqual
			= .:IfStat
			= .:LoopStat
			= .:JumpStat
			= .:WithStat
			= .:Expression
			-> ::

Definition 	= DEF <!> id:IDENTIFIER '='? NL* val:Expression
			= DEF <!> id:IDENTIFIER ':' (block:ContextLine | NL <!> block:Context <$> BLOCK_END)

IfStat 	= IF <!> cond:Expression <$> ':' ( exec:ContextLine [ <$> alt:ElseStatPart ] | NL <!> exec:Context ( <$> alt:ElseStatPart | <$> BLOCK_END) )
ElseStatPart 	= ELSE <!> <$> ':' (exec:ContextLine | NL <!> exec:Context <$> BLOCK_END)
				= .:ElifStatPart
ElifStatPart 	= ELIF <!> cond:Expression <$> ':' ( exec:ContextLine [ <$> alt:ElseStatPart ] | NL <!> exec:Context ( <$> alt:ElseStatPart | <$> BLOCK_END) )

LoopStat 	= LOOP_MARK <!> parts::LoopStatPart ( <$> ';' parts::LoopStatPart)* <$> ':' (block:ContextLine | NL <!> block:Context <$> BLOCK_END)
			= .:LoopStatPart <!> <$> ':' (block:ContextLine | <$> NL <!> block:Context <$> BLOCK_END)
LoopStatPart 	= .:TimesLoopStatPart
				= .:ForLoopStatPart
				= .:WhileLoopStatPart
				-> ::
TimesLoopStatPart = TIMES <!> count:Expression
ForLoopStatPart = FOR <!> id:IDENTIFIER IN iterable:Expression
WhileLoopStatPart = WHILE <!> cond:Expression

JumpStat 	= .:BreakStat
			= .:ContinueStat
			= .:ReturnStat
			= .:YieldStat
BreakStat = BREAK <!> [ id:IDENTIFIER ]
ContinueStat = CONTINUE <!> [ id:IDENTIFIER ]
ReturnStat = RETURN <!> [ val:Expression ]
YieldStat = YIELD <!> [ val:Expression ]

WithStat = WITH <!> entries::WithStatEntry ( ',' entries::WithStatEntry )* ':' (block:ContextLine | NL <!> block:Context <$> BLOCK_END)
WithStatEntry 	= id:IDENTIFIER '=' <!> val:Expression
				= val:Expression


###
### *** Assignments *** ###
###

AssignmentEqualOperator = op:ASSIGN
						= op:'='
						= op:'+='
						= op:'-='
						= op:'*='
						= op:CROSS_CHANGE
						= op:DOT_CHANGE
						= op:'/='
						= op:'/%='
						= op:'%='
						= op:'^='
						= op:'>>='
						= op:'<<='
						= op:'&='
						= op:'|='

AssignmentEqual = left:Expression ( operator:AssignmentEqualOperator <!> NL* rights:Expression )+




#	To be considered:
#		If no argument name is specified (no prefix), the symbol won't be stored
#		If a instead of a single semicolon, double semicolon ('::') is placed between the name and the symbol,
#			the argument will be a list in which the symbol will be inserted.