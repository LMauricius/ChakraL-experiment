
<!doctype html>
<html>
    <head>
        <title>value</title>
        <link rel="stylesheet" href="style.css">
        <link rel="stylesheet" href="syntax_style.css">
    </head>

    <body>
        <div class="wrapper">
            <div class="sidebar">
                <div class="tableofcontents">
                    <p class="tableofcontents_title">Contents</p>
                            <li><a href="introduction.html">1&nbspIntroduction</a>
        <ul>
            <li><a href="how_to_read_the_documentation.html">1&nbspHow to read the documentation</a>
            </li>
            <li><a href="language_goals.html">2&nbspLanguage goals</a>
            </li>
            <li><a href="file_format.html">3&nbspFile format</a>
            </li>
            <li><a href="module_system.html">4&nbspModule system</a>
            </li>
        </ul>
        </li>
        <li>2&nbspBasic concepts
        <ul>
            <li><a href="context.html">1&nbspContext</a>
            </li>
            <li><b>2 Value</b>
            </li>
            <li><a href="trait_system.html">3&nbspTrait system</a>
            </li>
        </ul>
        </li>
        <li>3&nbspLanguage features
        <ul>
            <li>1&nbspStatements
            <ul>
                <li><a href="using_statement.html">1&nbspusing statement</a>
                </li>
                <li><a href="if_statement.html">2&nbspif statement</a>
                </li>
            </ul>
            </li>
            <li><a href="expressions.html">2&nbspExpressions</a>
            <ul>
                <li><a href="module_expression.html">1&nbspmodule expression</a>
                </li>
            </ul>
            </li>
        </ul>
        </li>
        <li>4&nbspStandard library
        </li>

                </div>
            </div>
            <div class="main">
                <div class="pagecontent">
                    <h1 id="value">Value</h1>
<h2 id="definition">Definition</h2>
<p>A value is a handle that can be used to access a context and modify
functions that map from it. It consists of 2 components: the data, and
the required trait.</p>
<h2 id="what-are-values">What are values?</h2>
<p>The values can be named constants, variables that can be changed
during the program’s runtime, literals that are explicitly written in
the code and used once etc. Here are few short examples that will be
better explained later in the documentation:</p>
<p><code>3.141592</code> is a numeric value, <code>"Hello world"</code>
is a textual value.</p>
<pre><code>a = b + c</code></pre>
<p>…<code>a</code>, <code>b</code> and <code>c</code> are variable
values</p>
<pre><code>t = &quot;Hello World!&quot;
n = 3</code></pre>
<p>…<code>"Hello World!"</code> and <code>3</code> are literal values,
while <code>t</code> and <code>n</code> are variable values.</p>
<pre><code>PI def 3.141592</code></pre>
<p>…<code>PI</code> is a constant value defined to be equal to the
literal value <code>3.141592</code></p>
<h2 id="the-data">The data</h2>
<p>The data is the context that can be used in functions, assigned to
other values and that can be modified if the value isn’t a constant.</p>
<h2 id="the-trait">The trait</h2>
<p>The trait of a value is the one that the data must satisfy. It is
used to restrict the kinds of data that can be assigned to a value and
keep the programmer’s sanity. The trait can be specified manually, or
inferred from another value whose data is assigned to it.</p>
<p>The trait can be manually specified. For example we can specify
variable value <code>a</code> to have a trait of
<code>Positive &amp; Integer</code> (<code>&amp;</code> combines
multiple traits into one):</p>
<pre><code>a: Integer &amp; Positive = 3</code></pre>
<p>The trait can also be automatically inferred during the first use of
a value. In the example:</p>
<pre><code>a = 3</code></pre>
<p>… <code>a</code>‘s trait will be inferred to be an <code>int32</code>
(a 32-bit signed <code>Integer</code> trait), as the integer literals’
trait is <code>int32</code>.</p>
<p>We chose 32-bit integers as the default because they are a good
compromise between the range of numbers (-2_147_483_647 to
2_147_483_647) and the memory taken (4 bytes). Literals that are outside
that range will be stored as the smallest native <code>Integer</code>
type that fits them. For example:</p>
<pre><code>a = 3 # 3 is int32, a is inferred to be int32
a = -60_000_000_000 # -60_000_000_000 is int64, a is still defined as int32
# the program raises an ERROR: 
# -60_000_000_000 cannot be cast to int32 as it is outside the range of int32</code></pre>
<h2 id="satisfying-the-trait">Satisfying the trait</h2>
<p>The data always satisfies the trait. If the trait is declared with an
<code>explicit</code> keyword, it will only be satisfied if the data is
actually declared to be that type; if not, it will also be satisfied if
the data is similar to the trait (it has the same members, it is
composed of the same sub-contexts). For more details see the chapter <a
href="trait_system.html">Trait system</a>.</p>
<p>An example of not satisfying the trait (we use assignment operator
instead of change, because the change operator can implicitly convert
values to the desired trait):</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode chakral"><code class="sourceCode chakral"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>a : int32 <span class="op">&lt;-</span> new <span class="dv">3</span> <span class="co"># assignment (&lt;-) instead of change (=)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">&lt;-</span> new <span class="st">&quot;Hello world&quot;</span> <span class="co"># ERROR: string is not an int32</span></span></code></pre></div>
<h2 id="similar-ideas-in-other-languages">Similar ideas in other
languages</h2>
<p>variable, constant, literal, pointer, temporary value, rvalue,
lvalue</p>

                </div>
            </div>
        </div>
    </body>
</html>